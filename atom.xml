<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YMLiang</title>
  <icon>https://www.gravatar.com/avatar/949b3d2d55d796bff0595b9b4a58fdde</icon>
  <subtitle>Never forget why you started</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-05T10:49:28.957Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YMLiang</name>
    <email>18135479521@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go开发基础入门——4</title>
    <link href="http://yoursite.com/2019/06/05/Go%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E2%80%94%E2%80%944/"/>
    <id>http://yoursite.com/2019/06/05/Go开发基础入门——4/</id>
    <published>2019-06-05T09:41:37.000Z</published>
    <updated>2019-06-05T10:49:28.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul><li><p>if</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   if 布尔表达式 &#123;</span><br><span class="line">/* 在布尔表达式为 true 时执行 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   *不支持三元操作符(三目运算符) &quot;a &gt; b ? a : b&quot;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   if else：</span><br><span class="line"></span><br><span class="line">   if 布尔表达式 &#123;</span><br><span class="line">   /* 在布尔表达式为 true 时执行 */</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   /* 在布尔表达式为 false 时执行 */</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>for</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Go语言的For循环有3中形式，只有其中的一种使用分号。</span><br><span class="line"></span><br><span class="line">for init; condition; post &#123; &#125;</span><br><span class="line">for condition &#123; &#125;</span><br><span class="line">for &#123; &#125;</span><br><span class="line">init： 一般为赋值表达式，给控制变量赋初值；</span><br><span class="line">condition： 关系表达式或逻辑表达式，循环控制条件；</span><br><span class="line">post： 一般为赋值表达式，给控制变量增量或减量。</span><br><span class="line">for语句执行过程如下：</span><br><span class="line">①先对表达式 init 赋初值；</span><br><span class="line">②判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。</span><br><span class="line"></span><br><span class="line">公式：</span><br><span class="line">for [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">&#123;</span><br><span class="line">    statement(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">替代 while(true)的方法：</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为比较简单，我这里说一个稍微复杂一点的就是 range ，那么请先看range的知识点</span><br><span class="line"></span><br><span class="line">下面是一个栗子：</span><br><span class="line">func changeBigSmallWord(str string) string&#123;</span><br><span class="line">    result := &quot;&quot;</span><br><span class="line">    for i,value := range str&#123;</span><br><span class="line">        if i%2==0 &#123;</span><br><span class="line">            result += strings.ToUpper(string(value))</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            result += strings.ToLower(string(value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">循环时用到range 即迭代传入的 str 相当于遍历了</span><br></pre></td></tr></table></figure></li><li><p>range</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">range = 迭代器的效果</span><br><span class="line">简单理解成遍历没有问题</span><br><span class="line"></span><br><span class="line">for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</span><br><span class="line">result := &quot;&quot;</span><br><span class="line">for key, value := range str &#123;</span><br><span class="line">    result = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for 和 for range有什么区别?</span><br><span class="line"></span><br><span class="line">主要是使用场景不同</span><br><span class="line"></span><br><span class="line">for可以</span><br><span class="line"></span><br><span class="line">遍历array和slice</span><br><span class="line">遍历key为整型递增的map</span><br><span class="line">遍历string</span><br><span class="line"></span><br><span class="line">for range可以完成所有for可以做的事情，却能做到for不能做的，包括</span><br><span class="line"></span><br><span class="line">遍历key为string类型的map并同时获取key和value</span><br><span class="line">遍历channel</span><br></pre></td></tr></table></figure></li><li><p>switch</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>循环控制Goto、Break、Continue</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;if&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   if 布尔表达式 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* 在布尔表达式为 true 时执行 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   *不支持三元操作符(三目运算符) &amp;quot;a &amp;gt; b ? a : b&amp;quot;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   if else：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   if 布尔表达式 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /* 在布尔表达式为 true 时执行 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /* 在布尔表达式为 false 时执行 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go开发基础入门——3</title>
    <link href="http://yoursite.com/2019/06/05/Go%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E2%80%94%E2%80%943/"/>
    <id>http://yoursite.com/2019/06/05/Go开发基础入门——3/</id>
    <published>2019-06-05T08:22:46.000Z</published>
    <updated>2019-06-05T10:49:20.991Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go-向函数传递指针参数"><a href="#Go-向函数传递指针参数" class="headerlink" title="Go 向函数传递指针参数"></a>Go 向函数传递指针参数</h3><ul><li><p>Go 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    /* 定义局部变量 */</span><br><span class="line">    var a int = 100</span><br><span class="line">    var b int = 200</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;交换前 a 的值 : %d\n&quot;, a)</span><br><span class="line">    fmt.Printf(&quot;交换前 b 的值 : %d\n&quot;, b)</span><br><span class="line"></span><br><span class="line">    /* 调用函数用于交换值</span><br><span class="line">    * &amp;a 指向 a 变量的地址</span><br><span class="line">    * &amp;b 指向 b 变量的地址</span><br><span class="line">    */</span><br><span class="line">    swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;交换后 a 的值 : %d\n&quot;, a)</span><br><span class="line">    fmt.Printf(&quot;交换后 b 的值 : %d\n&quot;, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func swap(x *int, y *int) &#123;</span><br><span class="line">    var temp int</span><br><span class="line">    temp = *x /* 保存 x 地址的值 */</span><br><span class="line">    *x = *y   /* 将 y 赋值给 x */</span><br><span class="line">    *y = temp /* 将 temp 赋值给 y */</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">交换前 a 的值 : 100</span><br><span class="line">交换前 b 的值 : 200</span><br><span class="line">交换后 a 的值 : 200</span><br><span class="line">交换后 b 的值 : 100</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="自定义类型Struct"><a href="#自定义类型Struct" class="headerlink" title="自定义类型Struct"></a>自定义类型Struct</h3><ul><li><p>Go中的 struct：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">可将类型分为命名和未命名两大类。命名类型包括 bool、int、string 等，而 array、slice、map 等和具体元素类型、长度等有关，属于未命名类型。</span><br><span class="line"></span><br><span class="line">具有相同声明的未命名类型被视为同一类型。</span><br><span class="line"></span><br><span class="line">• 具有相同基类型的指针。</span><br><span class="line">• 具有相同元素类型和长度的 array。</span><br><span class="line">• 具有相同元素类型的 slice。</span><br><span class="line">• 具有相同键值类型的 map。</span><br><span class="line">• 具有相同元素类型和传送方向的 channel。</span><br><span class="line">• 具有相同字段序列 (字段名、类型、标签、顺序) 的匿名 struct。 </span><br><span class="line">• 签名相同 (参数和返回值，不包括参数名称) 的 function。</span><br><span class="line">• 方法集相同 ( 方法名、方法签名相同，和次序无关) 的 interface。</span><br></pre></td></tr></table></figure></li><li><p>struct 特点：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 用来自定义复杂数据结构</span><br><span class="line">2. struct里面可以包含多个字段（属性）</span><br><span class="line">3. struct类型可以定义方法，注意和函数的区分</span><br><span class="line">4. struct类型是值类型</span><br><span class="line">5. struct类型可以嵌套</span><br><span class="line">6. Go语言没有class类型，只有struct类型</span><br><span class="line">7. 结构体是用户单独定义的类型，不能和其他类型进行强制转换</span><br><span class="line">8. golang中的struct没有构造函数，一般可以使用工厂模式来解决这个问题。</span><br><span class="line">9. 我们可以为struct中的每个字段，写上一个tag。这个tag可以通过反射的机制获取到，最常用的场景就是json序列化和反序列化。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>可以理解为面向对象编程</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct声明及初始化：</span><br><span class="line"></span><br><span class="line">声明：</span><br><span class="line"></span><br><span class="line">type typeName struct &#123;  </span><br><span class="line">//...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">type global struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    type local struct&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">初始化：</span><br><span class="line"></span><br><span class="line">方法有几种：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Test struct &#123;</span><br><span class="line">    int</span><br><span class="line">    string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a Test</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    b := new(Test) //同 var b *Test = new(Test)</span><br><span class="line">    c := Test&#123;1, &quot;c&quot;&#125;</span><br><span class="line">    d := Test&#123;&#125;</span><br><span class="line">    e := &amp;Test&#123;&#125;</span><br><span class="line">    f := &amp;Test&#123;2, &quot;f&quot;&#125; //同 var d *Test = &amp;Test&#123;2, &quot;f&quot;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(a, b, c, d, e, f)</span><br><span class="line">    // 注: a b c d 返回 Test 类型变量；e f 返回 *Test 类型变量；若无初始化值，则默认为零值</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">&#123;0 &#125; &amp;&#123;0 &#125; &#123;1 c&#125; &#123;0 &#125; &amp;&#123;0 &#125; &amp;&#123;2 f&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化值可以分为两种</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">a. 有序: typeName&#123;value1, value2, ...&#125; 必须一一对应</span><br><span class="line">b. 无序: typeName&#123;field1:value1, field2:value2, ...&#125; 可初始化部分值</span><br><span class="line"></span><br><span class="line">栗子：</span><br><span class="line"></span><br><span class="line">a：有序</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age int</span><br><span class="line">    sex int</span><br><span class="line">    phone int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    person := Person&#123;&quot;lff&quot;, 23, 1, 18135479521&#125;</span><br><span class="line">    fmt.Println(person)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b： 无序</span><br><span class="line">func main() &#123;</span><br><span class="line">    p2 := Person&#123;age: 23&#125; //无序，指你可以指定给p2赋哪个字段的值</span><br><span class="line">    fmt.Println(person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>操作 struct </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">声明的struct与普通类型一样</span><br><span class="line">访问结构体中的一个变量名, 用 &quot;.&quot; 来连接:</span><br><span class="line">varName.field 或 (*varName).field</span><br><span class="line">如操作上面 Person 结构体中的 age : p.age = 35</span><br><span class="line">也可以作为函数中的参数，返回值类型</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">举个栗子：</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//1. 声明一个自定义类型名为 Person 的结构体</span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    //2. 初始化</span><br><span class="line">    var p1 Person</span><br><span class="line">    p2 := Person&#123;&#125;</span><br><span class="line">    p3 := Person&#123;&quot;James&quot;, 23&#125;</span><br><span class="line">    p4 := Person&#123;age: 23&#125;</span><br><span class="line">    fmt.Println(p1, p2, p3, p4)</span><br><span class="line">    p5 := new(Person)</span><br><span class="line">    p6 := &amp;Person&#123;&#125;</span><br><span class="line">    p7 := &amp;Person&#123;&quot;James&quot;, 23&#125;</span><br><span class="line">    p8 := &amp;Person&#123;age: 23&#125;</span><br><span class="line">    fmt.Println(p5, p6, p7, p8)</span><br><span class="line"></span><br><span class="line">    //3. 操作</span><br><span class="line">    p1.age = 50</span><br><span class="line">    p2.age = 25</span><br><span class="line">    if compareAge(p1, p2) &#123;</span><br><span class="line">        fmt.Println(&quot;p1 is older than p2&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;p2 is older than p1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func compareAge(p1, p2 Person) bool &#123;</span><br><span class="line">    if p1.age &gt; p2.age &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&#123; 0&#125; &#123; 0&#125; &#123;James 23&#125; &#123; 23&#125;</span><br><span class="line">&amp;&#123; 0&#125; &amp;&#123; 0&#125; &amp;&#123;James 23&#125; &amp;&#123; 23&#125;</span><br><span class="line">p1 is older than p2</span><br></pre></td></tr></table></figure></li><li><p>匿名字段</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">匿名字段：</span><br><span class="line">声明一个 struct1 可以包含已经存在的 struct2 或者go语言中内置类型作为内置字段，称为匿名字段，即只写了 typeName，无 varName，但是 typeName 不能重复。</span><br><span class="line"></span><br><span class="line">匿名字段与面向对象程序语言中的继承</span><br><span class="line"></span><br><span class="line">声明及初始化:</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">    addr string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">    Person //匿名字段</span><br><span class="line">    salary int</span><br><span class="line">    int           //用内置类型作为匿名字段</span><br><span class="line">    addr   string //类似于重载</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    em1 := Employee&#123;Person&#123;&quot;rain&quot;, 23, &quot;qingyangqu&quot;&#125;, 5000, 100, &quot;gaoxingqu&quot;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(em1)</span><br><span class="line">    // var em2 Person = em1</span><br><span class="line">    // Error: cannot use em1 (type Employee) as type Person in assignment （没有继承， 然也不会有多态）</span><br><span class="line"></span><br><span class="line">    var em2 Person = em1.Person // 同类型拷贝。</span><br><span class="line"></span><br><span class="line">    fmt.Println(em2)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">&#123;&#123;Murphy 23 帝都&#125; 5000 100 北京&#125;</span><br><span class="line">&#123;Murphy 23 帝都&#125;</span><br><span class="line">操作</span><br><span class="line"></span><br><span class="line">访问方式也是通过 &quot;.&quot; 来连接</span><br><span class="line">相同字段采用最外层优先访问，类似于重载</span><br><span class="line">em1.addr 访问的是 Employee 中最外层的 addr</span><br><span class="line">em1.Person.addr 访问的是 Employee 中 Person 中的 addr</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">    addr string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">    Person //匿名字段</span><br><span class="line">    salary int</span><br><span class="line">    int           //用内置类型作为匿名字段</span><br><span class="line">    addr   string //类似于重载</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    /*</span><br><span class="line">    var em1 Employee = Employee&#123;&#125;</span><br><span class="line">    em1.Person = Person&#123;&quot;rain&quot;, 23, &quot;帝都&quot;&#125;</span><br><span class="line">    em1.salary = 5000</span><br><span class="line">    em1.int = 100 //使用时注意其意义，此处无</span><br><span class="line">    em1.addr = &quot;北京&quot;</span><br><span class="line">    */</span><br><span class="line">    //em1 := Employee&#123;Person&#123;&quot;rain&quot;, 23, &quot;帝都&quot;&#125;, 5000, 100, &quot;北京&quot;&#125;</span><br><span class="line">    //初始化方式不一样，但是结果一样</span><br><span class="line">    em1 := Employee&#123;Person: Person&#123;&quot;Murphy&quot;, 23, &quot;帝都&quot;&#125;, salary: 5000, int: 100, addr: &quot;北京&quot;&#125;</span><br><span class="line">    fmt.Println(em1)</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;live addr(em1.addr) = &quot;, em1.addr)</span><br><span class="line">    fmt.Println(&quot;work addr(em1.Person.addr) = &quot;, em1.Person.addr)</span><br><span class="line">    em1.int = 200 //修改匿名字段的值</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&#123;&#123;Murphy 23 帝都&#125; 5000 100 北京&#125;</span><br><span class="line">live addr(em1.addr) =  北京</span><br><span class="line">work addr(em1.Person.addr) =  帝都</span><br><span class="line">空结构 &quot;节省&quot; 内存， 如用来实现 set 数据结构，或者实现没有 &quot;状态&quot; 只有方法的 &quot;静态类&quot;。</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var null struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">    set := make(map[string]struct&#123;&#125;)</span><br><span class="line">    set[&quot;a&quot;] = null</span><br><span class="line">&#125;</span><br><span class="line">不能同时嵌入某一类型和其指针类型，因为它们名字相同。</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Resource struct &#123;</span><br><span class="line">    id int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">    *Resource</span><br><span class="line">    // Resource // Error: duplicate field Resource</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    u := User&#123;</span><br><span class="line">        &amp;Resource&#123;1&#125;,</span><br><span class="line">        &quot;Administrator&quot;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(u.id)</span><br><span class="line">    println(u.Resource.id)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Go-向函数传递指针参数&quot;&gt;&lt;a href=&quot;#Go-向函数传递指针参数&quot; class=&quot;headerlink&quot; title=&quot;Go 向函数传递指针参数&quot;&gt;&lt;/a&gt;Go 向函数传递指针参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Go 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import &amp;quot;fmt&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func main() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 定义局部变量 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var a int = 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var b int = 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Printf(&amp;quot;交换前 a 的值 : %d\n&amp;quot;, a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Printf(&amp;quot;交换前 b 的值 : %d\n&amp;quot;, b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 调用函数用于交换值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    * &amp;amp;a 指向 a 变量的地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    * &amp;amp;b 指向 b 变量的地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    swap(&amp;amp;a, &amp;amp;b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Printf(&amp;quot;交换后 a 的值 : %d\n&amp;quot;, a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Printf(&amp;quot;交换后 b 的值 : %d\n&amp;quot;, b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func swap(x *int, y *int) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var temp int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    temp = *x /* 保存 x 地址的值 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *x = *y   /* 将 y 赋值给 x */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *y = temp /* 将 temp 赋值给 y */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出结果：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;交换前 a 的值 : 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;交换前 b 的值 : 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;交换后 a 的值 : 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;交换后 b 的值 : 100&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go开发基础入门——2</title>
    <link href="http://yoursite.com/2019/06/04/Go%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942/"/>
    <id>http://yoursite.com/2019/06/04/Go开发基础入门——2/</id>
    <published>2019-06-04T09:42:56.000Z</published>
    <updated>2019-06-05T10:48:25.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   通过类型前置加一个圆括号</span><br><span class="line">   T(表达式)</span><br><span class="line">   T表示要转化的类型，表达式包括：变量，数值，函数返回值等</span><br><span class="line">   int(8.2)</span><br><span class="line">   int(80.5)</span><br><span class="line">   布尔型无法与其他类型转换</span><br><span class="line"></span><br><span class="line">   int转换为string OK</span><br><span class="line">   string转换为int NO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   eg:</span><br><span class="line">   chinese := 90</span><br><span class="line">english := 90.9</span><br><span class="line">result := string(chinese)</span><br><span class="line"></span><br><span class="line">fmt.Println(chinese,english,result)</span><br><span class="line">   </span><br><span class="line">   90 90.9 Z</span><br></pre></td></tr></table></figure></code></pre><a id="more"></a><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">常量是一个简单值的标识符，在程序运行时，不会被修改的量。</span><br><span class="line"></span><br><span class="line">常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</span><br><span class="line"></span><br><span class="line">常量的定义格式：</span><br><span class="line">const identifier [type] = value</span><br><span class="line"></span><br><span class="line">你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</span><br><span class="line">显式类型定义： const b string = &quot;abc&quot;</span><br><span class="line">隐式类型定义： const b = &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">多个相同类型的声明可以简写为：</span><br><span class="line">const c_name1, c_name2 = value1, value2</span><br><span class="line"></span><br><span class="line">常量用于枚举(常量组)：</span><br><span class="line">也可以使用 const()定义块，定义多个，每个常量单独一行，例如</span><br><span class="line">const (</span><br><span class="line">  c6 = 42</span><br><span class="line">  c7 = 1000</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const()块定义时，如果常量未给出定义，则延续上面的定义规则，例如：</span><br><span class="line">const (</span><br><span class="line">  c7 = 42</span><br><span class="line">  c8 // c8 = 42</span><br><span class="line">  c9 // c9 = 42</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">iota迭代定义常量：</span><br><span class="line">const配合iota关键字使用，可以定义一组由0开始+1迭代的常量 演示语法：</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  gender_secret = iota</span><br><span class="line">  gender_male // = iota</span><br><span class="line">  gender_female // = iota</span><br><span class="line">)</span><br><span class="line">此时，三个常量值，分别是,0, 1, 2 iota的规则是：若iota出现在const()中，那么const()定义的第一行的iota就是0，第二行就是0+1=1，不论iota是否被常量使用。演示如下：</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  c1 = 42 // iota = 0，虽然未使用iota，但后边（const()中）有使用，此时iota被初始化为0，下面每行累加1</span><br><span class="line">  c2 = iota      // iota = 1，iota继续累加，使用了iota</span><br><span class="line">  c3 = 1024      // iota = 2，同样未使用，但iota的值继续累加。c3 被定义为1024</span><br><span class="line">  c4             // iota = 3，c4延续上面的定义c4=1024，iota继续累加</span><br><span class="line">  c5 = iota      // iota = 4，iota继续累加，使用了iota</span><br><span class="line">  c6 = iota      // iota = 5，iota继续累加，使用了iota</span><br><span class="line">)</span><br><span class="line">此时结果为：42, 1, 1024, 1024, 4, 5</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>func 和 JavaScript中定义类似 定义之后在main中来调用，流程很好理解</p><ul><li><p>Go中函数为一等公民：</p><ol><li>函数本身可以作为值来传递</li><li>支持匿名函数和闭包</li><li>函数可以满足接口</li></ol></li><li><p>如何声明函数(函数定义)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> func 函数名 (参数列表) (返回值参数列表)&#123;</span><br><span class="line">   //函数体</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> 参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数</span><br><span class="line"> 返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</span><br><span class="line"></span><br><span class="line"> 这里以一个加法的栗子说明：</span><br><span class="line"></span><br><span class="line"> func add (a int,b int) int &#123;</span><br><span class="line">   var sum int = a + b</span><br><span class="line"> return sum</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> func main() &#123;</span><br><span class="line">   //函数调用</span><br><span class="line">   cd := add(10,20)</span><br><span class="line">   fmt.Println(cd)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> 输出：30</span><br><span class="line"></span><br><span class="line"> 下面再来写一个有多个返回值的</span><br><span class="line"> func add(a int, b int) (int,string)&#123;</span><br><span class="line">var sum int = a + b</span><br><span class="line">str := strconv.Itoa(a)</span><br><span class="line">return sum,str</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> func main() &#123;</span><br><span class="line"> cd,str := add(100,200)</span><br><span class="line">fmt.Println(&quot;cd值为：&quot;,cd,str)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> 输出：cd值为： 300 100</span><br><span class="line"></span><br><span class="line"> 如果一个函数有多个返回值而你只想要其中的一个或几个，那么你不想要的返回值可以用下划线：_ 替代，也就是匿名变量</span><br><span class="line"></span><br><span class="line"> eg:</span><br><span class="line"> cd, str := add(100,200)</span><br><span class="line"> 此时不想要str 则改为：</span><br><span class="line"> cd, _ := add(100,200)</span><br></pre></td></tr></table></figure></li><li><p>变量的作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Go语言变量再三个地方声明：</span><br><span class="line">1. 函数内——局部变量</span><br><span class="line">2. 函数外——全局变量</span><br><span class="line">3. 函数中——形式参数</span><br><span class="line"></span><br><span class="line">与java定义类似不多解释</span><br></pre></td></tr></table></figure></li><li><p>Go 语言指针</p><p>• 默认值 nil，没有 NULL 常量。<br>• 操作符 “&amp;” （取地址符） 取变量地址，”*” （取值符）透过指针访问目标对象。<br>• 不支持指针运算，不支持 “-&gt;” 运算符，直接用 “.” 访问目标成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Go 支持指针。指针是保存值的地址的地方。 一个指针用 * 定义 </span><br><span class="line">指针声明：</span><br><span class="line"></span><br><span class="line">var name *类型</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">var ip *int     /* 指向整型*/ //声明一个int值得指针变量</span><br><span class="line">var fp *float32 /* 指向浮点型 */</span><br><span class="line">var sp *string  /* 指向字符串类型 */</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">根据数据类型定义指针。 例：</span><br><span class="line"></span><br><span class="line">var ap *int</span><br><span class="line">上面的  ap  是指向整数类型的指针。＆ 运算符可用于获取变量的地址。</span><br><span class="line"></span><br><span class="line">a := 12</span><br><span class="line">ap = &amp;a</span><br><span class="line">可以使用 * 运算符访问指针指向的值：</span><br><span class="line"></span><br><span class="line">fmt.Println(*ap)</span><br><span class="line">// =&gt; 12</span><br><span class="line"></span><br><span class="line">如何使用指针？</span><br><span class="line"></span><br><span class="line">指针使用流程：</span><br><span class="line">定义指针变量。</span><br><span class="line">为指针变量赋值。</span><br><span class="line">访问指针变量中指向地址的值。</span><br><span class="line">在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</span><br></pre></td></tr></table></figure></li><li><p>举个栗子</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var a int = 20 /* 声明实际变量 */</span><br><span class="line">  var ip *int    /* 声明指针变量 */</span><br><span class="line"></span><br><span class="line">  ip = &amp;a /* 指针变量的存储地址 */</span><br><span class="line"></span><br><span class="line">  fmt.Printf(&quot;a 变量的地址是: %x\n&quot;, &amp;a)</span><br><span class="line"></span><br><span class="line">  /* 指针变量的存储地址 */</span><br><span class="line">  fmt.Printf(&quot;ip 变量的存储地址: %x\n&quot;, ip)</span><br><span class="line"></span><br><span class="line">  /* 使用指针访问值 */</span><br><span class="line">  fmt.Printf(&quot;*ip 变量的值: %d\n&quot;, *ip)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">a 变量的地址是: c420012058</span><br><span class="line">ip 变量的存储地址: c420012058</span><br><span class="line">*ip 变量的值: 20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在将结构体作为参数传递或者为已定义类型声明方法时，通常首选指针。</span><br><span class="line"></span><br><span class="line">传递值时，实际复制的值意味着更多的内存</span><br><span class="line">传递指针后，函数更改的值将反映在方法 / 函数调用者中。</span><br><span class="line">例子:</span><br><span class="line">func increment(i *int) &#123;</span><br><span class="line">  *i++</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">  i := 10</span><br><span class="line">  increment(&amp;i)</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">//=&gt; 11</span><br><span class="line"></span><br><span class="line">上面那个栗子表示将i 用指针的形式再函数中加1，更改了i本身的值</span><br></pre></td></tr></table></figure><ul><li><p>直接用指针访问目标对象成员：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">直接用指针访问目标对象成员：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  type data struct&#123; a int &#125;</span><br><span class="line"></span><br><span class="line">  var d = data&#123;1234&#125;</span><br><span class="line">  var p *data</span><br><span class="line"></span><br><span class="line">  p = &amp;d</span><br><span class="line">  fmt.Printf(&quot;%p, %v\n&quot;, p, p.a) // 直接用指针访问目标对象成员，无须转换。</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line"></span><br><span class="line">0xc420012058, 1234</span><br><span class="line"></span><br><span class="line">这种 .a 的形式有点类似于java中对象.变量的感觉，很熟悉，这样理解会方便一些</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1. 不能对指针做加减法等运算。</span><br><span class="line">2. 可以在 unsafe.Pointer 和任意类型指针间进 转换。</span><br><span class="line">3. 将 Pointer 转换成 uintptr，可变相实现指针运算。</span><br></pre></td></tr></table></figure></li></ul><h3 id="Go-空指针-nil"><a href="#Go-空指针-nil" class="headerlink" title="Go 空指针 nil"></a>Go 空指针 nil</h3><ul><li><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">nil 指针也称为空指针。</span><br><span class="line"></span><br><span class="line">nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</span><br><span class="line"></span><br><span class="line">一个指针变量通常缩写为 ptr 即 Pointer。</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var ptr *int</span><br><span class="line">  /* %x 指十六进制，小写字母，每字节两个字符*/</span><br><span class="line">  fmt.Printf(&quot;ptr 的值为 : %x\n&quot;, ptr)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">ptr 的值为 : 0</span><br></pre></td></tr></table></figure></li><li><p>空指针判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var ptr1 *int</span><br><span class="line">  var i int = 1</span><br><span class="line">  ptr2 := &amp;i</span><br><span class="line">  if ptr1 == nil &#123; </span><br><span class="line">    fmt.Println(&quot;prt1 是空指针&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  if ptr2 != nil &#123; </span><br><span class="line">    fmt.Println(&quot;prt2 不是空指针 值为：&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">prt1 是空指针</span><br><span class="line">prt2 不是空指针</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">指针记录到这里我稍微总结一下：</span><br><span class="line"></span><br><span class="line">和C语言中指针类似，存储的是变量的地址值，我们无法直接给指针变量赋值</span><br><span class="line">但是我们先定义一个变量之后将其地址取出： 如何取？  用 &amp; 取   &amp;变量</span><br><span class="line">取出后我们把将要赋值的指针地址指向这个变量  ptr = &amp;变量</span><br><span class="line">这样就实现了给指针赋值 之后 *ptr 就可取出指针的值</span><br></pre></td></tr></table></figure><pre><code>请大家记住这个步骤：1. 指针声明格式如下：var name *类型2. 如何使用指针？指针使用流程：定义指针变量。为指针变量赋值。访问指针变量中指向地址的值。在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</code></pre></li></ul><h3 id="Go-指针数组"><a href="#Go-指针数组" class="headerlink" title="Go 指针数组"></a>Go 指针数组</h3><ul><li><p>声明指针数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">var ptr [MAX]*int;</span><br><span class="line">ptr 为整型指针数组。因此每个元素都指向了一个值。以下实例的三个整数将存储在指针数组中：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">const MAX int = 3</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  a := []int&#123;9, 99, 999&#125;</span><br><span class="line">  var i int</span><br><span class="line">  var ptr [MAX]*int</span><br><span class="line"></span><br><span class="line">  for i = 0; i &lt; MAX; i++ &#123;</span><br><span class="line">    ptr[i] = &amp;a[i] /* 整数地址赋值给指针数组 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for i = 0; i &lt; MAX; i++ &#123;</span><br><span class="line">    fmt.Printf(&quot;a[%d] = %d\n&quot;, i, *ptr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">a[0] = 9</span><br><span class="line">a[1] = 99</span><br><span class="line">a[2] = 999</span><br><span class="line"></span><br><span class="line">如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</span><br><span class="line">当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：</span><br><span class="line"></span><br><span class="line">指向指针的指针变量声明格式如下：</span><br><span class="line"></span><br><span class="line">var ptr **int</span><br><span class="line">以上指向指针的指针变量为整型。</span><br><span class="line">访问指向指针的指针变量值需要使用两个 * 号，如下所示：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">  var a int</span><br><span class="line">  var ptr *int</span><br><span class="line">  var pptr **int</span><br><span class="line"></span><br><span class="line">  a = 3000</span><br><span class="line"></span><br><span class="line">  /* 指针 ptr 地址 */</span><br><span class="line">  ptr = &amp;a</span><br><span class="line"></span><br><span class="line">  /* 指向指针 ptr 地址 */</span><br><span class="line">  pptr = &amp;ptr</span><br><span class="line"></span><br><span class="line">  /* 获取 pptr 的值 */</span><br><span class="line">  fmt.Printf(&quot;变量 a = %d\n&quot;, a)</span><br><span class="line">  fmt.Printf(&quot;指针变量 *ptr = %d\n&quot;, *ptr)</span><br><span class="line">  fmt.Printf(&quot;指向指针的指针变量 **pptr = %d\n&quot;, **pptr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">变量 a = 3000</span><br><span class="line">指针变量 *ptr = 3000</span><br><span class="line">指向指针的指针变量 **pptr = 3000</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据类型转换&quot;&gt;&lt;a href=&quot;#数据类型转换&quot; class=&quot;headerlink&quot; title=&quot;数据类型转换&quot;&gt;&lt;/a&gt;数据类型转换&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   通过类型前置加一个圆括号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   T(表达式)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   T表示要转化的类型，表达式包括：变量，数值，函数返回值等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int(8.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int(80.5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   布尔型无法与其他类型转换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int转换为string OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   string转换为int NO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   eg:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   chinese := 90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;english := 90.9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;result := string(chinese)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Println(chinese,english,result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   90 90.9 Z&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go开发基础入门</title>
    <link href="http://yoursite.com/2019/06/04/Go%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/06/04/Go开发基础入门/</id>
    <published>2019-06-04T08:46:10.000Z</published>
    <updated>2019-06-05T10:49:08.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go开发入门"><a href="#Go开发入门" class="headerlink" title="Go开发入门"></a>Go开发入门</h2><h3 id="变量的定义，赋值"><a href="#变量的定义，赋值" class="headerlink" title="变量的定义，赋值"></a>变量的定义，赋值</h3><p>变量声明：Go的变量名首字母不能为数字</p><ul><li><p>未初始化的变量声明：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   var 变量名 变量类型</span><br><span class="line">var a int               // 声明 int 类型的变量</span><br><span class="line">var b [10] int          // 声明 int 类型数组</span><br><span class="line">var c []int             // 声明 int 类型的切片 [] 内赋初值是数组，不赋值是切片</span><br><span class="line">var d *int              // 声明 int 类型的指针</span><br><span class="line">   打印结果为</span><br><span class="line"></span><br><span class="line">   //a=&#123;0&#125;,b=&#123;[0 0 0 0 0 0 0 0 0 0]&#125;,c=&#123;[]&#125;,d=&#123;&lt;nil&gt;&#125;</span><br><span class="line"></span><br><span class="line">   那么未初始化的变量默认值为：</span><br><span class="line"></span><br><span class="line">   整型和浮点型变量： 0</span><br><span class="line">   字符串： 0</span><br><span class="line">   布尔： false</span><br><span class="line">   函数，指针： nil</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>初始化的变量声明：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 变量类型 = 表达式</span><br><span class="line">var a int = 10</span><br><span class="line"></span><br><span class="line">//编译器自动推断格式</span><br><span class="line">var 变量名 = 表达式</span><br><span class="line"></span><br><span class="line">//简短声明格式(短变量声明格式)</span><br><span class="line">变量名 := 表达式</span><br><span class="line"></span><br><span class="line">:= 可以高效的创建新变量，在内存中开辟空间</span><br><span class="line">var 省略</span><br><span class="line">编译器自动推断类型</span><br><span class="line">声明变量首选这种形式</span><br><span class="line">只能用在函数体内，不能作为全局变量来声明</span><br><span class="line">变量名不能是被定义过的，不然会报错</span><br></pre></td></tr></table></figure></li><li><p>变量多重赋值</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go可以进行多变量赋值，变量与变量之间逗号隔开</span><br><span class="line">a, b, c, d := 1, 2, true, &quot;def&quot;</span><br><span class="line">fmt.Printf(&quot;a=&#123;%d&#125;,b=&#123;%d&#125;,c=&#123;%v&#125;,d=&#123;%v&#125; \n&quot;, a, b, c, d)</span><br><span class="line"></span><br><span class="line">a, b = b, a // a,b互换位置</span><br></pre></td></tr></table></figure><ul><li><p>匿名变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要用于函数返回值，返回我们需要的字段</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>布尔型<br>布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</li><li>数字类型<br>整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</li><li>字符串类型:<br>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</li><li>派生类型:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">包括：</span><br><span class="line">(a) 指针类型（Pointer）</span><br><span class="line">(b) 数组类型</span><br><span class="line">(c) 结构化类型(struct)</span><br><span class="line">(d) Channel 类型</span><br><span class="line">(e) 函数类型</span><br><span class="line">(f) 切片类型</span><br><span class="line">(g) 接口类型（interface）</span><br><span class="line">(h) Map 类型</span><br></pre></td></tr></table></figure></li></ul><p>更详细的可以参考<a href="https://www.cnblogs.com/fengbohello/p/5854108.html" target="_blank" rel="noopener">这篇博文</a>，写的非常详细</p><h3 id="格式化输出语句"><a href="#格式化输出语句" class="headerlink" title="格式化输出语句"></a>格式化输出语句</h3><ul><li><p>通用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%v value，值的默认表示</span><br><span class="line">%+v 类似%v，但输出结构体时会添加字段名</span><br><span class="line">%#v 值的 Go 语法表示</span><br><span class="line">%T 值的数据类型Go语法表示，如： int , string等</span><br></pre></td></tr></table></figure></li><li><p>布尔</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%t true或false</span><br></pre></td></tr></table></figure></li><li><p>整数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%b     二进制表示 </span><br><span class="line">%c     相应Unicode码点所表示的字符 </span><br><span class="line">%d     十进制表示 </span><br><span class="line">%8d    整形长度为8，不足8则在数值前补空格 超出以实际为准</span><br><span class="line">%08d   数字长度是8，不足8位的，数字前补0 超出以实际为准</span><br><span class="line">%o     八进制表示 </span><br><span class="line">%q     单引号围绕的字符字面值，由Go语法安全地转义 </span><br><span class="line">%x     十六进制表示，字母形式为小写 a-f </span><br><span class="line">%X     十六进制表示，字母形式为大写 A-F </span><br><span class="line">%U     Unicode格式：U+1234，等同于 &quot;U+%04X&quot;</span><br></pre></td></tr></table></figure></li><li><p>浮点,复数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%b     无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat中的 &apos;b&apos; 转换格式一致。例如 -123456p-78 </span><br><span class="line">%e     科学计数法，例如 -1234.456e+78 </span><br><span class="line">%E     科学计数法，例如 -1234.456E+78 </span><br><span class="line">%f     有小数点而无指数，例如 123.456 </span><br><span class="line">%g     根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 </span><br><span class="line">%G     根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</span><br></pre></td></tr></table></figure></li><li><p>字符串和bytes的slice表示：</p>  <figure class="highlight plain"><figcaption><span>字符串或切片的无解译字节 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%q     双引号围绕的字符串，由Go语法安全地转义 </span><br><span class="line">%x     十六进制，小写字母，每字节两个字符 </span><br><span class="line">%X     十六进制，大写字母，每字节两个字符</span><br></pre></td></tr></table></figure></li><li><p>指针：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%p     十六进制表示，前缀 0x</span><br><span class="line">这里没有 &apos;u&apos; 标记。若整数为无符号类型，他们就会被打印成无符号的。类似地，这里也不需要指定操作数的大小（int8，int64）。</span><br><span class="line"></span><br><span class="line">对于％ｖ来说默认的格式是：</span><br><span class="line">bool:                    %t </span><br><span class="line">int, int8 etc.:          %d </span><br><span class="line">uint, uint8 etc.:        %d, %x if printed with %#v</span><br><span class="line">float32, complex64, etc: %g</span><br><span class="line">string:                  %s</span><br><span class="line">chan:                    %p </span><br><span class="line">pointer:                 %p</span><br><span class="line">由此可以看出，默认的输出格式可以使用%v进行指定，除非输出其他与默认不同的格式，否则都可以使用%v进行替代（但是不推荐使用）</span><br></pre></td></tr></table></figure></li><li><p>对于复合对象:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">里面的元素使用如下规则进行打印：</span><br><span class="line">struct:            &#123;field0 field1 ...&#125; </span><br><span class="line">array, slice:      [elem0 elem1 ...] </span><br><span class="line">maps:              map[key1:value1 key2:value2] </span><br><span class="line">pointer to above:  &amp;&#123;&#125;, &amp;[], &amp;map[]</span><br></pre></td></tr></table></figure></li><li><p>宽度和精度：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">宽度是在％之后的值，如果没有指定，则使用该值的默认值，精度是跟在宽度之后的值，如果没有指定，也是使用要打印的值的默认精度．例如：％９.２f，宽度９，精度２</span><br><span class="line"></span><br><span class="line">%f:      default width, default precision </span><br><span class="line">%9f      width 9, default precision </span><br><span class="line">%.2f     default width, precision 2 </span><br><span class="line">%9.2f    width 9, precision 2 </span><br><span class="line">%9.f     width 9, precision 0</span><br></pre></td></tr></table></figure></li></ul><p>这里有一些<a href="https://blog.csdn.net/qq_34777600/article/details/81266453" target="_blank" rel="noopener">练习</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Go开发入门&quot;&gt;&lt;a href=&quot;#Go开发入门&quot; class=&quot;headerlink&quot; title=&quot;Go开发入门&quot;&gt;&lt;/a&gt;Go开发入门&lt;/h2&gt;&lt;h3 id=&quot;变量的定义，赋值&quot;&gt;&lt;a href=&quot;#变量的定义，赋值&quot; class=&quot;headerlink&quot; title=&quot;变量的定义，赋值&quot;&gt;&lt;/a&gt;变量的定义，赋值&lt;/h3&gt;&lt;p&gt;变量声明：Go的变量名首字母不能为数字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;未初始化的变量声明：&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   var 变量名 变量类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a int               // 声明 int 类型的变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var b [10] int          // 声明 int 类型数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var c []int             // 声明 int 类型的切片 [] 内赋初值是数组，不赋值是切片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var d *int              // 声明 int 类型的指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   打印结果为&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   //a=&amp;#123;0&amp;#125;,b=&amp;#123;[0 0 0 0 0 0 0 0 0 0]&amp;#125;,c=&amp;#123;[]&amp;#125;,d=&amp;#123;&amp;lt;nil&amp;gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   那么未初始化的变量默认值为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   整型和浮点型变量： 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   字符串： 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   布尔： false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   函数，指针： nil&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Golang-Web编程</title>
    <link href="http://yoursite.com/2019/06/03/Golang-Web%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/06/03/Golang-Web编程/</id>
    <published>2019-06-03T02:27:17.000Z</published>
    <updated>2019-06-03T02:27:17.947Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>beego框架搭建踩坑</title>
    <link href="http://yoursite.com/2019/05/30/beego%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91/"/>
    <id>http://yoursite.com/2019/05/30/beego框架搭建踩坑/</id>
    <published>2019-05-30T05:39:38.000Z</published>
    <updated>2019-06-05T07:09:09.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是beego"><a href="#什么是beego" class="headerlink" title="什么是beego"></a>什么是beego</h3><pre><code>一个框架：可以理解为Golang的MVC框架四个特点：简单化、智能化、模块化、高性能具体好处去官网自行浏览</code></pre><p><a href="https://beego.me/" target="_blank" rel="noopener">官网传送门</a></p><a id="more"></a><h3 id="踩坑之前先安装一下Golang"><a href="#踩坑之前先安装一下Golang" class="headerlink" title="踩坑之前先安装一下Golang"></a>踩坑之前先安装一下Golang</h3><pre><code>1. 找go的官网下载 https://studygolang.com/articles/6165 windows下载后缀为msi的文件，之后傻瓜式安装2. 配置GOROOT和GPATH环境变量    https://studygolang.com/articles/6165 这里有除了这两个以外还有Path中:    F:\Go\bin   %GOPATH%\bin3. 之后输入go,go version,和go env来看一下    go env 看一下GOPATH的路径改变了没有，如果没有改变在你系统环境变量的上方有个你个人用户的环境变量，重复配置一下GOPATH如果还是不生效    百度搜 &quot;windows10配置GOPATH不生效的解决方案&quot; 4. IDE选择 ： goland 好不好用去试试，可以换主题   主题传送门：https://blog.csdn.net/qq_31339365/article/details/78323153   安装过程中可能遇到的问题：越狱问题传送门：https://blog.csdn.net/u014044812/article/details/876211685. 之后测试一个小demo即可Goland的目录结构GOPATH：    bin:    pkg:    src: 项目名:            main.go</code></pre><h3 id="beego框架安装"><a href="#beego框架安装" class="headerlink" title="beego框架安装"></a>beego框架安装</h3><pre><code>beego 包含一些示例应用程序以帮您学习并使用 beego 应用框架。您需要安装 Go 1.1+ 以确保所有功能的正常使用。你需要安装或者升级 Beego 和 Bee 的开发工具:命令在你的GOPATH下输入go get github.com/astaxie/beegogo get -u github.com/beego/bee为了更加方便的操作，请将 $GOPATH/bin 加入到你的 $PATH 变量中。请确保在此之前您已经添加了 $GOPATH 变量。 windows下只需要$path里面配了 %GOPATH%\bin 即可检测是否安装：1. 在你GOPATH/src 输入 bee new 你的项目名称2. cd 你的项目名称3. bee run之后访问 localhost:8080 出现下图即搭建成功</code></pre><p><img src="/images/beego/beego1.png" alt="beego搭建"></p><pre><code>接着可以实现一个小的功能体验一下MVC架构1. 用goland打开你的项目</code></pre><p><img src="/images/beego/beego2.png" alt="beego搭建"></p><pre><code>项目结构后面会出文章解释，先简单了解一下，这里我们主要了解一下controllers和routers先看一下写法：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package controllers</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/astaxie/beego&quot;</span><br><span class="line">)</span><br><span class="line">//声明了一个控制器 HelloController</span><br><span class="line">//这个控制器里面内嵌了beego.Controller这就是Go的嵌入方式</span><br><span class="line">//也就是HelloController自动拥有了所有 beego.Controller 的方法</span><br><span class="line">//这类似于面向对象里的继承</span><br><span class="line"></span><br><span class="line">type HelloController struct &#123;</span><br><span class="line">beego.Controller //这里相当于继承beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//而beego.Controller拥有很多方法</span><br><span class="line">//其中包括Init、Prepare、Post、Get、Delete、Head等方法</span><br><span class="line">//我们可以通过重写的方式来实现这些方法，而我们下面的代码就是重写了Get方法。</span><br><span class="line">//重写Get方法</span><br><span class="line">func (hello *HelloController) Get() &#123;</span><br><span class="line">hello.Ctx.WriteString(&quot;hello go&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这里写了一个hello.go 的 controller那么上面的代码到底做了些什么呢？首先我们导入了包 github.com/astaxie/beego。我们知道 Go 语言里面被导入的包会按照深度优先的顺序去执行导入包的初始化（变量和 init 函数，更多详情），beego 包中会初始化一个 BeeAPP 的应用和一些参数。定义 Controller，这里我们定义了一个 struct 为 HelloController，充分利用了 Go 语言的组合的概念，匿名包含了 beego.Controller，这样我们的 HelloController 就拥有了 beego.Controller 的所有方法。定义 RESTful 方法，通过匿名组合之后，其实目前的 HelloController 已经拥有了 Get、Post、Delete、Put 等方法，这些方法是分别用来对应用户请求的 Method 函数，如果用户发起的是 POST 请求，那么就执行 Post 函数。所以这里我们定义了 HelloController 的 Get 方法用来重写继承的 Get 函数，这样当用户发起 GET 请求的时候就会执行该函数。Router 注册路由，路由就是告诉 beego，当用户来请求的时候，该如何去调用相应的 Controller，这里我们注册了请求 / 的时候，请求到 HelloController。这里我们需要知道，Router 函数的两个参数函数，第一个是路径，第二个是 Controller 的指针。Run 应用，bee run 启动，其实就是内部监听了 8080 端口：Go 默认情况会监听你本机所有的 IP 上面的 8080 端口停止服务的话，请按 Ctrl+c。之后在 routers 下 routers.go下添加 // 然后将新增的HelloController添加路由，修改routers/router.go文件新增路由beego.Router(&quot;/hello&quot;, &amp;controllers.HelloController{})和java的controller写法类似 /hello 是后缀 即你用localhost:8080/hello可以访问界面如果是用goland进行开发，可以直接启动main.go，其中的配置如下1. 点击edit configurations</code></pre><p><img src="/images/beego/beego3.png" alt="beego搭建"><br><img src="/images/beego/beego4.png" alt="beego搭建"></p><pre><code>下面我们访问一下 localhost:8080/hello</code></pre><p><img src="/images/beego/beego5.png" alt="beego搭建"></p><pre><code>OVER！！！</code></pre><blockquote><p>感谢帮助我踩坑成功的各位哥哥，正是由于你们的付出，才让我们踩更少的坑，感恩<br>如果涉及到您的版权问题，请联系我删除，谢谢<br><a href="mailto:18135479521@163.com" target="_blank" rel="noopener">18135479521@163.com</a></p></blockquote><p>版权声明：本文为博主原创文章，转载请附上博文链接！</p><p><a href="https://app.netlify.com/sites/ymliang/deploys" target="_blank" rel="noopener"><img src="https://api.netlify.com/api/v1/badges/0f11aaba-6571-4f78-b114-467979ef9df5/deploy-status" alt="Netlify Status"></a></p><p><a href><img src="https://img.shields.io/badge/download-26k-green.svg?style=flat-square" alt="Travis"></a> <a href><img src="https://img.shields.io/badge/windows-black.svg?style=flat-square&amp;logo=windows" alt="Travis"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是beego&quot;&gt;&lt;a href=&quot;#什么是beego&quot; class=&quot;headerlink&quot; title=&quot;什么是beego&quot;&gt;&lt;/a&gt;什么是beego&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;一个框架：可以理解为Golang的MVC框架
四个特点：简单化、智能化、模块化、高性能
具体好处去官网自行浏览
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://beego.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="beego" scheme="http://yoursite.com/tags/beego/"/>
    
  </entry>
  
  <entry>
    <title>spark知识梳理</title>
    <link href="http://yoursite.com/2019/05/23/spark%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/23/spark知识梳理/</id>
    <published>2019-05-23T10:19:30.000Z</published>
    <updated>2019-05-31T05:27:57.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spark定义"><a href="#Spark定义" class="headerlink" title="Spark定义:"></a>Spark定义:</h3><p>Spark编程始于数据集，而数据集往往存放在分布式持久化存储之上，比如Hadoop分布式文件系统HDFS</p><p>编写Spark 程序通常包括一系列相关步骤。</p><pre><code>• 在输入数据集上定义一组转换。• 调用 action，用以将转换后的数据集保存到持久存储上，或者把结果返回到驱动程序的本地内存。• 运行本地计算，本地计算处理分布式计算的结果。本地计算有助于你确定下一步的转换和 action。</code></pre><a id="more"></a><pre><code>要想理解 Spark，就必须理解 Spark 框架提供的两种抽象：存储和执行。Spark 优美地搭配这两类抽象，可以将数据处理管道中的任何中间步骤缓在内存里以备后用常见的RDD转化操作</code></pre><h3 id="transform算子"><a href="#transform算子" class="headerlink" title="transform算子:"></a>transform算子:</h3><p><img src="/images/spark知识梳理/transform.png" alt="transform"></p><h3 id="action算子"><a href="#action算子" class="headerlink" title="action算子:"></a>action算子:</h3><p><img src="/images/spark知识梳理/action.png" alt="action"></p><h3 id="case-class"><a href="#case-class" class="headerlink" title="case class"></a>case class</h3><p>case class 是不可变类的一种简单类型它非常好用，内置了所有 Java 类的基本方法，比如toString、equals和 hashCode。我们来试试为记录关联数据定义一个 case class：</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">样例数据来自加州大学欧文分校机器学习资料库（UC Irvine Machine Learning Repository）。</span><br><span class="line">这里要分析的数据集来源于一项纪录关联研究，是德国一家医院在2010年完成的。这个数据及包含数百万对病人记录，每队记录都根据不同标准来匹配。比如病人姓名、地址、生日。</span><br><span class="line">每个匹配字段都被赋予一个数值评分，范围为0.0 到 1.0，分值根据字符串相似度得出。然后这些数据交给人工处理，标记出哪些代表同一个人哪些代表不同的人。</span><br><span class="line">为了保护病人隐私，创建的数据集的每个字段原始值被删除。病人的ID、字段匹配分数、匹配对标识（包括匹配的和不匹配的）等信息是公开的，可用于纪录关联研究。</span><br></pre></td></tr></table></figure><p>数据获取</p><pre><code>$ mkdir linkage$ cd linkage/$ wget https://archive.ics.uci.edu/ml/machine-learning-databases/00210/donation.zip(http://bit.ly/1Aoywaq)$ unzip donation.zip$ unzip &apos;block_*.zip&apos;放入HDFS：$ hadoop fs -mkdir /linkage$ hadoop fs -put block_*.csv /linkage</code></pre><p>启动spark-shell 这里本地启动</p><pre><code>spark-shell Setting default log level to &quot;WARN&quot;.To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).19/05/24 07:15:36 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableSpark context Web UI available at http://192.111.110.111:4040Spark context available as &apos;sc&apos; (master = spark://master:7077, app id = app-20190524071537-0001).Spark session available as &apos;spark&apos;.Welcome to    ____              __    / __/__  ___ _____/ /__    _\ \/ _ \/ _ `/ __/  &apos;_//___/ .__/\_,_/_/ /_/\_\   version 2.2.0    /_/Using Scala version 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_144)Type in expressions to have them evaluated.Type :help for more information.scala&gt; 如果出现以上说明启动成功</code></pre><p>读数据</p><pre><code>scala&gt;val rawblocks = sc.textFile(&quot;hdfs:///linkage/*.csv&quot;)scala&gt;val head = rawblocks.take(10)scala&gt;head.lengthres2: Int = 10遍历scala&gt;head.foreach(println)&quot;id_1&quot;,&quot;id_2&quot;,&quot;cmp_fname_c1&quot;,&quot;cmp_fname_c2&quot;,&quot;cmp_lname_c1&quot;,&quot;cmp_lname_c2&quot;,&quot;cmp_sex&quot;,&quot;cmp_bd&quot;,&quot;cmp_bm&quot;,&quot;cmp_by&quot;,&quot;cmp_plz&quot;,&quot;is_match&quot;37291,53113,0.833333333333333,?,1,?,1,1,1,1,0,TRUE39086,47614,1,?,1,?,1,1,1,1,1,TRUE70031,70237,1,?,1,?,1,1,1,1,1,TRUE84795,97439,1,?,1,?,1,1,1,1,1,TRUE36950,42116,1,?,1,1,1,1,1,1,1,TRUE42413,48491,1,?,1,?,1,1,1,1,1,TRUE25965,64753,1,?,1,?,1,1,1,1,1,TRUE49451,90407,1,?,1,?,1,1,1,1,0,TRUE39932,40902,1,?,1,?,1,1,1,1,1,TRUE</code></pre><p>定义函数过滤第一行的表头数据：(“id_1”,”id_2”,”cmp_fname_c1”….)</p><pre><code>scala&gt; def isHeader(line:String):Boolean={            line.contains(&quot;id_1&quot;) || line.contains(&quot;cmp&quot;)        }scala&gt; head.filter(isHeader).foreach(println) 查包含&quot;id_1&quot;的行scala&gt; head.filterNot(isHeader).foreach(println) 查不包含&quot;id_1&quot;的行scala&gt; head.filter(x=&gt; isHeader(x)).foreach(println) 查包含&quot;id_1&quot;的行scala&gt; head.filter(x=&gt; !isHeader(x)).foreach(println) 查不包含&quot;id_1&quot;的行scala&gt; head.filter(isHeader(_)).foreach(println) 查包含&quot;id_1&quot;的行scala&gt; head.filter(!isHeader(_)).foreach(println) 查不包含&quot;id_1&quot;的行过滤的方法有三种，再上方已经列举出来了，可以根据喜好和编码习惯选择将去掉标题头 即含有 id_1的第一行去掉后变为新的 RDDscala&gt; val noheader = rawblocks.filter(x =&gt; !isHeader(x)) noheader: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[4] at filter at &lt;console&gt;:28</code></pre><p>进行数据结构化</p><pre><code>说到数据结构化，首先java的思想就是封装，scala中是元组和case class ，其中 case class类似于封装tuple 元组 -- scala    为了测试方便，先取一行数据    val line = head(5)    1. 首先定义一个函数，里面处理每一行数据    def parse(line:String)={        val pieces = line.split(&apos;,&apos;)        val id1 = pieces(0).toInt        val id2 = pieces(1).toInt        val scores = pieces.slice(2,11).map(toDouble)        val matched = pieces(11).toBoolean        (id1,id2,scores,matched)    }    val tup = parse(line)    2. 可能你没有注意有问号的情况，那么为了避免出现 ? 导致程序报错，可以定义 toDouble函数    def toDouble(s:String)={        if(&quot;?&quot;.equals(s)) Double.NaN else s.toDouble    }    --------------------------------------------------------------------------        slice函数截取集合        slice函数需要两个参数，第一个参数表示从该下标开始截取，第二个参数表示截取到该下标（不包含）。        object TestCollection {            val list =List(1,4,6,4,1)            def main(args: Array[String]): Unit = {                print(list.slice(0,3))            }        }    --------------------------------------------------------------------------    3. 之后再执行 val tup = parse(line)    得到的tup就是一个元组    元组的操作:    tup._1      取第一个元素    tup.productElement(0)       或者用 productElement 方法，它是从 0 开始计数的。    tup.productArity        也可以用 productArity 方法得到元组的大小case class     case class 是不可变类的一种简单类型，它非常好用，内置了所有 Java 类的基本方法，比如 toString、equals 和 hashCode。我们来试试为记录关联数据定义一个 case class：    case class MatchData(id1: Int, id2: Int,scores: Array[Double], matched: Boolean)    现在修改 parse 方法以返回 MatchData 实例，这个实例是 case class 而不再是元组：    def parse(line: String) = {        val pieces = line.split(&apos;,&apos;)        val id1 = pieces(0).toInt        val id2 = pieces(1).toInt        val scores = pieces.slice(2, 11).map(toDouble)        val matched = pieces(11).toBoolean        MatchData(id1, id2, scores, matched)    }    val md = parse(line)    这里要注意两点：    一，创建 case class 时没必要在 MatchData 前写上关键字 new    二，MatchData 类有个内置的 toString 方法实现，除了scores 数组字段外，这个方法在其他字段上的表现都还不错。    现在通过名字来访问 MatchData 的字段：    md.matched    md.id1    是不是有种 对象.成员变量 的意思 有些地方还是很像java的，比如java8的lambda表达式和scala非常相似    之后将其作用于head数据集上    val mds = head.filter(x=&gt; !isHeader(x)).map(x=&gt; parse(x))    之后再作用于整个数据集上 noheader    val parsed = noheader.map(line =&gt; parse(line))    记住：和我们本地生成的 mds 数组不同，parse 函数并没有实际应用到集群数据上。当在    parsed 这个 RDD 上执行某个需要输出的调用时，就会用 parse 函数把 noheader RDD     的每个 String 转换成 MatchData 类的实例。如果在 parsed RDD 上执行另一个调用以    产生不同输出，parse函数会在输入数据上再执行一遍。这没有充分利用集群资源。数据一    旦解析好，我们想以解析格式把数据存到集群上，这样就不需要每次遇到新问题时都重新解    析。Spark支持这种使用场景，通过在实例上调用cache 方法，可以指示在内存里缓存某个    RDD。现在用 parsed 这个 RDD 实验一下：    parsed.cache()    Spark的缓存：        虽然默认情况下 RDD 的内容是临时的，但 Spark 提供了在 RDD 中持久化数据的机制。第        一次调用动作并计算出 RDD 内容后，RDD 的内容可以存储在集群的内存或磁盘上。这样下一        次需要调用依赖该 RDD 的动作时，就不需要从依赖关系中重新计算 RDD，数据可以从缓存分        区中直接返回：            cached.cache()            cached.count()            cached.take(10)        在上述代码中，cache 方法调用指示在下次计算 RDD 后，要把 RDD 存储起来。调用        count 会导致第一次计算 RDD。采取（take）这个动作返回一个本地的 Array，包含        RDD 的前 10 个元素。但调用 take 时，访问的是 cached 已经缓存好的元素，而不是        从 cached 的依赖关系中重新计算出来的。        Spark 为持久化 RDD 定义了几种不同的机制，用不同的 StorageLevel 值表示。rdd.        cache() 是 rdd.persist(StorageLevel.MEMORY) 的简写，它将 RDD 存储为未序列化        的 Java 对象。当 Spark 估计内存不够存放一个分区时，它干脆就不在内存中存放该分        区，这样在下次需要时就必须重新计算。在对象需要频繁访问或低延访问时适合使用        StorageLevel.MEMORY，因为它可以避免序列化的开销。相比其他选项，StorageLevel.        MEMORY 的问题是要占用更大的内存空间。另外，大量小对象会对 Java 的垃圾回收造成        压力，会导致程序停顿和常见的速度缓慢问题。        Spark 也提供了 MEMORY_SER 的存储级别，用于在内存中分配大字节缓冲区以存储 RDD        序列化内容。如果使用得当（稍后会详细介绍），序列化数据占用的空间比未经序列化        的数据占用的空间往往要少两到五倍。        Spark 也可以用磁盘来缓存 RDD。        存储级别 MEMORY_AND_DISK 和 MEMORY_AND_DISK_SER        分别类似于 MEMORY 和 MEMORY_SER。对于 MEMORY 和 MEMORY_SER，如果一个分区在内存        里放不下，整个分区都不会放在内存。对于 MEMORY_AND_DISK 和 MEMORY_AND_DISK_SER，        如果分区在内存里放不下，Spark 会将其溢写到磁盘上。        什么时候该缓存数据是门艺术，这通常需要对空间和速度进行权衡，垃圾回收开销的        问题也会时不时让情况更复杂。一般情况下，如果多个动作需要用到某个 RDD，而它        的计算代价又很高，那么就应该把这个 RDD 缓存起来。</code></pre><p>聚合</p><pre><code>我们用 groupBy 方法来创建一个 Scala Map[Boolean, Array[MatchData]]，其中键值基于MatchData 类的字段 matched：    val grouped = mds.groupBy(md =&gt; md.matched)    grouped: scala.collection.immutable.Map[Boolean,Array[MatchData]] = Map(true -&gt; Array(MatchData(37291,53113,[D@14587d48,true), MatchData(39086,47614,[D@556e8e2e,true), MatchData(70031,70237,[D@4d94e219,true), MatchData(84795,97439,[D@25937e5b,true), MatchData(36950,42116,[D@7276f59c,true), MatchData(42413,48491,[D@53481a02,true), MatchData(25965,64753,[D@3926be58,true), MatchData(49451,90407,[D@7f96e81,true), MatchData(39932,40902,[D@42e6a1f7,true)))利用mapValues进行记数    grouped.mapValues(x=&gt;x.size).foreach(println)    (true,9)</code></pre><p>创建直方图</p><pre><code>先来试试创建一个简单的直方图，用它来算一下 parsed 中的 MatchData 记录有多少 matched字段值为 true 或 false。幸运的是 RDD[T] 类已经定义了一个名为 countByValue 的动作，该动作对于计数类运算效率非常高，它向客户端返回 Map[T,Long] 类型的结果。对 MatchData记录中的 matched 字段映射调用 countByValue 会执行一个 Spark 作业，并向客户端返回结果：    scala&gt; val matchCounts = parsed.map(md =&gt; md.matched).countByValue()countByValue:统计一个RDD中各个value的出现次数。返回一个map，map的key是元素的值，value是出现的次数。count:  统计RDD中元素的个数。countByKey: 与count类似，但是是以key为单位进行统计。 注意：此函数返回的是一个map，不是int。Scala 的Map 类没有提供根据内容的键或值排序的方法，但是我们可以将 Map 转换成Scala 的Seq 类型，而Seq 支持排序。Scala 的 Seq 类和 Java 的 List 类接口类似，都是可迭代集合，即具有确定的长度并且可以根据下标来查找值。    scala&gt; val matchCountsSeq = matchCounts.toSeq    matchCountsSeq: Seq[(Boolean, Long)] = ArrayBuffer((true,20931), (false,5728201))------------------------------------------------------------------------------------------------        Scala 集合            Scala 集合类库很庞大，包括 list、set、map 和 array。利用 toList、toSet 和 toArray            方法，各种集合类型可以方便地相互转换。------------------------------------------------------------------------------------------------sortBy 排序matchCountsSeq.sortBy(_._1).foreach(println)matchCountsSeq.sortBy(_._2).foreach(println)matchCountsSeq.sortBy(_._2).reverse.foreach(println)_._1 指按第一列指标排序reverse 反转排序结果</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Spark定义&quot;&gt;&lt;a href=&quot;#Spark定义&quot; class=&quot;headerlink&quot; title=&quot;Spark定义:&quot;&gt;&lt;/a&gt;Spark定义:&lt;/h3&gt;&lt;p&gt;Spark编程始于数据集，而数据集往往存放在分布式持久化存储之上，比如Hadoop分布式文件系统HDFS&lt;/p&gt;
&lt;p&gt;编写Spark 程序通常包括一系列相关步骤。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;• 在输入数据集上定义一组转换。
• 调用 action，用以将转换后的数据集保存到持久存储上，或者把结果返回到驱动程序的
本地内存。
• 运行本地计算，本地计算处理分布式计算的结果。本地计算有助于你确定下一步的转换
和 action。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="spark" scheme="http://yoursite.com/categories/spark/"/>
    
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>redis取经之路</title>
    <link href="http://yoursite.com/2019/05/21/redis%E5%8F%96%E7%BB%8F%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/05/21/redis取经之路/</id>
    <published>2019-05-21T06:44:34.000Z</published>
    <updated>2019-06-04T03:08:08.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis基本数据结构"><a href="#redis基本数据结构" class="headerlink" title="redis基本数据结构"></a>redis基本数据结构</h3><p>Redis使用的是自己构建的简单动态字符串(SDS)[simple dynamic string,SDS]的抽象类型，并将SDS用做Rdis的默认字符串表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello&quot;</span><br><span class="line">Ok</span><br></pre></td></tr></table></figure></p><p>redis的Key-Value的存储方式</p><pre><code>key是一个字符串对象，对象的底层实现是一个保存着字符串&quot;msg&quot;的SDSvalue也是一个字符串对象，对象的底层实现是一个保存着字符串&quot;hello&quot;的SDS</code></pre><p>SDS除了用来保存数据库中的字符串值之外，还被用作缓冲区(Buffer):AOF模块中的AOF缓冲区<br><a id="more"></a></p><p>基本数据类型</p><pre><code>- 字符串命令:GET SET DEL- 列表:一个列表结构可以有序地存储多个字符串     LPUSH RPUSH 表示元素推入列表的左端和右端     LPOP RPOP分别从列表的左端和右端弹出元素，被弹出的元素不再属于列表     LINDEX用于获取列表在给定位置的上一个元素     LRANGE用于获取列表在给定范围上的所有元素- 集合:列表可以存储多个相同的字符串，集合则通过散列表来保证自己存储的每个字符串都是各不相同的(这些散列表只有键，但没有与键相关联的值)     redis的集合使用的是无序方式存储元素     SADD:将元素添加到集合        redis&gt; sadd fengjr &quot;hehehehe&quot;        (integer) 1     SREM:从集合移除元素，命令会返回被移除元素的数量     SMEMBERS:获取集合包含的所有元素将得到一个由元素组成的序列     SISMEMBER:快速检查一个元素是否已经存在于集合中- 散列:redis的散列可以存储多个键值对之间的映射。和字符串一样，散列存储的值既可以是字符串，又可以是数字值，并且用户同样可以对散列存储的数字值执行自增操作或者自减操作     HSET:在散列里面关联起给定的键值对        hset hash-key sub-key1 value1        hset hash-key sub-key2 value2        栗子:        redis&gt; HSET myhash field1 123        redis&gt; HSET myhash name liangym     返回值为1表示给定的键不存在于散列里面，添加成功     返回值为0表示给定的键存在于散列里面，添加失败     HDEL:如果给定键存在于散列里面，删除这个键        栗子:        redis&gt; HDEL myhash name        (integer) 1 删除成功     HGET:从散列里面获取某个键的值     HGETALL:获取散列包含的所有键值对        栗子:        redis&gt; HGETALL myhash        1) &quot;filed1&quot;        2) &quot;foo&quot;        3) &quot;field1&quot;        4) &quot;123&quot;     HINCRBY:对散列存储的值执行自增操作     HINCRBY key field icrement        栗子:        redis&gt;HINCRBY myhash field1 123        (integer) 246- 有序集合:和散列一样都用于存储键值对：有序集合的键被称为成员(member)，每个成员都是各不相同的；而有序集合的值则被称为分值(score)，分值必须为浮点数     ZADD:将一个带有给定分值的成员添加到有序集合里面        栗子:        redis&gt;zadd zset-key 728 member     ZRANGE:根据元素在有序排列中所处的位置，从有序集合里面获取多个元素     ZRANGEBYSCORE:获取有序集合在给定分值范围内的所有元素     ZREM:如果给定成员存在于有序集合，那么移除这个成员     ZINCRBY:给有序集合成员的分值执行自增操作        栗子:        ZINCRBY key increment member        redis&gt;ZINCRBY zset-key 123 member1    ZSCORE:检查记录的有序集合的值        栗子:        ZSCORE key member        redis&gt;ZSCORE zset-key member1        &quot;851&quot;</code></pre><h3 id="redis的特性"><a href="#redis的特性" class="headerlink" title="redis的特性"></a>redis的特性</h3><pre><code>数据结构内存存储(这使得Redis的速度非常快)远程(这使得Redis可以与多个客户端和服务器进行连接)持久化(这可以使得服务器可以再重启之后仍然保持重启之前的数据)可扩展(通过主从复制和分片)通过将传统数据库的一部分数据处理任务以及存储任务转交给redis来完成，可以提升网页的载入速度，并降低资源的占用量</code></pre><h3 id="场景一：登录和cookie缓存"><a href="#场景一：登录和cookie缓存" class="headerlink" title="场景一：登录和cookie缓存"></a>场景一：登录和cookie缓存</h3><pre><code>将登录信息存储在cookie中  可以用签名(signed) 和令牌(token)使用redis来记录用户信息，将每天要对数据库执行的写入操作减少了很多</code></pre><h3 id="场景二：购物车"><a href="#场景二：购物车" class="headerlink" title="场景二：购物车"></a>场景二：购物车</h3><pre><code>定义：散列：每个用户的购物车key：商品IDvalue：商品订购数量将会话和购物车都存储到Redis里面，这样可以减少请求的体积，还可以使得我们根据用户浏览过的上铺，用户放入购物车的商品，以及用户最终购买的商品进行统计计算。实现：在查看过这件商品的用户当中，有X%的用户最终购买了这件商品， 购买了这件商品的用户也购买了某某某其他商品 等功能</code></pre><h3 id="网页缓存"><a href="#网页缓存" class="headerlink" title="网页缓存"></a>网页缓存</h3><pre><code>页面内容不需要动态生成，减少网站在动态生成内容上面所花的时间，可以降低网站处理相同负载所需的服务器数量，并让网站的速度变得更快(增强用户体验)中间层的作用：对于一个不能被缓存的请求，函数将直接生成并返回页面，而对于可以被缓存的请求，函数首先会尝试从缓存里取出并返回被缓存的页面，如果缓存页面不存在，那么函数会生成页面并将其缓存在Redis中5分钟，最后将页面返回给函数调用者</code></pre><h3 id="数据行缓存"><a href="#数据行缓存" class="headerlink" title="数据行缓存"></a>数据行缓存</h3><pre><code>场景：促销活动，会推出一些特价商品供用户抢购疑虑：网站如果对整个促销页面进行缓存，可能会导致用户看到错误的特价商品的数量，但如果每次都从数据库里面取出特价商品的剩余数量的话又会给数据库带来巨大的压力，导致我们需要花费额外的成本来扩展数据库。解决：促销活动必定会带来一些负载，所以必须对数据进行缓存，编写一个持续运行的守护进程，让这个函数将指定的数据行缓存到redis里面，并不定期地对这些缓存进行更新。设置两个有序集合，分别为：调度有序集合，延时有序集合，调度顾名思义调度，延时则是设置了指定数据航的缓存需要每隔多少秒更新一次如果数据行记录的是特价促销商品的剩余数量，并且参与促销活动的用户非常多的话，那么我们最好每隔几秒更新一次数据行缓存；另一方面，如果数据并不经常改变，或者商品缺货是可以接受的，那么我们可以将更新缓存的时间变长</code></pre><h3 id="网页分析"><a href="#网页分析" class="headerlink" title="网页分析"></a>网页分析</h3><h3 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;redis基本数据结构&quot;&gt;&lt;a href=&quot;#redis基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;redis基本数据结构&quot;&gt;&lt;/a&gt;redis基本数据结构&lt;/h3&gt;&lt;p&gt;Redis使用的是自己构建的简单动态字符串(SDS)[simple dynamic string,SDS]的抽象类型，并将SDS用做Rdis的默认字符串表示&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;redis&amp;gt; SET msg &amp;quot;hello&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ok&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;redis的Key-Value的存储方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;key是一个字符串对象，对象的底层实现是一个保存着字符串&amp;quot;msg&amp;quot;的SDS
value也是一个字符串对象，对象的底层实现是一个保存着字符串&amp;quot;hello&amp;quot;的SDS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SDS除了用来保存数据库中的字符串值之外，还被用作缓冲区(Buffer):AOF模块中的AOF缓冲区&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Git配置SSH密钥</title>
    <link href="http://yoursite.com/2019/05/16/Git%E9%85%8D%E7%BD%AESSH%E5%AF%86%E9%92%A5/"/>
    <id>http://yoursite.com/2019/05/16/Git配置SSH密钥/</id>
    <published>2019-05-16T01:48:08.000Z</published>
    <updated>2019-06-04T03:08:33.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><pre><code>在随便一个文件夹空白处右击 点击 Git Bash Here初次安装git配置用户名和邮箱$ git config --global user.name &quot;yiming.liang&quot;$ git config --global user.email &quot;18135479521@163.com&quot;注意：（引号内请输入你自己设置的名字，和你自己的邮箱）此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱</code></pre><a id="more"></a><pre><code>git使用ssh密钥--------------------------------------------------------------------------------git使用https协议，每次pull, push都会提示要输入密码，使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦初次使用git的用户要使用git协议大概需要三个步骤：一、生成密钥对二、设置远程仓库（本文以github为例）上的公钥三、把git的 remote url 修改为git协议（以上两个步骤初次设置过以后，以后使用都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤）一、生成密钥对--------------------------------------------------------------------------------大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看：$ cd ~/.ssh$ lsauthorized_keys2  id_dsa       known_hosts config            id_dsa.pub看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;Creates a new ssh key using the provided email # Generating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa):直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)：Enter same passphrase again: [Type passphrase again]完了之后，大概是这样：Your public key has been saved in /home/you/.ssh/id_rsa.pub.The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com到此为止，你本地的密钥对就生成了。二、添加公钥到你的远程仓库（github）1、查看你生成的公钥：$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC2、登陆你的github帐户。点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key3、然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。4、点击 Add key。完成以后，验证下这个key是不是正常工作：$ ssh -T git@github.comAttempts to ssh to github如果，看到：Hi xxx! You&apos;ve successfully authenticated, but GitHub does not # provide shell access.恭喜你，你的设置已经成功了。三、修改git的remote url使用命令 git remote -v 查看你当前的 remote url$ git remote -vorigin https://github.com/someaccount/someproject.git (fetch)origin https://github.com/someaccount/someproject.git (push)如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议）你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url，类似：复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。git remote set-url origin git@github.com:someaccount/someproject.git然后你可以再用命令 git remote -v 查看一下，url是否已经变成了ssh地址。然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了参考链接：http://www.tuicool.com/articles/BzUrAvF</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;配置用户名和邮箱&quot;&gt;&lt;a href=&quot;#配置用户名和邮箱&quot; class=&quot;headerlink&quot; title=&quot;配置用户名和邮箱&quot;&gt;&lt;/a&gt;配置用户名和邮箱&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在随便一个文件夹空白处右击 点击 Git Bash Here
初次安装git配置用户名和邮箱


$ git config --global user.name &amp;quot;yiming.liang&amp;quot;
$ git config --global user.email &amp;quot;18135479521@163.com&amp;quot;
注意：（引号内请输入你自己设置的名字，和你自己的邮箱）此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>leetCode 155 最小栈</title>
    <link href="http://yoursite.com/2019/05/06/leetCode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://yoursite.com/2019/05/06/leetCode-155-最小栈/</id>
    <published>2019-05-06T10:04:32.000Z</published>
    <updated>2019-06-03T07:54:03.892Z</updated>
    
    <content type="html"><![CDATA[<pre><code>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) -- 将元素 x 推入栈中。pop() -- 删除栈顶的元素。top() -- 获取栈顶元素。getMin() -- 检索栈中的最小元素。</code></pre><a id="more"></a><pre><code>示例:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    //声明栈</span><br><span class="line">    private Stack&lt;Integer&gt; stack;</span><br><span class="line">    //声明初始最小值为Integer.MAX_VALUE保证第一个push的值必定毕它小则可以设定第一个push的值为最小值</span><br><span class="line">    private int min = Integer.MAX_VALUE;</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line"></span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">        //新建栈</span><br><span class="line">        stack = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        //判断如果push的值小于等于min值则将之前的最小值入栈，min设置为当前最小值，之后将当前最小值入栈</span><br><span class="line">        // &gt;= 中的 等于是为了避免出现相同值的情况 比如 0,1,0</span><br><span class="line">        if(min&gt;=x)&#123;</span><br><span class="line">            stack.push(min);</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        //判断pop的值是否和当前最小值相等，如果相等则将上一次push的值设为最小值(因为pop后栈顶元素为上一次入栈的最小值)，整体思路就是每次遇到最小值时将上一次的最小值push，之后push当前最小值，pop的时候也是同样，如果pop的值等于最小值则将最小值设置为上一次push入的值，注意pop的时候，只要执行了pop()方法，栈顶元素就出栈了，则当前最小值出栈，此时栈顶元素为上一次push的最小值，所以可以直接设置为最小值(即 min = stack.pop())</span><br><span class="line">        if(stack.pop() == min)&#123;</span><br><span class="line">            min = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int top() &#123;</span><br><span class="line">        //打印栈顶元素</span><br><span class="line">        return stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMin() &#123;</span><br><span class="line">        //直接返回设定的最小值</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 忽略这段</span><br><span class="line">* Your MinStack object will be instantiated and called as such:</span><br><span class="line">* MinStack obj = new MinStack();</span><br><span class="line">* obj.push(x);</span><br><span class="line">* obj.pop();</span><br><span class="line">* int param_3 = obj.top();</span><br><span class="line">* int param_4 = obj.getMin();</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) -- 将元素 x 推入栈中。
pop() -- 删除栈顶的元素。
top() -- 获取栈顶元素。
getMin() -- 检索栈中的最小元素。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>linux高级命令</title>
    <link href="http://yoursite.com/2019/05/06/linux%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/05/06/linux高级命令/</id>
    <published>2019-05-06T06:48:25.000Z</published>
    <updated>2019-06-04T03:09:12.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><pre><code>awk是行处理器: 相比较屏幕处理的优点，在处理庞大文件时不会出现内存溢出或是处理缓慢的问题，通常用来格式化文本信息awk处理过程: 依次对每一行进行处理，然后输出awk命令形式:awk [-F|-f|-v] ‘BEGIN{} //{command1; command2} END{}’ file[-F|-f|-v]   大参数，-F指定分隔符，-f调用脚本，-v定义变量 var=value&apos;  &apos;          引用代码块BEGIN   初始化代码块，在对每一行进行处理之前，初始化代码，主要是引用全局变量，设置FS分隔符//           匹配代码块，可以是字符串或正则表达式{}           命令代码块，包含一条或多条命令；          多条命令使用分号分隔END      结尾代码块，在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息</code></pre><a id="more"></a><pre><code>特殊要点:$0           表示整个当前行$1           每行第一个字段NF          字段数量变量NR          每行的记录号，多文件记录递增FNR        与NR类似，不过多文件记录不递增，每个文件都从1开始\t            制表符\n           换行符FS          BEGIN时定义分隔符RS       输入的记录分隔符， 默认为换行符(即文本是按一行一行输入)~            匹配，与==相比不是精确比较!~           不匹配，不精确比较==         等于，必须全部相等，精确比较!=           不等于，精确比较&amp;&amp;　     逻辑与||             逻辑或+            匹配时表示1个或1个以上/[0-9][0-9]+/   两个或两个以上数字/[0-9][0-9]*/    一个或一个以上数字FILENAME 文件名OFS      输出字段分隔符， 默认也是空格，可以改为制表符等ORS        输出的记录分隔符，默认为换行符,即处理结果也是一行一行输出到屏幕-F&apos;[:#/]&apos;   定义三个分隔符print &amp; $0print 是awk打印指定内容的主要命令awk &apos;{print}&apos;  /etc/passwd   ==   awk &apos;{print $0}&apos;  /etc/passwd  awk &apos;{print &quot; &quot;}&apos; /etc/passwd                                           //不输出passwd的内容，而是输出相同个数的空行，进一步解释了awk是一行一行处理文本awk &apos;{print &quot;a&quot;}&apos;   /etc/passwd                                        //输出相同个数的a行，一行只有一个a字母awk -F&quot;:&quot; &apos;{print $1}&apos;  /etc/passwd awk -F: &apos;{print $1; print $2}&apos;   /etc/passwd                   //将每一行的前二个字段，分行输出，进一步理解一行一行处理文本awk  -F: &apos;{print $1,$3,$6}&apos; OFS=&quot;\t&quot; /etc/passwd        //输出字段1,3,6，以制表符作为分隔符-f指定脚本文件awk -f script.awk  fileBEGIN{FS=&quot;:&quot;}{print $1}               //效果与awk -F&quot;:&quot; &apos;{print $1}&apos;相同,只是分隔符使用FS在代码自身中指定awk &apos;BEGIN{X=0} /^$/{ X+=1 } END{print &quot;I find&quot;,X,&quot;blank lines.&quot;}&apos; test I find 4 blank lines.ls -l|awk &apos;BEGIN{sum=0} !/^d/{sum+=$5} END{print &quot;total size is&quot;,sum}&apos;                    //计算文件大小total size is 17487-F指定分隔符$1 指指定分隔符后，第一个字段，$3第三个字段， \t是制表符一个或多个连续的空格或制表符看做一个定界符，即多个空格看做一个空格awk -F&quot;:&quot; &apos;{print $1}&apos;  /etc/passwdawk -F&quot;:&quot; &apos;{print $1 $3}&apos;  /etc/passwd                       //$1与$3相连输出，不分隔awk -F&quot;:&quot; &apos;{print $1,$3}&apos;  /etc/passwd                       //多了一个逗号，$1与$3使用空格分隔awk -F&quot;:&quot; &apos;{print $1 &quot; &quot; $3}&apos;  /etc/passwd                  //$1与$3之间手动添加空格分隔awk -F&quot;:&quot; &apos;{print &quot;Username:&quot; $1 &quot;\t\t Uid:&quot; $3 }&apos; /etc/passwd       //自定义输出  awk -F: &apos;{print NF}&apos; /etc/passwd                                //显示每行有多少字段awk -F: &apos;{print $NF}&apos; /etc/passwd                              //将每行第NF个字段的值打印出来awk -F: &apos;NF==4 {print }&apos; /etc/passwd                       //显示只有4个字段的行awk -F: &apos;NF&gt;2{print $0}&apos; /etc/passwd                       //显示每行字段数量大于2的行awk &apos;{print NR,$0}&apos; /etc/passwd                                 //输出每行的行号awk -F: &apos;{print NR,NF,$NF,&quot;\t&quot;,$0}&apos; /etc/passwd      //依次打印行号，字段数，最后字段值，制表符，每行内容awk -F: &apos;NR==5{print}&apos;  /etc/passwd                         //显示第5行awk -F: &apos;NR==5 || NR==6{print}&apos;  /etc/passwd       //显示第5行和第6行route -n|awk &apos;NR!=1{print}&apos;                                       //不显示第一行//匹配代码块//纯字符匹配   !//纯字符不匹配   ~//字段值匹配    !~//字段值不匹配   ~/a1|a2/字段值匹配a1或a2   awk &apos;/mysql/&apos; /etc/passwdawk &apos;/mysql/{print }&apos; /etc/passwdawk &apos;/mysql/{print $0}&apos; /etc/passwd                   //三条指令结果一样awk &apos;!/mysql/{print $0}&apos; /etc/passwd                  //输出不匹配mysql的行awk &apos;/mysql|mail/{print}&apos; /etc/passwdawk &apos;!/mysql|mail/{print}&apos; /etc/passwdawk -F: &apos;/mail/,/mysql/{print}&apos; /etc/passwd         //区间匹配awk &apos;/[2][7][7]*/{print $0}&apos; /etc/passwd               //匹配包含27为数字开头的行，如27，277，2777...awk -F: &apos;$1~/mail/{print $1}&apos; /etc/passwd           //$1匹配指定内容才显示awk -F: &apos;{if($1~/mail/) print $1}&apos; /etc/passwd     //与上面相同awk -F: &apos;$1!~/mail/{print $1}&apos; /etc/passwd          //不匹配awk -F: &apos;$1!~/mail|mysql/{print $1}&apos; /etc/passwd        IF语句必须用在{}中，且比较内容用()扩起来awk -F: &apos;{if($1~/mail/) print $1}&apos; /etc/passwd                                       //简写awk -F: &apos;{if($1~/mail/) {print $1}}&apos;  /etc/passwd                                   //全写awk -F: &apos;{if($1~/mail/) {print $1} else {print $2}}&apos; /etc/passwd            //if...else...条件表达式==   !=   &gt;   &gt;=  awk -F&quot;:&quot; &apos;$1==&quot;mysql&quot;{print $3}&apos; /etc/passwd  awk -F&quot;:&quot; &apos;{if($1==&quot;mysql&quot;) print $3}&apos; /etc/passwd          //与上面相同 awk -F&quot;:&quot; &apos;$1!=&quot;mysql&quot;{print $3}&apos; /etc/passwd                 //不等于awk -F&quot;:&quot; &apos;$3&gt;1000{print $3}&apos; /etc/passwd                      //大于awk -F&quot;:&quot; &apos;$3&gt;=100{print $3}&apos; /etc/passwd                     //大于等于awk -F&quot;:&quot; &apos;$3&lt;1{print $3}&apos; /etc/passwd                            //小于awk -F&quot;:&quot; &apos;$3&lt;=1{print $3}&apos; /etc/passwd                         //小于等于逻辑运算符&amp;&amp;　|| awk -F: &apos;$1~/mail/ &amp;&amp; $3&gt;8 {print }&apos; /etc/passwd         //逻辑与，$1匹配mail，并且$3&gt;8awk -F: &apos;{if($1~/mail/ &amp;&amp; $3&gt;8) print }&apos; /etc/passwdawk -F: &apos;$1~/mail/ || $3&gt;1000 {print }&apos; /etc/passwd       //逻辑或awk -F: &apos;{if($1~/mail/ || $3&gt;1000) print }&apos; /etc/passwd 数值运算awk -F: &apos;$3 &gt; 100&apos; /etc/passwd    awk -F: &apos;$3 &gt; 100 || $3 &lt; 5&apos; /etc/passwd  awk -F: &apos;$3+$4 &gt; 200&apos; /etc/passwdawk -F: &apos;/mysql|mail/{print $3+10}&apos; /etc/passwd                    //第三个字段加10打印 awk -F: &apos;/mysql/{print $3-$4}&apos; /etc/passwd                             //减法awk -F: &apos;/mysql/{print $3*$4}&apos; /etc/passwd                             //求乘积awk &apos;/MemFree/{print $2/1024}&apos; /proc/meminfo                  //除法awk &apos;/MemFree/{print int($2/1024)}&apos; /proc/meminfo           //取整输出分隔符OFSawk &apos;$6 ~ /FIN/ || NR==1 {print NR,$4,$5,$6}&apos; OFS=&quot;\t&quot; netstat.txtawk &apos;$6 ~ /WAIT/ || NR==1 {print NR,$4,$5,$6}&apos; OFS=&quot;\t&quot; netstat.txt        //输出字段6匹配WAIT的行，其中输出每行行号，字段4，5,6，并使用制表符分割字段输出处理结果到文件①在命令代码块中直接输出    route -n|awk &apos;NR!=1{print &gt; &quot;./fs&quot;}&apos;   ②使用重定向进行输出           route -n|awk &apos;NR!=1{print}&apos;  &gt; ./fs格式化输出netstat -anp|awk &apos;{printf &quot;%-8s %-8s %-10s\n&quot;,$1,$2,$3}&apos; printf表示格式输出%格式化输出分隔符-8长度为8个字符s表示字符串类型打印每行前三个字段，指定第一个字段输出字符串类型(长度为8)，第二个字段输出字符串类型(长度为8),第三个字段输出字符串类型(长度为10)netstat -anp|awk &apos;$6==&quot;LISTEN&quot; || NR==1 {printf &quot;%-10s %-10s %-10s \n&quot;,$1,$2,$3}&apos;netstat -anp|awk &apos;$6==&quot;LISTEN&quot; || NR==1 {printf &quot;%-3s %-10s %-10s %-10s \n&quot;,NR,$1,$2,$3}&apos;IF语句awk -F: &apos;{if($3&gt;100) print &quot;large&quot;; else print &quot;small&quot;}&apos; /etc/passwdsmallsmallsmalllargesmallsmallawk -F: &apos;BEGIN{A=0;B=0} {if($3&gt;100) {A++; print &quot;large&quot;} else {B++; print &quot;small&quot;}} END{print A,&quot;\t&quot;,B}&apos; /etc/passwd                                                                                                                 //ID大于100,A加1，否则B加1awk -F: &apos;{if($3&lt;100) next; else print}&apos; /etc/passwd                         //小于100跳过，否则显示awk -F: &apos;BEGIN{i=1} {if(i&lt;NF) print NR,NF,i++ }&apos; /etc/passwd   awk -F: &apos;BEGIN{i=1} {if(i&lt;NF) {print NR,NF} i++ }&apos; /etc/passwd另一种形式awk -F: &apos;{print ($3&gt;100 ? &quot;yes&quot;:&quot;no&quot;)}&apos;  /etc/passwd awk -F: &apos;{print ($3&gt;100 ? $3&quot;:\tyes&quot;:$3&quot;:\tno&quot;)}&apos;  /etc/passwdwhile语句awk -F: &apos;BEGIN{i=1} {while(i&lt;NF) print NF,$i,i++}&apos; /etc/passwd 7 root 17 x 27 0 37 0 47 root 57 /root 6数组netstat -anp|awk &apos;NR!=1{a[$6]++} END{for (i in a) print i,&quot;\t&quot;,a[i]}&apos;netstat -anp|awk &apos;NR!=1{a[$6]++} END{for (i in a) printf &quot;%-20s %-10s %-5s \n&quot;, i,&quot;\t&quot;,a[i]}&apos;9523                               1     9929                               1     LISTEN                            6     7903                               1     3038/cupsd                   1     7913                               1     10837                             1     9833                               1     应用1awk -F: &apos;{print NF}&apos; helloworld.sh                                                       //输出文件每行有多少字段awk -F: &apos;{print $1,$2,$3,$4,$5}&apos; helloworld.sh                                 //输出前5个字段awk -F: &apos;{print $1,$2,$3,$4,$5}&apos; OFS=&apos;\t&apos; helloworld.sh                 //输出前5个字段并使用制表符分隔输出awk -F: &apos;{print NR,$1,$2,$3,$4,$5}&apos; OFS=&apos;\t&apos; helloworld.sh           //制表符分隔输出前5个字段，并打印行号应用2awk -F&apos;[:#]&apos; &apos;{print NF}&apos;  helloworld.sh                                                  //指定多个分隔符: #，输出每行多少字段awk -F&apos;[:#]&apos; &apos;{print $1,$2,$3,$4,$5,$6,$7}&apos; OFS=&apos;\t&apos; helloworld.sh   //制表符分隔输出多字段应用3awk -F&apos;[:#/]&apos; &apos;{print NF}&apos; helloworld.sh                                               //指定三个分隔符，并输出每行字段数awk -F&apos;[:#/]&apos; &apos;{print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12}&apos; helloworld.sh     //制表符分隔输出多字段应用4计算/home目录下，普通文件的大小，使用KB作为单位ls -l|awk &apos;BEGIN{sum=0} !/^d/{sum+=$5} END{print &quot;total size is:&quot;,sum/1024,&quot;KB&quot;}&apos;ls -l|awk &apos;BEGIN{sum=0} !/^d/{sum+=$5} END{print &quot;total size is:&quot;,int(sum/1024),&quot;KB&quot;}&apos;         //int是取整的意思应用5统计netstat -anp 状态为LISTEN和CONNECT的连接数量分别是多少netstat -anp|awk &apos;$6~/LISTEN|CONNECTED/{sum[$6]++} END{for (i in sum) printf &quot;%-10s %-6s %-3s \n&quot;, i,&quot; &quot;,sum[i]}&apos;应用6统计/home目录下不同用户的普通文件的总数是多少？ls -l|awk &apos;NR!=1 &amp;&amp; !/^d/{sum[$3]++} END{for (i in sum) printf &quot;%-6s %-5s %-3s \n&quot;,i,&quot; &quot;,sum[i]}&apos;   mysql        199 root           374 统计/home目录下不同用户的普通文件的大小总size是多少？ls -l|awk &apos;NR!=1 &amp;&amp; !/^d/{sum[$3]+=$5} END{for (i in sum) printf &quot;%-6s %-5s %-3s %-2s \n&quot;,i,&quot; &quot;,sum[i]/1024/1024,&quot;MB&quot;}&apos;应用7输出成绩表awk &apos;BEGIN{math=0;eng=0;com=0;printf &quot;Lineno.   Name    No.    Math   English   Computer    Total\n&quot;;printf &quot;------------------------------------------------------------\n&quot;}{math+=$3; eng+=$4; com+=$5;printf &quot;%-8s %-7s %-7s %-7s %-9s %-10s %-7s \n&quot;,NR,$1,$2,$3,$4,$5,$3+$4+$5} END{printf &quot;------------------------------------------------------------\n&quot;;printf &quot;%-24s %-7s %-9s %-20s \n&quot;,&quot;Total:&quot;,math,eng,com;printf &quot;%-24s %-7s %-9s %-20s \n&quot;,&quot;Avg:&quot;,math/NR,eng/NR,com/NR}&apos; test0[root@localhost home]# cat test0 Marry   2143 78 84 77Jack    2321 66 78 45Tom     2122 48 77 71Mike    2537 87 97 95Bob     2415 40 57 62awk手册http://www.chinaunix.net/old_jh/7/16985.html</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;awk&quot;&gt;&lt;a href=&quot;#awk&quot; class=&quot;headerlink&quot; title=&quot;awk&quot;&gt;&lt;/a&gt;awk&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;awk是行处理器: 相比较屏幕处理的优点，在处理庞大文件时不会出现内存溢出或是处理缓慢的问题，通常用来格式化文本信息
awk处理过程: 依次对每一行进行处理，然后输出
awk命令形式:
awk [-F|-f|-v] ‘BEGIN{} //{command1; command2} END{}’ file
[-F|-f|-v]   大参数，-F指定分隔符，-f调用脚本，-v定义变量 var=value
&amp;apos;  &amp;apos;          引用代码块
BEGIN   初始化代码块，在对每一行进行处理之前，初始化代码，主要是引用全局变量，设置FS分隔符
//           匹配代码块，可以是字符串或正则表达式
{}           命令代码块，包含一条或多条命令
；          多条命令使用分号分隔
END      结尾代码块，在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>springCloud多模块打包时报错问题</title>
    <link href="http://yoursite.com/2019/04/25/springCloud%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%97%B6%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/25/springCloud多模块打包时报错问题/</id>
    <published>2019-04-25T07:08:51.000Z</published>
    <updated>2019-05-30T09:18:08.415Z</updated>
    
    <content type="html"><![CDATA[<p>执行mvn clean package spring-boot:repackage，报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:1.5.3.RELEASE:repackage (default)</span><br><span class="line"> on project webapps-api-bid: Execution default of goal org.springframework.boot:spring-boot-maven-plugin:1.5.3.RELEASE:</span><br><span class="line"> repackage failed: Unable to find main class</span><br></pre></td></tr></table></figure></p><p>错误提示：</p><p><code>repackage failed: Unable to find main class</code><br><a id="more"></a><br>原因：</p><pre><code>多模块打包时，如果项目模块包含common，core等模块，这些模块不需要启动，应把其打成不可执行包来使用那当我们在maven中有多重依赖时，应注意一点，Common打包出来的应该是不可执行的jar包，所以不要在Common的pom中定义spring-boot-maven-plugin插件。项目    yixue（父类工程，定义各模块，指定模块依赖jar版本）|------------------------------|--yixue-admin    后台用户注册||--yixue-course  后台视频管理||--yixue-commom     common工具包，维护工具类，公共类||--yixue-ui    web界面，请求跳转，拦截等||--yixue-eureka   SpringCloud注册</code></pre><p>解决方法：</p><pre><code>common项目中除了必要的依赖包以外，maven打包的插件不要再添加一遍了，因为这个SpringBoot插件会在Maven的package后进行二次打包，目的为了生成可执行jar包，如果C中定义了这个插件，会报错提示没有找到main函数简单来说，如果你的root：`&lt;parent&gt;&lt;/parent&gt;`项目已经添加了`spring-boot-maven-plugin`插件，那么common就别依赖root了，自己包含一些必要的依赖包，之后别手动添加打包插件即可，如果打包还是失败的话，对root项目clean再install一下，之后应该没有什么问题了</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;执行mvn clean package spring-boot:repackage，报错如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:1.5.3.RELEASE:repackage (default)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; on project webapps-api-bid: Execution default of goal org.springframework.boot:spring-boot-maven-plugin:1.5.3.RELEASE:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; repackage failed: Unable to find main class&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;错误提示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;repackage failed: Unable to find main class&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="springCloud" scheme="http://yoursite.com/tags/springCloud/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SQL分析函数场景实例</title>
    <link href="http://yoursite.com/2019/04/18/SQL%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0%E5%9C%BA%E6%99%AF%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/04/18/SQL分析函数场景实例/</id>
    <published>2019-04-18T10:51:34.000Z</published>
    <updated>2019-05-15T08:22:28.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h3><ol><li><p>用来排序的函数<br>它和聚合函数的不同之处是对于每个组返回多行<br><code>row_number() over()rank() over()dense_rank() over()first_value() over()</code></p><a id="more"></a><p><a href="https://blog.csdn.net/myflysun/article/details/70477204" target="_blank" rel="noopener">语法:</a></p><p> row_number() over([partition by xxx] [order by xxx]) 返回的是行信息，没有排名<br> rank ( )  over([partition by xxx] [order by xxx]) 返回的相关等级不会跳跃<br> dense_rank ( ) over([partition by xxx] [order by xxx]) 返回的返回的相关等级会跳跃</p></li></ol><p>场景: 查询每个班的第一名的成绩</p><pre><code>SELECT * FROM (select t.name,t.class,t.sroce,rank() over(partition by t.class order by t.sroce desc) mm from T2_TEMP t) where mm = 1;</code></pre><p><code>LagLead</code></p><p><a href="https://blog.csdn.net/pelifymeng2/article/details/70313943" target="_blank" rel="noopener">语法:</a></p><pre><code>lag(exp_str,offset,defval) over(partion by ..order by …)lead(exp_str,offset,defval) over(partion by ..order by …)其中exp_str是字段名Offset是偏移量，即是上1个或上N个的值，假设当前行在表中排在第5行，则offset 为3，则表示我们所要找的数据行就是表中的第2行（即5-3=2）,默认值是1Defval默认值，当两个函数取上N/下N个值，当在表中从当前行位置向前数N行已经超出了表的范围时，lag（）函数将defval这个参数值作为函数的返回值，若没有指定默认值，则返回NULL，那么在数学运算中，总要给一个默认值才不会出错。</code></pre><ol start="2"><li><p>聚合函数</p><pre><code>聚合函数对于每个组只返回一行count、max、min、sum、avg、Variance、StddevCount 用来求有效数据的数量Max 用来求给定数据中最大的那一个数据Min    用来求给定数据中最小的那一个数据Avg    用来求给定数据的平均值Sum 用来求给定数据的总和Variance 用来求给定数据的标准差Stddev 用来求给定数据的方差median 主要用于统计整表或者分组情况下的中位数（限定参数为数值型或日期/时间型），忽略NULL值对于聚合函数，如果给定的值中存在空值的话，oracle将会直接忽略select count(*) from xxx对于聚合函数中可以使用distinct关键字来压缩重复值比如我们想统计总共有多少个部门的话我们如果写Select count(deptno) from emp;将会得到错误的结果。因为实际上有很多重复的值也被计算在内。为了找到正确的答案，你应该这样写。Select count(distinct deptno) from emp;</code></pre></li><li><p><a href="http://www.cnblogs.com/cc11001100/p/9043946.html" target="_blank" rel="noopener">collect函数</a></p></li></ol><p><code>collect_listcollect_set</code></p><p>它们都是将分组中的某列转为一个数组返回，不同的是collect_list不去重而collect_set去重。</p><p>语法: </p><pre><code>collect_list(column_name)collect_set(column_name)有的时候我们想根据A进行分组然后随便取出每个分组中的一个B，代入到这个实验中就是按照用户进行分组，然后随便拿出一个他看过的视频名称即可collect_list(column_name)[0] 和取数组一样简单</code></pre><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分析函数&quot;&gt;&lt;a href=&quot;#分析函数&quot; class=&quot;headerlink&quot; title=&quot;分析函数&quot;&gt;&lt;/a&gt;分析函数&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用来排序的函数&lt;br&gt;它和聚合函数的不同之处是对于每个组返回多行&lt;br&gt;&lt;code&gt;row_number() over()
rank() over()
dense_rank() over()
first_value() over()&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="sql" scheme="http://yoursite.com/categories/sql/"/>
    
    
      <category term="sql" scheme="http://yoursite.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>springboot踩坑出坑记</title>
    <link href="http://yoursite.com/2019/04/17/springboot%E8%B8%A9%E5%9D%91%E5%87%BA%E5%9D%91%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/17/springboot踩坑出坑记/</id>
    <published>2019-04-17T09:57:26.000Z</published>
    <updated>2019-06-03T10:48:08.477Z</updated>
    
    <content type="html"><![CDATA[<p>4月15到4月17我都在把毕设从eclipse重构到IDEA中，springboot最让我头疼的是它的版本问题，因为每一个版本对应的依赖包都有可能出错，这里分享一下如何成功移植用eclipse写的springboot到IDEA中，比较简单的步骤我这里不详细说了，说一下我遇到的一些很难找出问题的地方<br>ps:只是针对于我的项目和我个人水平，大神勿喷嘿嘿<br><a id="more"></a></p><h2 id="springboot-mybatis整合坑"><a href="#springboot-mybatis整合坑" class="headerlink" title="springboot-mybatis整合坑"></a>springboot-mybatis整合坑</h2><ul><li>出现下方错误请查看启动类：XXXApplication 是否扫描到mapper映射文件，声明eclipse和idea不一样，这里eclipse可以跑通，idea中不行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Field chapterDao in cn.yixue.service.ChapterServiceImp required a bean of type &apos;cn.yixue.dao.ChapterMapper&apos; that could not be found.</span><br><span class="line"></span><br><span class="line">The injection point has the following annotations:</span><br><span class="line">    - @org.springframework.beans.factory.annotation.Autowired(required=true)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Consider defining a bean of type &apos;cn.yixue.dao.ChapterMapper&apos; in your configuration.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以上提取出有用的信息：required a bean of type &apos;xxxx&apos; that could not be found.</span><br><span class="line"></span><br><span class="line">代表bean没注入，从bean注入寻找方向，有的人会说我用@Autowired之类的种种，但没扫到，好吧~</span><br></pre></td></tr></table></figure></li></ul><p>解决方法：</p><ol><li><p>在相应的mapper类中加@Mapper标注让springboot根据标注去将mapper注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface ChapterMapper &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动类加<code>@MapperScan(value = &quot;cn.yixue.video.dao&quot;)</code> value 后的包一定要对应到mapper类对应的地方，比如我的mapper在dao下，就是<code>cn.yixue.video.dao</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(value = &quot;cn.yixue.video.dao&quot;)</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class YixueVideoApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(YixueVideoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Spring Boot项目中含有Mybatis,打Jar包运行之后,报如下错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Failed to configure a DataSource: &apos;url&apos; attribute is not specified and no embedded datasource could be configured.</span><br><span class="line"></span><br><span class="line">Reason: Failed to determine a suitable driver class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Consider the following:</span><br><span class="line">    If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.</span><br><span class="line">    If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).</span><br></pre></td></tr></table></figure></li></ol><p>网上好多解决方案，针对于每个人都不一样，我的应该是打包的时候读不到我的配置文件，需要在<code>pom.xml</code>里面加<code>resourses</code>指定下配置文件，因为eclipse是识别的，Idea可能不会？我也不太知道，反正是加上了，因为好像有Idea读不到我的<code>application.properties</code>或者<code>application.yml</code>文件，我就一次性都配上了，这个大家具体遇到的时候再去搜一下就行，不用刻意的记:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;!-- 如果不添加此节点mybatis的mapper.xml文件都会被漏掉。 --&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/*.yml&lt;/include&gt;</span><br><span class="line">            &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">            &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">        &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/*.yml&lt;/include&gt;</span><br><span class="line">            &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">            &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">        &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h2 id="springBoot-SpringCloud整合坑"><a href="#springBoot-SpringCloud整合坑" class="headerlink" title="springBoot-SpringCloud整合坑"></a>springBoot-SpringCloud整合坑</h2><ul><li>利用SpringCloud做服务注册时，Eclipse需要自己导jar包依赖和配置版本，Idea直接可以再创建Springboot项目时鼠标点击引入，这个我就放几张图来解释：</li></ul><p><img src="springboot踩坑出坑记/springCloud1.png" alt><br><img src="springboot踩坑出坑记/springCloud2.png" alt><br><img src="springboot踩坑出坑记/springCloud3.png" alt></p><p>最后一个next后直接finish……</p><p>之后再pom.xml里面会看到Idea自动为你引入的依赖和 <code>spring-boot-maven-plugin</code> 插件，插件版本我建议还是稍微低一点，因为boot真的是随着版本变动改动很大，我用的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></p><p>这个也是在网上搜了很久之后找到的一个版本，还有一个<code>1.4.9.RELEASE</code>也可以，之后就是看看Idea导入的<code>SpringCloud</code>依赖的版本<code>version</code>，版本错误很容易报<code>java.lang.AbstractMethodError: null</code>这个错误我找了很久，原因也是看了一个<a href="https://blog.csdn.net/kxj19980524/article/details/87860876" target="_blank" rel="noopener">大佬的博客</a>找到的，具体就是因为Idea给你的依赖是根据你选择的springboot的版本来的，一般人不会去修改，这也就是为什么eclipse不容易报错，Idea容易的原因，因为eclipse得自己找…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure></p><p>我的parent的版本是<code>&lt;version&gt;2.0.5.RELEASE&lt;/version&gt;</code>，大佬的文章也提到了2.1.0和2.1.0以下的有区别，我还是建议用低的，低的差别不会太大，还挺稳……我还用过1.5.9.RELEASE…</p><ul><li>之后配置<code>eureka</code>的服务的时候Idea提供的版本也要改，这个原因是因为如果使用<code>${spring-cloud.version}</code>的话,当版本号下调到<code>2.1.0</code>以下的时候,一些组件的包还是<code>2.1.0</code>它不会跟随parent版本的下调而下调,也就是parent的版本小于组件的版本,这时候就会出问题<br>当改为<code>Finchley.RELEASE</code>的时候,组件的依赖就会跟随parent的版本下调而下调<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;!-- 这是Idea给设的 --&gt;</span><br><span class="line">    &lt;!--&lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt;--&gt;</span><br><span class="line">    &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="解决静态资源跨域时的坑"><a href="#解决静态资源跨域时的坑" class="headerlink" title="解决静态资源跨域时的坑"></a>解决静态资源跨域时的坑</h2><ul><li>之前在eclipse中静态资源访问是可以通过<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RestTemplate restTemplate;</span><br></pre></td></tr></table></figure></li></ul><p>直接装配的，之后到了Idea中报错了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ERROR 31473 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : </span><br><span class="line"></span><br><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Field restTemplate in &apos;xxxxxx&apos;</span><br><span class="line">required a bean of type &apos;org.springframework.web.client.RestTemplate&apos; that could not be found.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Consider defining a bean of type &apos;org.springframework.web.client.RestTemplate&apos; in your configuration.</span><br></pre></td></tr></table></figure></p><p>解决方法如下，大致就是先靠@Bean装配，再用…:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate(RestTemplateBuilder builder) &#123;</span><br><span class="line">   // Do any additional configuration here</span><br><span class="line">   return builder.build();</span><br><span class="line">&#125;</span><br><span class="line">@Autowired</span><br><span class="line">private RestTemplate restTemplate;</span><br></pre></td></tr></table></figure></p><p>之后就不报错了(针对于我的错误)</p><h2 id="我的-pom-xml-project的xml"><a href="#我的-pom-xml-project的xml" class="headerlink" title="我的 pom.xml(project的xml)"></a>我的 pom.xml(project的xml)</h2><p>我的架构</p><p><img src="springboot踩坑出坑记/jiagou.png" alt="点我"><br>圈住的地方是下方的pom.xml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;cn.yixue&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;yixue&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        &lt;lombok.version&gt;1.14.8&lt;/lombok.version&gt;</span><br><span class="line">        &lt;fastjson.version&gt;1.2.31&lt;/fastjson.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;!--该配置必须--&gt;</span><br><span class="line">                    &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;yixue-commom&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;yixue-admin&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;yixue-video&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>这就是我移植项目遇到的一些问题，下面列一些大佬的博客，对我帮助很大，不胜感激<br>如有侵权，请联系我删除</p><ul><li><a href="https://www.cnblogs.com/skyLogin/p/9203540.html" target="_blank" rel="noopener">springboot @WebFilter过滤器的使用</a></li><li><a href="https://blog.csdn.net/kxj19980524/article/details/87860876" target="_blank" rel="noopener">java.lang.AbstractMethodError: null</a></li><li><a href="https://blog.csdn.net/kxj19980524/article/details/87860876" target="_blank" rel="noopener">不能自动装配RestTemplate  /  not found</a></li><li><a href="https://www.jianshu.com/p/836d455663da" target="_blank" rel="noopener">SpringBoot 2.0 报错: Failed to configure a DataSource: ‘url’ attribute is not specified and no embe…</a></li><li><a href="http://www.cnblogs.com/sxdcgaq8080/p/7715427.html" target="_blank" rel="noopener">在pom.xml文件中使用resources插件的小作用</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;4月15到4月17我都在把毕设从eclipse重构到IDEA中，springboot最让我头疼的是它的版本问题，因为每一个版本对应的依赖包都有可能出错，这里分享一下如何成功移植用eclipse写的springboot到IDEA中，比较简单的步骤我这里不详细说了，说一下我遇到的一些很难找出问题的地方&lt;br&gt;ps:只是针对于我的项目和我个人水平，大神勿喷嘿嘿&lt;br&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="springCloud" scheme="http://yoursite.com/tags/springCloud/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-含有重复字符的最长子串</title>
    <link href="http://yoursite.com/2019/04/10/%E5%90%AB%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/04/10/含有重复字符的最长子串/</id>
    <published>2019-04-10T08:25:25.000Z</published>
    <updated>2019-06-03T07:53:29.372Z</updated>
    
    <content type="html"><![CDATA[<pre><code>* 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。** 示例 1:* 输入: &quot;abcabcbb&quot;* 输出: 3* 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><a id="more"></a><pre><code>* &lt;p&gt;* 示例 2:* &lt;p&gt;* 输入: &quot;bbbbb&quot;* 输出: 1* 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。* &lt;p&gt;* 示例 3:* &lt;p&gt;* 输入: &quot;pwwkew&quot;* 输出: 3* 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。* 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。*/</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class LongestSubstring &#123;</span><br><span class="line">    public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int length = s.length();</span><br><span class="line">        if(length&lt;2) &#123;return length;&#125;</span><br><span class="line">        Set set = new HashSet();</span><br><span class="line">        int res = 0;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = 0;</span><br><span class="line">        while (end&lt;length)&#123;</span><br><span class="line">            if(!set.contains(s.charAt(end)))&#123;</span><br><span class="line">                set.add(s.charAt(end++));</span><br><span class="line">                res = Math.max(res,set.size());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                set.remove(s.charAt(start++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int result = lengthOfLongestSubstring(&quot;abcabcbb&quot;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;* 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。
*
* 示例 1:
* 输入: &amp;quot;abcabcbb&amp;quot;
* 输出: 3
* 解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>慢SQL优化解决方案(看这一篇就够了)</title>
    <link href="http://yoursite.com/2019/03/25/%E6%85%A2SQL%E4%BC%98%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>http://yoursite.com/2019/03/25/慢SQL优化解决方案-看这一篇就够了/</id>
    <published>2019-03-25T02:51:08.000Z</published>
    <updated>2019-04-17T10:57:22.569Z</updated>
    
    <content type="html"><![CDATA[<h3 id="慢SQL问题"><a href="#慢SQL问题" class="headerlink" title="慢SQL问题"></a>慢SQL问题</h3><p>导致慢 SQL 的原因：<br>在遇到慢 SQL 情况时，不能简单的把原因归结为 SQL 编写问题(虽然这是最常见的因素)<br>实际上导致慢 SQL 有很多因素，甚至包括硬件和 mysql 本身的 bug。根据出现的概率从大到小，罗列如下：<br><a id="more"></a><br>    SQL编写问题</p><pre><code>锁业务实例相互干绕对 IO/CPU 资源争用服务器硬件MYSQL BUG</code></pre><ul><li>由 SQL 编写导致的慢 SQL 优化</li></ul><blockquote><p>针对SQL编写导致的慢 SQL，优化起来还是相对比较方便的。<br>正如上一节提到的正确的使用索引能加快查询速度，那么我们在编写 SQL 时就需要注意与索引相关的规则：</p></blockquote><pre><code>1.字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；2.mysql 不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；3.不要在字段前面加减运算；4.字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；5.like % 在前面用不到索引；6.根据联合索引的第二个及以后的字段单独查询用不到索引；7.不要使用 select *；8.排序请尽量使用升序 ;9.or 的查询尽量用 union 代替 （Innodb）；10.复合索引高选择性的字段排在前面；11.order by / group by 字段包括在索引当中减少排序，效率会更高。12.除了上述索引使用规则外，SQL 编写时还需要特别注意一下几点：13.尽量规避大事务的 SQL，大事务的 SQL 会影响数据库的并发性能及主从同步；14.分页语句 limit 的问题；15.删除表所有记录请用 truncate，不要用 delete；16.不让 mysql 干多余的事情，如计算；17.输写 SQL 带字段，以防止后面表变更带来的问题，性能也是比较优的 ( 涉及到数据字典解析，请自行查询资料)；18.在 Innodb上用 select count(*)，因为 Innodb 会存储统计信息；19.慎用 Oder by rand()。</code></pre><blockquote><p>分析诊断工具<br>在日常开发工作中，我们可以做一些工作达到预防慢 SQL 问题，比如在上线前预先用诊断工具对 SQL 进行分析。常用的工具有：</p></blockquote><pre><code>mysqldumpslowmysql profilemysql explain</code></pre><p>具体使用及分析方法在此就不赘述，网上有丰富的资源可以参考。</p><blockquote><p>误操作、程序 bug 时怎么办</p></blockquote><pre><code>提出这个问题显然主要是针对刚开始工作的年轻同行们……实际上误操作和程序 bug 导致数据误删或者混乱的问题并非少见但是刚入行的开发工作者会比较紧张。一个成熟的企业往往会有完善的数据管理规范和较丰富的数据恢复方案（初创公司除外）会进行数据备份和数据容灾。当你发现误操作或程序 bug 导致线上数据被误删或误改动时，一定不能慌乱，应及时与 DBA 联系第一时间进行数据恢复（严重时直接停止服务），尽可能减少影响和损失。对于重要数据（如资金）的操作，在开发时一定要反复进行测试，确保没有问题后再上线。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;慢SQL问题&quot;&gt;&lt;a href=&quot;#慢SQL问题&quot; class=&quot;headerlink&quot; title=&quot;慢SQL问题&quot;&gt;&lt;/a&gt;慢SQL问题&lt;/h3&gt;&lt;p&gt;导致慢 SQL 的原因：&lt;br&gt;在遇到慢 SQL 情况时，不能简单的把原因归结为 SQL 编写问题(虽然这是最常见的因素)&lt;br&gt;实际上导致慢 SQL 有很多因素，甚至包括硬件和 mysql 本身的 bug。根据出现的概率从大到小，罗列如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-字符移位问题</title>
    <link href="http://yoursite.com/2019/03/20/%E5%AD%97%E7%AC%A6%E7%A7%BB%E4%BD%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/20/字符移位问题/</id>
    <published>2019-03-20T09:12:41.000Z</published>
    <updated>2019-06-03T07:53:19.236Z</updated>
    
    <content type="html"><![CDATA[<p>有一个由小写字母组成的字符串 S，和一个整数数组 shifts。我们将字母表中的下一个字母称为原字母的 移位（由于字母表是环绕的， ‘z’ 将会变成 ‘a’）。例如·，shift(‘a’) = ‘b’， shift(‘t’) = ‘u’,， 以及 shift(‘z’) = ‘a’。对于每个 shifts[i] = x ， 我们会将 S 中的前 i+1 个字母移位 x 次。返回将所有这些移位都应用到 S 后最终得到的字符串。<br><a id="more"></a></p><h3 id="字符移位问题-leetcode-843"><a href="#字符移位问题-leetcode-843" class="headerlink" title="字符移位问题 leetcode 843"></a>字符移位问题 leetcode 843</h3><pre><code>/*** 字符移位问题 leetcode 843* 有一个由小写字母组成的字符串 S，和一个整数数组 shifts。* 我们将字母表中的下一个字母称为原字母的 移位（由于字母表是环绕的， &apos;z&apos; 将会变成 &apos;a&apos;）。* 例如·，shift(&apos;a&apos;) = &apos;b&apos;， shift(&apos;t&apos;) = &apos;u&apos;,， 以及 shift(&apos;z&apos;) = &apos;a&apos;。* 对于每个 shifts[i] = x ， 我们会将 S 中的前 i+1 个字母移位 x 次。* 返回将所有这些移位都应用到 S 后最终得到的字符串。** 示例：* 输入：S = &quot;abc&quot;, shifts = [3,5,9]* 输出：&quot;rpl&quot;* 解释：* 我们以 &quot;abc&quot; 开始。* 将 S 中的第 1 个字母移位 3 次后，我们得到 &quot;dbc&quot;。* 再将 S 中的前 2 个字母移位 5 次后，我们得到 &quot;igc&quot;。* 最后将 S 中的这 3 个字母移位 9 次后，我们得到答案 &quot;rpl&quot;。*/</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class shiftingLetters &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 方法一：不推荐，但好理解</span><br><span class="line">     * @author yiming.liang</span><br><span class="line">     * @date 2019/3/20 15:33</span><br><span class="line">     * @param [S, shifts]</span><br><span class="line">     * @return java.lang.String</span><br><span class="line">     */</span><br><span class="line">        public static String shiftingLetter(String S, int[] shifts) &#123;</span><br><span class="line">            //目的为了拼字符串的</span><br><span class="line">            StringBuffer sb = new StringBuffer();</span><br><span class="line">            char c = 0;</span><br><span class="line">            for(int i = shifts.length-2;i&gt;=0;i--)&#123;</span><br><span class="line">                //从后往前算应该向后走几步,因为题目中说第二个走，第一个也走，第三个走，前两个也走</span><br><span class="line">                //所以最后一个走的是最少的，只走一步，而第一个走的最多，是后几个步数的和</span><br><span class="line">                //这样就比较好理解，我们直接从倒数第二个字母开始，将他和最后一人走的加起来，算出倒数第二个字母走的步数</span><br><span class="line">                //之后依次累加即可</span><br><span class="line">                shifts[i] += shifts[i+1]%26;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 0; i &lt; S.length(); i++) &#123;</span><br><span class="line">//                c = (char)(c.charAt(i) - &apos;a&apos; + shift) % 26 + &apos;a&apos;);</span><br><span class="line">                //这里分情况，上面那个是最好的方式但难理解，下面那个是好理解但麻烦</span><br><span class="line">                //下面这边分两种情况，第一钟是字母向后走但不超过z 直接加即可</span><br><span class="line">                c = (char)(S.charAt(i) + shifts[i]%26);</span><br><span class="line">                //如果超了z即122，这里拿一个栗子来说明,用例中&quot;ruu&quot;，&#123;26,9,17&#125;;</span><br><span class="line">                //u要向后走17步，而u的ascii码为117，走17步明显超过了z则判断是否大于122</span><br><span class="line">                //如果大于122，则算出大了多少，17+117-122 = 12则我们从u开始还要向后走5步到z</span><br><span class="line">                //再返回去走12步，这时我们是从z开始走的，则a也要被算在内，而我们后面的+&apos;a&apos;则代表着从a开始走</span><br><span class="line">                //显然a也被算在这12步内了，所以要-1再+&apos;a&apos;</span><br><span class="line">                //over</span><br><span class="line">                if(c&gt;122)&#123;</span><br><span class="line">                    c = (char) ((c-122)-1 + &apos;a&apos;);</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 方法二:推荐</span><br><span class="line">         * @author yiming.liang</span><br><span class="line">         * @date 2019/3/20 16:45</span><br><span class="line">         * @param [S, shifts]</span><br><span class="line">         * @return java.lang.String</span><br><span class="line">         */</span><br><span class="line">        public String shiftingLetter2(String S, int[] shifts) &#123;</span><br><span class="line">            char[] arr = S.toCharArray();</span><br><span class="line">            int shift = 0;</span><br><span class="line">            for (int i = arr.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                shift = (shift + shifts[i]) % 26;</span><br><span class="line">                arr[i] = (char)((arr[i] - &apos;a&apos; + shift) % 26 + &apos;a&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            return new String(arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//            char i = &apos;a&apos;+1;</span><br><span class="line">        int[] shifts = &#123;26,9,17&#125;;</span><br><span class="line">        String str = shiftingLetter(&quot;ruu&quot;,shifts);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个由小写字母组成的字符串 S，和一个整数数组 shifts。我们将字母表中的下一个字母称为原字母的 移位（由于字母表是环绕的， ‘z’ 将会变成 ‘a’）。例如·，shift(‘a’) = ‘b’， shift(‘t’) = ‘u’,， 以及 shift(‘z’) = ‘a’。对于每个 shifts[i] = x ， 我们会将 S 中的前 i+1 个字母移位 x 次。返回将所有这些移位都应用到 S 后最终得到的字符串。&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1013:总持续时间可被60整除的歌曲</title>
    <link href="http://yoursite.com/2019/03/20/leetcode-1013-%E6%80%BB%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E5%8F%AF%E8%A2%AB-60-%E6%95%B4%E9%99%A4%E7%9A%84%E6%AD%8C%E6%9B%B2/"/>
    <id>http://yoursite.com/2019/03/20/leetcode-1013-总持续时间可被-60-整除的歌曲/</id>
    <published>2019-03-20T07:03:42.000Z</published>
    <updated>2019-06-03T07:52:42.723Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode-1013-总持续时间可被-60-整除的歌曲"><a href="#leetcode-1013-总持续时间可被-60-整除的歌曲" class="headerlink" title="leetcode 1013:总持续时间可被 60 整除的歌曲"></a>leetcode 1013:总持续时间可被 60 整除的歌曲</h3><blockquote><p>在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。<br>返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字  i &lt; j 且有 (time[i] + time[j]) % 60 == 0。</p></blockquote><pre><code>示例 1：输入：[30,20,150,100,40]输出：3解释：这三对的总持续时间可被 60 整数：(time[0] = 30, time[2] = 150): 总持续时间 180(time[1] = 20, time[3] = 100): 总持续时间 120(time[1] = 20, time[4] = 40): 总持续时间 60示例 2：输入：[60,60,60]输出：3解释：所有三对的总持续时间都是 120，可以被 60 整数。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法1：时间复杂度O(n^2)，效率奇低</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int numPairsDivisibleBy60(int[] time) &#123;</span><br><span class="line">        int resutl = 0;</span><br><span class="line">        for(int i = 0;i&lt;time.length-1;i++)&#123;</span><br><span class="line">            for (int j = i+1; j &lt; time.length; j++) &#123;</span><br><span class="line">                if(time[i]+time[j]%60==0)&#123;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">方法2：</span><br><span class="line">    利用数组，将每个数对60取模后的值当作新数组的下标，并记录次数</span><br><span class="line">    接着遇到连续多个都能整出60的数，则此时 arr[0]的值应该会++多次</span><br><span class="line">    若arr[0]=3 即有3个60，他们两两组合则可以组合的数量为(n(n-1))/2 result = (3*2)/2 = 3</span><br><span class="line">    同理，取mode后的值为30也是特殊情况，则组合的方法和0的一样，接着下面写就可以了</span><br><span class="line">    排除了特殊情况后，正常情况就是20  40,   10   50之类的相加为60的数，这些数2 2 组合直接乘就可以了</span><br><span class="line">    </span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int numPairsDivisibleBy60(int[] time) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int[] res = new int[60];</span><br><span class="line">        for(int i:time)&#123;</span><br><span class="line">            res[i%60]++;</span><br><span class="line">        &#125;</span><br><span class="line">        result += (res[0] * (res[0]-1))/2;</span><br><span class="line">        result += (res[30] * (res[30]-1))/2;</span><br><span class="line">        //正常情况，相加为60证明一定能被60整除</span><br><span class="line">        for(int i = 1;i&lt;30;i++)&#123;</span><br><span class="line">            result += (res[i] * res[60-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;leetcode-1013-总持续时间可被-60-整除的歌曲&quot;&gt;&lt;a href=&quot;#leetcode-1013-总持续时间可被-60-整除的歌曲&quot; class=&quot;headerlink&quot; title=&quot;leetcode 1013:总持续时间可被 60 整除的歌曲&quot;&gt;
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Kafka如何利用Zookeeper做负载均衡</title>
    <link href="http://yoursite.com/2019/03/20/Kafka%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Zookeeper%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2019/03/20/Kafka如何利用Zookeeper做负载均衡/</id>
    <published>2019-03-20T03:01:08.000Z</published>
    <updated>2019-03-20T03:02:07.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kafka与Zookeeper"><a href="#Kafka与Zookeeper" class="headerlink" title="Kafka与Zookeeper"></a>Kafka与Zookeeper</h3><ul><li><p>Kafka如何利用zookeeper做负载均衡</p><pre><code>Kafka使用zk的分布式协调服务，将生产者，消费者，消息储存（broker，用于存储信息，消息读写等）结合在一起。同时借助zk，kafka能够将生产者，消费者和broker在内的所有组件在无状态的条件下建立起生产者和消费者的订阅关系，实现生产者的负载均衡。</code></pre><ul><li><p>broker在zk中注册</p><p>  kafka的每个broker（相当于一个节点，相当于一个机器）在启动时，都会在zk中注册，告诉zk其brokerid，在整个的集群中，<code>broker.id/brokers/ids</code>，当节点失效时，zk就会删除该节点，就很方便的监控整个集群broker的变化，及时调整负载均衡。</p></li><li><p>topic在zk中注册</p><p>  在kafka中可以定义很多个topic，每个topic又被分为很多个分区。一般情况下，每个分区独立在存在一个broker上，所有的这些topic和broker的对应关系都有zk进行维护</p></li><li><p>consumer(消费者)在zk中注册</p><ul><li><p>注册新的消费者，当有新的消费者注册到zk中，zk会创建专用的节点来保存相关信息，路径<code>ls /consumers/{group_id}/  [ids,owners,offset]</code>，Ids:记录该消费分组有几个正在消费的消费者，Owmners：记录该消费分组消费的topic信息，Offset：记录topic每个分区中的每个offset</p></li><li><p>监听消费者分组中消费者的变化 ,监听/consumers/{group_id}/ids的子节点的变化，一旦发现消费者新增或者减少及时调整消费者的负载均衡。</p></li></ul></li></ul><hr><p>  转载<br>  作者：SmartBrain<br>  原文：<a href="https://blog.csdn.net/Peter_Changyb/article/details/81562855" target="_blank" rel="noopener">https://blog.csdn.net/Peter_Changyb/article/details/81562855</a> </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Kafka与Zookeeper&quot;&gt;&lt;a href=&quot;#Kafka与Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;Kafka与Zookeeper&quot;&gt;&lt;/a&gt;Kafka与Zookeeper&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Kafka如何利用
      
    
    </summary>
    
      <category term="kafka" scheme="http://yoursite.com/categories/kafka/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>maven之pom.xml中的元素解析</title>
    <link href="http://yoursite.com/2019/03/19/maven%E4%B9%8Bpom-xml%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/03/19/maven之pom-xml中的元素解析/</id>
    <published>2019-03-19T12:14:44.000Z</published>
    <updated>2019-04-12T06:03:32.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven-pom-xml-中元素解析"><a href="#Maven-pom-xml-中元素解析" class="headerlink" title="Maven-pom.xml-中元素解析"></a>Maven-pom.xml-中元素解析</h2><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><pre><code>模块用处：项目规模比较大，模块较为复杂，目的是为了聚合，一次性构建全部模块</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码：</span><br><span class="line">&lt;modules&gt;</span><br><span class="line">　　　 &lt;!-- 模块都写在此处 --&gt;</span><br><span class="line">      &lt;module&gt;admin-register&lt;/module&gt;</span><br><span class="line">      &lt;module&gt;admin-login&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure><h3 id="dependencyManagement"><a href="#dependencyManagement" class="headerlink" title="dependencyManagement"></a>dependencyManagement</h3><pre><code>依赖管理用处：管理maven依赖</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代码：</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.yixue.sms&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;sms-dubbo-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><pre><code>继承用处：类似与java中的继承，如果每个子模块都用了相同的依赖包，则配置父模块，子模块继承父模块则代表继承了父模块的依赖包</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">代码：</span><br><span class="line">父：</span><br><span class="line"></span><br><span class="line">&lt;modules&gt;</span><br><span class="line">　　　 &lt;!-- 模块都写在此处 --&gt;</span><br><span class="line">      &lt;module&gt;admin-register&lt;/module&gt;</span><br><span class="line">      &lt;module&gt;admin-login&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt; &lt;!-- 配置共有依赖 --&gt;</span><br><span class="line">    &lt;!-- spring 依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">子：</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.admin.user&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;admin-login&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; </span><br><span class="line">    &lt;!-- 与不配置一样，默认就是寻找上级目录下得pom.xml --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;!-- 配置自己独有依赖 --&gt;</span><br><span class="line">&lt;dependencies&gt;   </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.mail&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mail&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.4.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.icegreen&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;greenmail&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.4.1&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><pre><code>假设将来需要添加一个新的子模块admin-util，该模块只是提供一些简单的帮助工具，不需要依赖spring那么我们可以用dependencyManagement既能让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活性在dependencyManagement元素下得依赖声明不会引入实际的依赖，不过它能够约束dependencies下的依赖使用父POM使用dependencyManagement能够统一项目范围中依赖的版本当依赖版本在父POM中声明后，子模块在使用依赖的时候就无须声明版本，也就不会发生多个子模块使用版本不一致的情况，帮助降低依赖冲突的几率</code></pre><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><pre><code>自定义一个或者多个Maven属性，然后再POM的其他地方使用${属性名}的方式引用该属性作用：消除重复，统一管理</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;!-- 定义 spring版本号 --&gt;</span><br><span class="line">    &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt;</span><br><span class="line">    &lt;junit.version&gt;4.7&lt;/junit.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">这里我记录了一些pom的属性：</span><br><span class="line"></span><br><span class="line">用户可以使用该类属性引用POM文件中对应元素的值。如：</span><br><span class="line"></span><br><span class="line">       $&#123;project.artifactId&#125;就对应了&lt;project&gt; &lt;artifactId&gt;元素的值，常用的POM属性包括：</span><br><span class="line"></span><br><span class="line">　　　　$&#123;project.build.sourceDirectory&#125;:项目的主源码目录，默认为src/main/java/</span><br><span class="line"></span><br><span class="line">　　　　$&#123;project.build.testSourceDirectory&#125;:项目的测试源码目录，默认为src/test/java/</span><br><span class="line"></span><br><span class="line">       $&#123;project.build.sourceEncoding&#125;表示主源码的编码格式;</span><br><span class="line"></span><br><span class="line">　　　　$&#123;project.build.directory&#125; ： 项目构建输出目录，默认为target/</span><br><span class="line"></span><br><span class="line">　　　　$&#123;project.outputDirectory&#125; : 项目主代码编译输出目录，默认为target/classes/</span><br><span class="line"></span><br><span class="line">　　　　$&#123;project.testOutputDirectory&#125;：项目测试主代码输出目录，默认为target/testclasses/</span><br><span class="line"></span><br><span class="line">　　　　$&#123;project.groupId&#125;：项目的groupId</span><br><span class="line"></span><br><span class="line">　　　　$&#123;project.artifactId&#125;：项目的artifactId</span><br><span class="line"></span><br><span class="line">　　　　$&#123;project.version&#125;：项目的version,与$&#123;version&#125; 等价</span><br><span class="line"></span><br><span class="line">　　　　$&#123;project.build.finalName&#125;：项目打包输出文件的名称，默认为$&#123;project.artifactId&#125;-$&#123;project.version&#125;</span><br></pre></td></tr></table></figure><h3 id="Exclusions"><a href="#Exclusions" class="headerlink" title="Exclusions"></a>Exclusions</h3><pre><code>排除依赖用法：来排除一些不需要同时下载的依赖jar举例：B项目中需要导入A项目的Maven依赖，通过依赖传递，会将A中的Jar包传递进来，如果B中不需要A中的某个jar包就可以使用exclusions标签</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用法：</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; </span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; </span><br><span class="line">    &lt;exclusions&gt; </span><br><span class="line">        &lt;exclusion&gt; </span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; </span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt; </span><br><span class="line">        &lt;/exclusion&gt; </span><br><span class="line">    &lt;/exclusions&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="环境变量属性"><a href="#环境变量属性" class="headerlink" title="环境变量属性"></a>环境变量属性</h3><pre><code>所有环境变量属性都可以使用以env. 开头的Maven属性引用，如${env.JAVA_HOME}指代了JAVA_HOME环境变量的的值beta:软件的验收测试如果配置了&lt;env&gt;beta&lt;/env&gt;${env} = beta</code></pre><h3 id="内置属性"><a href="#内置属性" class="headerlink" title="内置属性"></a>内置属性</h3><pre><code>(Maven预定义,用户可以直接使用)${basedir}表示项目根目录,即包含pom.xml文件的目录;${version}表示项目版本;${project.basedir}同${basedir};${project.baseUri}表示项目文件地址;${maven.build.timestamp}表示项目构件开始时间;${maven.build.timestamp.format}表示属性${maven.build.timestamp}的展示格式,默认值为yyyyMMdd-HHmm,可自定义其格式,其类型可参考java.text.SimpleDateFormat。用法如下：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;maven.build.timestamp.format&gt;yyyy-MM-dd HH:mm:ss&lt;/maven.build.timestamp.format&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><pre><code>在Maven的pom.xml文件中，存在如下两种&lt;build&gt;：（1）全局配置（project build）        针对整个项目的所有情况都有效（2）配置（profile build）        针对不同的profile配置共用的基本build元素:defaultGoal，执行构建时默认的goal或phase，如jar:jar或者package等directory，构建的结果所在的路径，默认为${basedir}/target目录finalName，构建的最终结果的名字，该名字可能在其他plugin中被改变&lt;build&gt;    &lt;filters&gt;        &lt;filter&gt;../config/filters-${env}.properties&lt;/filter&gt;    &lt;/filters&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources/&lt;/directory&gt;            &lt;excludes&gt;                &lt;exclude&gt;test/*&lt;/exclude&gt;                &lt;exclude&gt;beta/*&lt;/exclude&gt;                &lt;exclude&gt;online/*&lt;/exclude&gt;            &lt;/excludes&gt;            &lt;!-- 是否使用过滤器 --&gt;            &lt;filtering&gt;true&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources/${profiles.active}&lt;/directory&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;resources，build过程中涉及的资源文件targetPath，资源文件的目标路径filtering，构建过程中是否对资源进行过滤，默认falsedirectory，资源文件的路径，默认位于${basedir}/src/main/resources/目录下includes，一组文件名的匹配模式，被匹配的资源文件将被构建过程处理excludes，一组文件名的匹配模式，被匹配的资源文件将被构建过程忽略。同时被includes和excludes匹配的资源文件，将被忽略。filters，给出对资源文件进行过滤的属性文件的路径，默认位于${basedir}/src/main/filters/目录下。属性文件中定义若干键值对。在构建过程中，对于资源文件中出现的变量（键），将使用属性文件中该键对应的值替换。testResources，test过程中涉及的资源文件，默认位于${basedir}/src/test/resources/目录下。这里的资源文件不会被构建到目标构件中</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Maven-pom-xml-中元素解析&quot;&gt;&lt;a href=&quot;#Maven-pom-xml-中元素解析&quot; class=&quot;headerlink&quot; title=&quot;Maven-pom.xml-中元素解析&quot;&gt;&lt;/a&gt;Maven-pom.xml-中元素解析&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="maven" scheme="http://yoursite.com/categories/maven/"/>
    
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
</feed>

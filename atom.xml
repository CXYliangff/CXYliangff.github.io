<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YMLiang</title>
  <icon>https://www.gravatar.com/avatar/949b3d2d55d796bff0595b9b4a58fdde</icon>
  <subtitle>Never forget why you started</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ymliang.com/"/>
  <updated>2020-04-24T06:18:01.355Z</updated>
  <id>http://ymliang.com/</id>
  
  <author>
    <name>YMLiang</name>
    <email>18135479521@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac电脑Item2当XShell使用</title>
    <link href="http://ymliang.com/Mac%E7%94%B5%E8%84%91Item2%E5%BD%93XShell%E4%BD%BF%E7%94%A8.html"/>
    <id>http://ymliang.com/Mac电脑Item2当XShell使用.html</id>
    <published>2020-04-24T06:03:30.000Z</published>
    <updated>2020-04-24T06:18:01.355Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在mac系统中优雅的将控制台item2当作windows-XShell使用"><a href="#在mac系统中优雅的将控制台item2当作windows-XShell使用" class="headerlink" title="在mac系统中优雅的将控制台item2当作windows-XShell使用"></a>在mac系统中优雅的将控制台item2当作windows-XShell使用</h3><pre><code>windows工作环境下，连接服务器很方便的使用xshell就可以，比较方便，傻瓜式操作但再macOs操作系统下需要下载软件，当然软件也有，但macOs自带的控制台软件就可以，而且还比较方便，来说下步骤</code></pre><ul><li><p>第一步是要先建立密码文件：sshpass {这是个目录}下的文件，用公司系统名字命名，方便查找<br>目录：/Users/你的苹果电脑登录用户名(我的是abc)/Downloads/sshpass 不会找的去百度一下苹果电脑Downloads文件夹怎么在控制台找到,你下载的文件，视频等都在这个文件夹下</p></li><li><p>第二步<br>vim 文件名(你自己起)<br>示例： vim password</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123456</span><br></pre></td></tr></table></figure><p> :wq   输入密码后保存</p></li><li><p>第三步<br>打开item2的设置<br>ietm2 打开 Preferences 的快捷键 command + 逗号<br>需要改的地方就两处，一是Name，二是Command<br>Name起个名字方便用的时候好找，Command是执行的命令<br><img src="/images/mac/item2.png" alt="item2设置"><br>执行的命令如下：<br><code>/usr/local/bin/sshpass -f /Users/abc/Downloads/sshpass/password ssh -p22 supdev@ip地址</code></p></li></ul><pre><code>​/usr/local/bin/sshpass是sshpass执行文件的路径，默认情况安装现在这个位置上sshpass下载:brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb-f是告诉sshpass加载文件/Users/abc/Downloads/sshpass/password 就是要加载的的密码文件​ssh -p22 supdev@ip地址  意思是用ssh链接，端口22，用户名和IP地址</code></pre><p>保存后，第一次先通过终端运行ssh 用户名@ip，登录成功后再选择该profile，就可以实现ssh登录(如果配置了密码文件，就是刚刚讲的password文件)那么第二次开始到以后都不需要输密码了<br>第一次使用命令：ssh supdev@ip  登录服务器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在mac系统中优雅的将控制台item2当作windows-XShell使用&quot;&gt;&lt;a href=&quot;#在mac系统中优雅的将控制台item2当作windows-XShell使用&quot; class=&quot;headerlink&quot; title=&quot;在mac系统中优雅的将控制台item
      
    
    </summary>
    
      <category term="XShell" scheme="http://ymliang.com/categories/XShell/"/>
    
    
      <category term="XShell" scheme="http://ymliang.com/tags/XShell/"/>
    
  </entry>
  
  <entry>
    <title>React脚手架创建项目异常[npm ERR! code ENOLOCAL]</title>
    <link href="http://ymliang.com/React%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%BC%82%E5%B8%B8-npm-ERR-code-ENOLOCAL.html"/>
    <id>http://ymliang.com/React脚手架创建项目异常-npm-ERR-code-ENOLOCAL.html</id>
    <published>2020-04-14T06:41:44.000Z</published>
    <updated>2020-04-14T06:50:13.969Z</updated>
    
    <content type="html"><![CDATA[<p>npm ERR! code ENOLOCAL<br>npm ERR! Could not install from “Files\nodejs\node_cache_npx\21364” as it does not contain a package.json file.</p><p>npm ERR! A complete log of this run can be found in:<br>npm ERR!     C:\Program Files\nodejs\node_cache_logs\2020-04-02T08_18_09_189Z-debug.log<br>Install for create-react-app@latest failed with code 1<br><a id="more"></a></p><p>解决：</p><pre><code>“更换node cache 路径”在项目目录下面运行：npm config set cache &quot;C:\Users\登录windows的用户名\AppData\Roaming\npm-cache&quot;--global切记目录和“--global”之间没有空格。</code></pre><ul><li>还有再使用npm install的时候,react会重新下载并更新需要的包,路径在当前文件夹下的node_modules</li><li>有的同学再使用的时候会提示上面的问题，或者操作不允许，网上会有教程说让使用管理员方式运行，这种回答都是杯水车薪，治标不治本的，我们要一步到位，使用上面的方法即可</li></ul><p><img src="/images/react/reactError01.png" alt="reactError"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm ERR! code ENOLOCAL&lt;br&gt;npm ERR! Could not install from “Files\nodejs\node_cache_npx\21364” as it does not contain a package.json file.&lt;/p&gt;
&lt;p&gt;npm ERR! A complete log of this run can be found in:&lt;br&gt;npm ERR!     C:\Program Files\nodejs\node_cache_logs\2020-04-02T08_18_09_189Z-debug.log&lt;br&gt;Install for create-react-app@latest failed with code 1&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://ymliang.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="http://ymliang.com/tags/React/"/>
    
      <category term="前端" scheme="http://ymliang.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>组装电脑：你不知道的事儿</title>
    <link href="http://ymliang.com/%E7%BB%84%E8%A3%85%E7%94%B5%E8%84%91%EF%BC%9A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E5%84%BF.html"/>
    <id>http://ymliang.com/组装电脑：你不知道的事儿.html</id>
    <published>2019-12-03T10:03:48.000Z</published>
    <updated>2019-12-05T11:07:26.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="电脑组装从零到一"><a href="#电脑组装从零到一" class="headerlink" title="电脑组装从零到一"></a>电脑组装从零到一</h3><pre><code>10月份自己组装了一个台式机，配置还可以，所以抽空把再装机中遇到的一些坑和学习到的一些硬件只是做了一张导图，分享给大家其实组装电脑没有想象中的难，只有0次和无数次的区别，为什么要组装而不买套机？其实是你和它的关系，如果是朋友，你会去培养，如果是雇佣，你不会花费太多心思，所以很多钱就让电脑城的人和淘宝卖家挣去了我粗略的估算了一下，刨去人工费和不知道几环套几环的硬件代理费，一台电脑的利润成本大概再2000左右，当然这个价格只是站在配件都是全新的基础上，如果想追求便宜高配可以去闲鱼捡捡垃圾，性价比会非常高</code></pre><p><img src="/images/buildComputer/buildComputer.png" alt="电脑组装"></p><h3 id="超频失败，电脑黑屏怎么办"><a href="#超频失败，电脑黑屏怎么办" class="headerlink" title="超频失败，电脑黑屏怎么办"></a>超频失败，电脑黑屏怎么办</h3><pre><code>2019.12.02 晚上因为手贱超频导致电脑黑屏无法开机，记得主板上的显示屏数字写着95（不知道啥意思，可能是就不的谐音）之后就开始查来查去，找到了我主板最有效的方法（Msi X399）1.可以扣电池，电池很隐蔽，在左上角的板下面藏着，基本上找不到2.CMOS重置，说明书上写着找跳线帽插上去5-10秒可以恢复BIOS3.X399 主板后置面板处有一键reset的按钮，点击即可恢复初始设置（我感觉像是恢复到上一次调整后，把不符合要求的设置调整到最佳状态）  因为我是设置锐龙自带的CPU设置软件 AMD Ryzen Master，先调整了cpu频率单核3700-&gt;3800，内存频率从1467 - 2200（这个地方是大坑）  DDR4内存是双通道，频率都是2倍的关系，所以，在你任务管理器看见的是X2 以后的频率，但是专业一点的软件会 %2 所以我当时就以为我3000MHZ的频率  为什么才给我1465，很纳闷所以就调成2200MHZ，之后就开不了机了  X399主板的重置BIOS在主板后面，有个按钮，很明显（这可能就是至尊平台的牛逼之处吧），虽然我找了一个小时的电池，和CMOS双针脚插口，然后我还没找到跳线帽，惭愧惭愧</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;电脑组装从零到一&quot;&gt;&lt;a href=&quot;#电脑组装从零到一&quot; class=&quot;headerlink&quot; title=&quot;电脑组装从零到一&quot;&gt;&lt;/a&gt;电脑组装从零到一&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;10月份自己组装了一个台式机，配置还可以，所以抽空把再装机中遇到的一些坑和学
      
    
    </summary>
    
      <category term="电脑组装" scheme="http://ymliang.com/categories/%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85/"/>
    
    
      <category term="电脑组装" scheme="http://ymliang.com/tags/%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Golang实现日志收集功能</title>
    <link href="http://ymliang.com/Golang%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E5%8A%9F%E8%83%BD.html"/>
    <id>http://ymliang.com/Golang实现日志收集功能.html</id>
    <published>2019-09-09T07:40:39.000Z</published>
    <updated>2019-09-09T07:40:39.271Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go爬虫(持续更新)</title>
    <link href="http://ymliang.com/Go%E7%88%AC%E8%99%AB.html"/>
    <id>http://ymliang.com/Go爬虫.html</id>
    <published>2019-07-26T13:21:30.000Z</published>
    <updated>2019-09-09T10:00:29.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前学习了一段时间go之后想写一点小的项目，上网查询了一些资料，做了一些小的demo，今天将我最近写的小项目分享给大家：利用go实现单任务版爬虫和并发爬虫，因为go对并发支持的很好，所以我们只需要提前将goroutine和channl学好，就很好理解了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">项目结构：</span><br><span class="line">1.带有简单的日志收集，打印的日志写到/logs目录下，可配置写到文件中还是输出到控制台，或者都输出</span><br><span class="line">2.简单的正则匹配，上下文控制超时，chan控制并发数量，goroutine并发下载等知识点</span><br><span class="line">3.简单的乱码处理，简单的随机数处理，图片下载，图片名称替换等</span><br><span class="line">项目难度 ❤</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><p>regexp  api:</p><pre><code>re := regexp.MustCompile(reStr) ： reStr代表正则表达式 ，这个方法表示按照这个正则去匹配re.FindAllStringSubmatch(srcStr,-1)  ： -1表示所有全查到    （1或2或3表示取1个2个3个）</code></pre></li><li><p>一些常用的正则符号</p><pre><code>(） ： 标识分组\w : 字母数字下划线\d ： 数字\D ：字母\s\S ： 任意字符\s ： 空白字符(小写s)\S ： 非空白字符(大写S)re1 | re2 ： re1 或 re2 所表示的片段regexp*+?  | regexp+? 分别表示1到多次 | 或0到多次   ？表示非贪婪，也就是匹配到？后面的东西为止{n,m}  |  {n,}  表示 n个到m个 |  或至少是n个[\w\.] 表示出现任意字母数字下划线或者 . 都是ok的</code></pre></li></ul><ul><li><p>举例：</p><pre><code>[\s\S]+?href   这段正则中： [\s\S] 表示任意字符+ 表示 0个或1个？表示不会隔过 href</code></pre></li><li><p>正则案例</p><pre><code>这里以电话号为案例rePhone = `(1[3456789]\d)(\d.[a-z]{2,3})(\d{4})`匹配出是二维数组形式分四组，整体为第一组，有一个括号加1组</code></pre></li><li><p>快捷键</p><p>  Alt + Shift + M 变为函数形式<br>  Ctrl + Alt + L 格式化代码<br>  Ctrl + Alt + V 变量名补全</p></li></ul><ul><li>示例代码：爬虫获取html界面内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func GetHtml(url string) string &#123;</span><br><span class="line">//利用context来控制超时</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second*60)</span><br><span class="line">defer cancel()</span><br><span class="line"></span><br><span class="line">var html string</span><br><span class="line">//建立一个channel</span><br><span class="line">done := make(chan int, 1)</span><br><span class="line">go func() &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">logs.Info(&quot;http get failed, err = &quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">defer resp.Body.Close()</span><br><span class="line"></span><br><span class="line">bytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">html = string(bytes)</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">//向channel里面放数字（相当于一个占位符，没什么具体含义，代表这个channel里面有东西）</span><br><span class="line">done &lt;- 1</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">//如果done 这个 channel里面有元素，则代表爬取页面成功</span><br><span class="line">case &lt;-done:</span><br><span class="line">fmt.Println(&quot;work done on time&quot;)</span><br><span class="line">return html</span><br><span class="line">//如果 context : ctx 超时，则爬取失败 ctx.Done()代表超时</span><br><span class="line">case &lt;-ctx.Done():</span><br><span class="line">// timeout</span><br><span class="line">fmt.Println(&quot;爬取超时：err= &quot;, ctx.Err())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return html</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>项目结构</li></ul><p><img src="/images/GO爬虫/项目结构.png" alt="项目结构"></p><ul><li>源代码</li></ul><p>完整代码可以fork 我的github : </p><p>main.go<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">&quot;crawler/config&quot;</span><br><span class="line">&quot;crawler/log&quot;</span><br><span class="line">&quot;crawler/utils&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;github.com/astaxie/beego/logs&quot;</span><br><span class="line">&quot;io/ioutil&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;regexp&quot;</span><br><span class="line">&quot;strings&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//爬取的一些正则</span><br><span class="line">var (</span><br><span class="line">//分四组，整体为第一组，有一个括号加1组</span><br><span class="line">rePhone = `(1[3456789]\d)(\d.[a-z]&#123;2,3&#125;)(\d&#123;4&#125;)`</span><br><span class="line">//reEmail = `[1-9]\d&#123;4,&#125;@qq.com`</span><br><span class="line">//  \w : 字母数字下划线</span><br><span class="line">reEmail = `\w+@\w+\.[a-z]&#123;2,3&#125;`</span><br><span class="line">/**爬取超链接*/</span><br><span class="line">reLink = `&lt;a[\s\S]+?href=&quot;(http[\s\S]+?)&quot;`</span><br><span class="line">/**爬取网站 图片*/</span><br><span class="line">rePic = `&lt;img[\s\S]+?src=&quot;(http[\s\S]+?)&quot;`</span><br><span class="line">/**爬取标题*/</span><br><span class="line">reTitle = `&lt;a[\s\S]+?title=&quot;([\s\S]+?)&quot;`</span><br><span class="line">/*爬取图片名称*/</span><br><span class="line">reName = `&lt;img[\s\S]+?alt=&quot;([\s\S]+?)&quot;`</span><br><span class="line">/**爬取图片url和图片alt名称*/</span><br><span class="line">rePicAlt = `&lt;img.+?src=&quot;(http.+?)&quot;.+?alt=&quot;(.+?)&quot;.*?&gt;`</span><br><span class="line">/**Alt正则*/</span><br><span class="line">reAlt = `alt=&quot;(.+?)&quot;`</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">定义一些全局变量</span><br><span class="line"> */</span><br><span class="line">var (</span><br><span class="line">pushChan sync.WaitGroup</span><br><span class="line">wg       sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">//加载日志配置</span><br><span class="line">fileName := &quot;./conf/config.conf&quot;</span><br><span class="line">err := config.LoadConf(&quot;ini&quot;, fileName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">logs.Error(&quot;LoadConf filed,err = &quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = log.InitLogger(config.Conf.LogPath, config.Conf.LogLevel)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;load conf error&quot;)</span><br><span class="line">panic(&quot;load conf failed&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url := &quot;https://www.163.com/&quot;</span><br><span class="line">//url := GetHtml(&quot;https://tieba.baidu.com/p/6118291659?pid=126751186930&amp;cid=0&amp;red_tag=1970653863#126751186930&quot;)</span><br><span class="line">//url := GetHtml(&quot;https://www.766ju.com/&quot;)</span><br><span class="line">//url := &quot;https://www.766ju.com/vod/html2/20124.html&quot;</span><br><span class="line"></span><br><span class="line">fmt.Println(time.Now(),&quot;:图片爬取开始！&quot;)</span><br><span class="line"></span><br><span class="line">/**----------------------下载图片-------------------*/</span><br><span class="line">//elems := GetUrls(url,reName)</span><br><span class="line">//elems := GetImgInfos(url, rePicAlt)</span><br><span class="line">//for _, str := range elems &#123;</span><br><span class="line">//fmt.Printf(&quot;Name = %s \n, url=  %s  \n&quot;, str[&quot;url&quot;], str[&quot;fileName&quot;])</span><br><span class="line">////异步下载图片</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line">//wg.Wait()</span><br><span class="line"></span><br><span class="line">pushChan.Add(1)</span><br><span class="line">go func(url, rePicAlt string) &#123;</span><br><span class="line">elem2Chan(url, rePicAlt)</span><br><span class="line">pushChan.Done()</span><br><span class="line">&#125;(url, rePicAlt)</span><br><span class="line">pushChan.Wait()</span><br><span class="line"></span><br><span class="line">close(midChan)</span><br><span class="line"></span><br><span class="line">fmt.Println(time.Now(),&quot;图片爬取完毕！&quot;)</span><br><span class="line">/**----------------------下载图片-------------------*/</span><br><span class="line"></span><br><span class="line">/**----------------------从管道中读并下载-------------------*/</span><br><span class="line">fmt.Println(time.Now(),&quot;图片开始下载！&quot;)</span><br><span class="line">for elem := range midChan &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func(elem map[string]string) &#123;</span><br><span class="line">DownLoadPicAsync(elem[&quot;url&quot;], elem[&quot;fileName&quot;])</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(elem)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(time.Now(),&quot;图片下载完成！&quot;)</span><br><span class="line">/**----------------------从管道中读并下载-------------------*/</span><br><span class="line"></span><br><span class="line">/**----------------------打印信息-------------------*/</span><br><span class="line">//PrintInfo(url,reName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">建立中间管道，爬到的图片扔进管道中</span><br><span class="line">*/</span><br><span class="line">var (</span><br><span class="line">midChan = make(chan map[string]string, 80)</span><br><span class="line">picChan = make(chan int, 10) //信号量最多为10</span><br><span class="line">)</span><br><span class="line">//每个图片实例放入chan ： midChan中</span><br><span class="line">func elem2Chan(url, reg string) &#123;</span><br><span class="line">elem := GetImgInfos(url, reg)</span><br><span class="line">for _, str := range elem &#123;</span><br><span class="line">midChan &lt;- str</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">同步下载图片</span><br><span class="line">*/</span><br><span class="line">func DownLoadPic(url, subFileName string) &#123;</span><br><span class="line"></span><br><span class="line">resp, _ := http.Get(url)</span><br><span class="line">defer resp.Body.Close()</span><br><span class="line">imageBytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">fileName := &quot;&quot;</span><br><span class="line">if strings.Contains(url, &quot;gif&quot;) &#123;</span><br><span class="line">//fileName := `D:\goImg\imgs\` + strconv.Itoa(int(time.Now().UnixNano())) + &quot;.jpg&quot;</span><br><span class="line">//fileName := `D:\goImg\imgs\` + GetRandomName() + &quot;.jpg&quot;</span><br><span class="line">fileName = `D:\goImg\imgs\` + utils.ReplaceName(subFileName) + &quot;.jpg&quot;</span><br><span class="line">err := ioutil.WriteFile(fileName, imageBytes, 0644)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;下载失败,err = &quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//fileName := `D:\goImg\imgs\` + GetRandomName() + &quot;.jpg&quot;</span><br><span class="line">fileName = `D:\goImg\imgs\` + utils.ReplaceName(subFileName) + &quot;.jpg&quot;</span><br><span class="line">err := ioutil.WriteFile(fileName, imageBytes, 0644)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;下载失败,err = &quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;下载成功,fileName = &#123;%s&#125;\n&quot;, fileName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">异步下载图片</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">func DownLoadPicAsync(url, fileName string) &#123;</span><br><span class="line">picChan &lt;- 123</span><br><span class="line">DownLoadPic(url, fileName)</span><br><span class="line">&lt;-picChan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">获取爬取到的每张图片的url</span><br><span class="line">*/</span><br><span class="line">func GetUrls(url, reg string) []string &#123;</span><br><span class="line">html := GetHtml(url)</span><br><span class="line">//爬取逻辑</span><br><span class="line">re := regexp.MustCompile(reg)</span><br><span class="line">// -1 代表匹配全部 ,写数字机几就取几个</span><br><span class="line">allString := re.FindAllStringSubmatch(html, -1)</span><br><span class="line">fmt.Println(&quot;捕获图片张数:&quot;, len(allString))</span><br><span class="line">imgUrls := make([]string, 0)</span><br><span class="line">for _, str := range allString &#123;</span><br><span class="line">imgUrl := str[1]</span><br><span class="line">imgUrls = append(imgUrls, imgUrl)</span><br><span class="line">&#125;</span><br><span class="line">return imgUrls</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">获取img+alt信息 返回map 数组</span><br><span class="line">map&#123;key1:url value1:string ; key2:fileName value2:string&#125;</span><br><span class="line">*/</span><br><span class="line">func GetImgInfos(url, reg string) []map[string]string &#123;</span><br><span class="line">//爬取html网页</span><br><span class="line">html := GetHtml(url)</span><br><span class="line">//爬取正则</span><br><span class="line">re := regexp.MustCompile(reg)</span><br><span class="line">// -1 代表匹配全部 ,写数字机几就取几个</span><br><span class="line">allString := re.FindAllStringSubmatch(html, -1)</span><br><span class="line">fmt.Println(&quot;捕获图片张数:&quot;, len(allString))</span><br><span class="line">//新建一个map切片</span><br><span class="line">imgInfos := make([]map[string]string, 0)</span><br><span class="line">for _, str := range allString &#123;</span><br><span class="line">imgInfo := make(map[string]string, 0)</span><br><span class="line">imgUrl := str[1]</span><br><span class="line">imgInfo[&quot;url&quot;] = imgUrl</span><br><span class="line">imgInfo[&quot;fileName&quot;] = GetImgNameFromTags(str[0])</span><br><span class="line">imgInfos = append(imgInfos, imgInfo)</span><br><span class="line">&#125;</span><br><span class="line">return imgInfos</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">判断fileName是用alt命名还是随机数命名</span><br><span class="line">*/</span><br><span class="line">func GetImgNameFromTags(imgUrl string) string &#123;</span><br><span class="line">re := regexp.MustCompile(reAlt)</span><br><span class="line">res := re.FindAllStringSubmatch(imgUrl, -1)</span><br><span class="line">if len(res) &gt; 0 &#123;</span><br><span class="line">//res[0][1]取的是第 1行 第二列的元素 即alt标签中的中文命名</span><br><span class="line">return utils.GBK2UTF8(res[0][1])</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return utils.GetRandomName()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Alt + Shift + M 变为函数形式</span><br><span class="line">/**</span><br><span class="line">爬取html网页</span><br><span class="line">*/</span><br><span class="line">func GetHtml(url string) string &#123;</span><br><span class="line">//控制超时</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second*60)</span><br><span class="line">defer cancel()</span><br><span class="line">var html string</span><br><span class="line">done := make(chan int, 1)</span><br><span class="line">go func() &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">logs.Info(&quot;http get failed, err = &quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">defer resp.Body.Close()</span><br><span class="line"></span><br><span class="line">bytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">html = string(bytes)</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">done &lt;- 1</span><br><span class="line">&#125;()</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-done:</span><br><span class="line">fmt.Println(&quot;work done on time&quot;)</span><br><span class="line">return html</span><br><span class="line">case &lt;-ctx.Done():</span><br><span class="line">// timeout</span><br><span class="line">fmt.Println(&quot;爬取超时：err= &quot;, ctx.Err())</span><br><span class="line">&#125;</span><br><span class="line">return html</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前学习了一段时间go之后想写一点小的项目，上网查询了一些资料，做了一些小的demo，今天将我最近写的小项目分享给大家：利用go实现单任务版爬虫和并发爬虫，因为go对并发支持的很好，所以我们只需要提前将goroutine和channl学好，就很好理解了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;项目结构：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.带有简单的日志收集，打印的日志写到/logs目录下，可配置写到文件中还是输出到控制台，或者都输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.简单的正则匹配，上下文控制超时，chan控制并发数量，goroutine并发下载等知识点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.简单的乱码处理，简单的随机数处理，图片下载，图片名称替换等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项目难度 ❤&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="go" scheme="http://ymliang.com/categories/go/"/>
    
    
      <category term="go" scheme="http://ymliang.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>经济学词汇(持续更新)</title>
    <link href="http://ymliang.com/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%AF%8D%E6%B1%87.html"/>
    <id>http://ymliang.com/经济学词汇.html</id>
    <published>2019-06-21T02:07:02.000Z</published>
    <updated>2019-07-29T06:39:06.644Z</updated>
    
    <content type="html"><![CDATA[<p>###</p><p>名义GDP：名义GDP是指以现行市场价格计算的既定时期国内总产品和服务的价格总和。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###&lt;/p&gt;
&lt;p&gt;名义GDP：名义GDP是指以现行市场价格计算的既定时期国内总产品和服务的价格总和。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go开发进阶——6</title>
    <link href="http://ymliang.com/Go%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%946.html"/>
    <id>http://ymliang.com/Go开发进阶——6.html</id>
    <published>2019-06-11T10:10:59.000Z</published>
    <updated>2019-09-09T10:00:48.885Z</updated>
    
    <content type="html"><![CDATA[<p>本章来讲什么是并发，了解并发的意义才能会用它</p><p>首先了解进程和线程<br>进程是资源分配的最小单位，线程是程序执行的最小单位。<br>进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。<br>线程是进程的一个执行实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。<br>一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行。</p><p>并发和并行</p><p>并发的关键是你有处理多个任务的能力，不一定要同时。<br>并行的关键是你有同时处理多个任务的能力。<br>所以我认为它们最关键的点就是：是否是同时。</p><a id="more"></a><h3 id="goroutine的定义"><a href="#goroutine的定义" class="headerlink" title="goroutine的定义"></a>goroutine的定义</h3><p>任何函数只需加上go就能发送给调度器运行<br>不需要在定义时区分是否异步函数<br>调度器在合适的点进行切换</p><h3 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h3><p>channel 是 CSP 模式的具体实现，用于多个 goroutine 通讯。<br>其内部实现了同步，确保并发安全。多个goroutine同时访问，不需要加锁。</p><p>由于管道容量是5，开启go写入10个数据，再写入5个数据，会阻塞，然而read每秒会读取一个，然后在会写入一个数据。make(chan int,5)即给它一个5个大小的缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func write(ch chan int) &#123;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">fmt.Println(&quot;put data:&quot;, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func read(ch chan int) &#123;</span><br><span class="line">for &#123;</span><br><span class="line">var b int</span><br><span class="line">b = &lt;-ch</span><br><span class="line">fmt.Println(b)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">intChan := make(chan int, 5)</span><br><span class="line">go write(intChan)</span><br><span class="line">go read(intChan)</span><br><span class="line"></span><br><span class="line">time.Sleep(10 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p>Golang 在语言层面对并发编程提供支持，一种类似协程，称作 goroutine 的机制。</p><p>只需在函数调用语句前添加 go 关键字，就可创建并发执行单元。开发人员无需了解任何执行细节，调度器会自动将其安排到合适的系统线程上执行。goroutine 是一种非常轻量级的实现，可在单个进程里执行成千上万的并发任务。</p><p>WaitGroup有三个方法</p><p>Add:添加或者减少等待goroutine的数量</p><p>Done:相当于Add(-1)</p><p>Wait:执行阻塞，直到所有的WaitGroup数量变成0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func work(wg *sync.WaitGroup, i int) &#123;</span><br><span class="line">fmt.Println(&quot;work:&quot;, i)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go work(&amp;wg,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(&quot;goroutine finished&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="go-defer"><a href="#go-defer" class="headerlink" title="go defer()"></a>go defer()</h3><p>go defer (go延迟函数)<br>defer语句调用一个函数，这个函数执行会推迟，直到外围的函数返回，或者外围函数运行到最后，或者相应的goroutine panic</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>上下文管理<br>使用context保存上下文，比如你可以保存session,user_id,password到你的上下文中</p><p>ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)</p><p>ctx.Done()   //代表超时</p><p>适用于：任何请求的超时都可以用 ctx来控制</p><p>ctx也可以控制一个goroutine的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章来讲什么是并发，了解并发的意义才能会用它&lt;/p&gt;
&lt;p&gt;首先了解进程和线程&lt;br&gt;进程是资源分配的最小单位，线程是程序执行的最小单位。&lt;br&gt;进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。&lt;br&gt;线程是进程的一个执行实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。&lt;br&gt;一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行。&lt;/p&gt;
&lt;p&gt;并发和并行&lt;/p&gt;
&lt;p&gt;并发的关键是你有处理多个任务的能力，不一定要同时。&lt;br&gt;并行的关键是你有同时处理多个任务的能力。&lt;br&gt;所以我认为它们最关键的点就是：是否是同时。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://ymliang.com/categories/go/"/>
    
    
      <category term="go" scheme="http://ymliang.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go中一些常见包的使用(永不完结)</title>
    <link href="http://ymliang.com/Go%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8-%E6%B0%B8%E4%B8%8D%E5%AE%8C%E7%BB%93.html"/>
    <id>http://ymliang.com/Go中一些常见包的使用-永不完结.html</id>
    <published>2019-06-11T05:59:59.000Z</published>
    <updated>2019-09-09T10:01:35.905Z</updated>
    
    <content type="html"><![CDATA[<h3 id="regexp包"><a href="#regexp包" class="headerlink" title="regexp包"></a>regexp包</h3><pre><code>------------------------------------------------------------// 判断在 b 中能否找到正则表达式 pattern 所匹配的子串// pattern：要查找的正则表达式// b：要在其中进行查找的 []byte// matched：返回是否找到匹配项// err：返回查找过程中遇到的任何错误// 此函数通过调用 Regexp 的方法实现func Match(pattern string, b []byte) (matched bool, err error)func main() {    fmt.Println(regexp.Match(&quot;H.* &quot;, []byte(&quot;Hello World!&quot;)))    // true }------------------------------------------------------------</code></pre><a id="more"></a><pre><code>// 判断在 r 中能否找到正则表达式 pattern 所匹配的子串// pattern：要查找的正则表达式// r：要在其中进行查找的 RuneReader 接口// matched：返回是否找到匹配项// err：返回查找过程中遇到的任何错误// 此函数通过调用 Regexp 的方法实现func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)func main() {    r := bytes.NewReader([]byte(&quot;Hello World!&quot;))    fmt.Println(regexp.MatchReader(&quot;H.* &quot;, r))    // true }------------------------------------------------------------// 判断在 s 中能否找到正则表达式 pattern 所匹配的子串// pattern：要查找的正则表达式// r：要在其中进行查找的字符串// matched：返回是否找到匹配项// err：返回查找过程中遇到的任何错误// 此函数通过调用 Regexp 的方法实现func MatchString(pattern string, s string) (matched bool, err error)func main() {    fmt.Println(regexp.Match(&quot;H.* &quot;, &quot;Hello World!&quot;))    // true }------------------------------------------------------------// QuoteMeta 将字符串 s 中的“特殊字符”转换为其“转义格式”// 例如，QuoteMeta（`[foo]`）返回`\[foo\]`。// 特殊字符有：\.+*?()|[]{}^$// 这些字符用于实现正则语法，所以当作普通字符使用时需要转换func QuoteMeta(s string) stringfunc main() {    fmt.Println(regexp.QuoteMeta(&quot;(?P:Hello) [a-z]&quot;))    // \(\?P:Hello\) \[a-z\]}------------------------------------------------------------// Regexp 结构表示一个编译后的正则表达式// Regexp 的公开接口都是通过方法实现的// 多个 goroutine 并发使用一个 RegExp 是安全的type Regexp struct {    // 私有字段}// 通过 Complite、CompilePOSIX、MustCompile、MustCompilePOSIX // 四个函数可以创建一个 Regexp 对象------------------------------------------------------------// Compile 用来解析正则表达式 expr 是否合法，如果合法，则返回一个 Regexp 对象// Regexp 对象可以在任意文本上执行需要的操作func Compile(expr string) (*Regexp, error)func main() {    reg, err := regexp.Compile(`\w+`)    fmt.Printf(&quot;%q,%v\n&quot;, reg.FindString(&quot;Hello World!&quot;), err)    // &quot;Hello&quot;,}------------------------------------------------------------// CompilePOSIX 的作用和 Compile 一样// 不同的是，CompilePOSIX 使用 POSIX 语法，// 同时，它采用最左最长方式搜索，// 而 Compile 采用最左最短方式搜索// POSIX 语法不支持 Perl 的语法格式：\d、\D、\s、\S、\w、\Wfunc CompilePOSIX(expr string) (*Regexp, error)func main() {    reg, err := regexp.CompilePOSIX(`[[:word:]]+`)    fmt.Printf(&quot;%q,%v\n&quot;, reg.FindString(&quot;Hello World!&quot;), err)    // &quot;Hello&quot;}------------------------------------------------------------// MustCompile 的作用和 Compile 一样// 不同的是，当正则表达式 str 不合法时，MustCompile 会抛出异常// 而 Compile 仅返回一个 error 值func MustCompile(str string) *Regexpfunc main() {    reg := regexp.MustCompile(`\w+`)    fmt.Println(reg.FindString(&quot;Hello World!&quot;))    // Hello}------------------------------------------------------------// MustCompilePOSIX 的作用和 CompilePOSIX 一样// 不同的是，当正则表达式 str 不合法时，MustCompilePOSIX 会抛出异常// 而 CompilePOSIX 仅返回一个 error 值func MustCompilePOSIX(str string) *Regexpfunc main() {    reg := regexp.MustCompilePOSIX(`[[:word:]].+ `)    fmt.Printf(&quot;%q\n&quot;, reg.FindString(&quot;Hello World!&quot;))    // &quot;Hello &quot;}------------------------------------------------------------// 在 b 中查找 re 中编译好的正则表达式，并返回第一个匹配的内容func (re *Regexp) Find(b []byte) []bytefunc main() {    reg := regexp.MustCompile(`\w+`)    fmt.Printf(&quot;%q&quot;, reg.Find([]byte(&quot;Hello World!&quot;)))    // &quot;Hello&quot;}------------------------------------------------------------// 在 s 中查找 re 中编译好的正则表达式，并返回第一个匹配的内容func (re *Regexp) FindString(s string) stringfunc main() {    reg := regexp.MustCompile(`\w+`)    fmt.Println(reg.FindString(&quot;Hello World!&quot;))    // &quot;Hello&quot;}------------------------------------------------------------// 在 b 中查找 re 中编译好的正则表达式，并返回所有匹配的内容// {{匹配项}, {匹配项}, ...}// 只查找前 n 个匹配项，如果 n &lt; 0，则查找所有匹配项func (re *Regexp) FindAll(b []byte, n int) [][]bytefunc main() {    reg := regexp.MustCompile(`\w+`)    fmt.Printf(&quot;%q&quot;, reg.FindAll([]byte(&quot;Hello World!&quot;), -1))    // [&quot;Hello&quot; &quot;World&quot;]}------------------------------------------------------------// 在 s 中查找 re 中编译好的正则表达式，并返回所有匹配的内容// {匹配项, 匹配项, ...}// 只查找前 n 个匹配项，如果 n &lt; 0，则查找所有匹配项func (re *Regexp) FindAllString(s string, n int) []stringfunc main() {    reg := regexp.MustCompile(`\w+`)    fmt.Printf(&quot;%q&quot;, reg.FindAllString(&quot;Hello World!&quot;, -1))    // [&quot;Hello&quot; &quot;World&quot;]}------------------------------------------------------------// 在 b 中查找 re 中编译好的正则表达式，并返回第一个匹配的位置// {起始位置, 结束位置}func (re *Regexp) FindIndex(b []byte) (loc []int)func main() {    reg := regexp.MustCompile(`\w+`)    fmt.Println(reg.FindIndex([]byte(&quot;Hello World!&quot;)))    // [0 5]}------------------------------------------------------------// 在 s 中查找 re 中编译好的正则表达式，并返回第一个匹配的位置// {起始位置, 结束位置}func (re *Regexp) FindStringIndex(s string) (loc []int)func main() {    reg := regexp.MustCompile(`\w+`)    fmt.Println(reg.FindStringIndex(&quot;Hello World!&quot;))    // [0 5]}------------------------------------------------------------// 在 r 中查找 re 中编译好的正则表达式，并返回第一个匹配的位置// {起始位置, 结束位置}func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)func main() {    r := bytes.NewReader([]byte(&quot;Hello World!&quot;))    reg := regexp.MustCompile(`\w+`)    fmt.Println(reg.FindReaderIndex(r))    // [0 5]}------------------------------------------------------------// 在 b 中查找 re 中编译好的正则表达式，并返回所有匹配的位置// {{起始位置, 结束位置}, {起始位置, 结束位置}, ...}// 只查找前 n 个匹配项，如果 n &lt; 0，则查找所有匹配项func (re *Regexp) FindAllIndex(b []byte, n int) [][]intfunc main() {    reg := regexp.MustCompile(`\w+`)    fmt.Println(reg.FindAllIndex([]byte(&quot;Hello World!&quot;), -1))    // [[0 5] [6 11]]}------------------------------------------------------------// 在 s 中查找 re 中编译好的正则表达式，并返回所有匹配的位置// {{起始位置, 结束位置}, {起始位置, 结束位置}, ...}// 只查找前 n 个匹配项，如果 n &lt; 0，则查找所有匹配项func (re *Regexp) FindAllStringIndex(s string, n int) [][]intfunc main() {    reg := regexp.MustCompile(`\w+`)    fmt.Println(reg.FindAllStringIndex(&quot;Hello World!&quot;, -1))    // [[0 5] [6 11]]}------------------------------------------------------------// 在 b 中查找 re 中编译好的正则表达式，并返回第一个匹配的内容// 同时返回子表达式匹配的内容// {{完整匹配项}, {子匹配项}, {子匹配项}, ...}func (re *Regexp) FindSubmatch(b []byte) [][]bytefunc main() {    reg := regexp.MustCompile(`(\w)(\w)+`)    fmt.Printf(&quot;%q&quot;, reg.FindSubmatch([]byte(&quot;Hello World!&quot;)))    // [&quot;Hello&quot; &quot;H&quot; &quot;o&quot;]}------------------------------------------------------------// 在 s 中查找 re 中编译好的正则表达式，并返回第一个匹配的内容// 同时返回子表达式匹配的内容// {完整匹配项, 子匹配项, 子匹配项, ...}func (re *Regexp) FindStringSubmatch(s string) []stringfunc main() {    reg := regexp.MustCompile(`(\w)(\w)+`)    fmt.Printf(&quot;%q&quot;, reg.FindStringSubmatch(&quot;Hello World!&quot;))    // [&quot;Hello&quot; &quot;H&quot; &quot;o&quot;]}------------------------------------------------------------// 在 b 中查找 re 中编译好的正则表达式，并返回所有匹配的内容// 同时返回子表达式匹配的内容// {//     {{完整匹配项}, {子匹配项}, {子匹配项}, ...},//     {{完整匹配项}, {子匹配项}, {子匹配项}, ...},//     ...// }func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]bytefunc main() {    reg := regexp.MustCompile(`(\w)(\w)+`)    fmt.Printf(&quot;%q&quot;, reg.FindAllSubmatch([]byte(&quot;Hello World!&quot;), -1))    // [[&quot;Hello&quot; &quot;H&quot; &quot;o&quot;] [&quot;World&quot; &quot;W&quot; &quot;d&quot;]]}------------------------------------------------------------// 在 s 中查找 re 中编译好的正则表达式，并返回所有匹配的内容// 同时返回子表达式匹配的内容// {//     {完整匹配项, 子匹配项, 子匹配项, ...},//     {完整匹配项, 子匹配项, 子匹配项, ...},//     ...// }// 只查找前 n 个匹配项，如果 n &lt; 0，则查找所有匹配项func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]stringfunc main() {    reg := regexp.MustCompile(`(\w)(\w)+`)    fmt.Printf(&quot;%q&quot;, reg.FindAllStringSubmatch(&quot;Hello World!&quot;, -1))    // [[&quot;Hello&quot; &quot;H&quot; &quot;o&quot;] [&quot;World&quot; &quot;W&quot; &quot;d&quot;]]}------------------------------------------------------------// 在 b 中查找 re 中编译好的正则表达式，并返回第一个匹配的位置// 同时返回子表达式匹配的位置// {完整项起始, 完整项结束, 子项起始, 子项结束, 子项起始, 子项结束, ...}func (re *Regexp) FindSubmatchIndex(b []byte) []intfunc main() {    reg := regexp.MustCompile(`(\w)(\w)+`)    fmt.Println(reg.FindSubmatchIndex([]byte(&quot;Hello World!&quot;)))    // [0 5 0 1 4 5]}------------------------------------------------------------// 在 s 中查找 re 中编译好的正则表达式，并返回第一个匹配的位置// 同时返回子表达式匹配的位置// {完整项起始, 完整项结束, 子项起始, 子项结束, 子项起始, 子项结束, ...}func (re *Regexp) FindStringSubmatchIndex(s string) []intfunc main() {    reg := regexp.MustCompile(`(\w)(\w)+`)    fmt.Println(reg.FindStringSubmatchIndex(&quot;Hello World!&quot;))    // [0 5 0 1 4 5]}------------------------------------------------------------// 在 r 中查找 re 中编译好的正则表达式，并返回第一个匹配的位置// 同时返回子表达式匹配的位置// {完整项起始, 完整项结束, 子项起始, 子项结束, 子项起始, 子项结束, ...}func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []intfunc main() {    r := bytes.NewReader([]byte(&quot;Hello World!&quot;))    reg := regexp.MustCompile(`(\w)(\w)+`)    fmt.Println(reg.FindReaderSubmatchIndex(r))    // [0 5 0 1 4 5]}------------------------------------------------------------// 在 b 中查找 re 中编译好的正则表达式，并返回所有匹配的位置// 同时返回子表达式匹配的位置// {//     {完整项起始, 完整项结束, 子项起始, 子项结束, 子项起始, 子项结束, ...}, //     {完整项起始, 完整项结束, 子项起始, 子项结束, 子项起始, 子项结束, ...}, //     ...// }// 只查找前 n 个匹配项，如果 n &lt; 0，则查找所有匹配项func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]intfunc main() {    reg := regexp.MustCompile(`(\w)(\w)+`)    fmt.Println(reg.FindAllSubmatchIndex([]byte(&quot;Hello World!&quot;), -1))    // [[0 5 0 1 4 5] [6 11 6 7 10 11]]}------------------------------------------------------------// 在 s 中查找 re 中编译好的正则表达式，并返回所有匹配的位置// 同时返回子表达式匹配的位置// {//     {完整项起始, 完整项结束, 子项起始, 子项结束, 子项起始, 子项结束, ...}, //     {完整项起始, 完整项结束, 子项起始, 子项结束, 子项起始, 子项结束, ...}, //     ...// }// 只查找前 n 个匹配项，如果 n &lt; 0，则查找所有匹配项func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]intfunc main() {    reg := regexp.MustCompile(`(\w)(\w)+`)    fmt.Println(reg.FindAllStringSubmatchIndex(&quot;Hello World!&quot;, -1))    // [[0 5 0 1 4 5] [6 11 6 7 10 11]]}------------------------------------------------------------// 将 template 的内容经过处理后，追加到 dst 的尾部。// template 中要有 $1、$2、${name1}、${name2} 这样的“分组引用符”// match 是由 FindSubmatchIndex 方法返回的结果，里面存放了各个分组的位置信息// 如果 template 中有“分组引用符”，则以 match 为标准，// 在 src 中取出相应的子串，替换掉 template 中的 $1、$2 等引用符号。func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []bytefunc main() {    reg := regexp.MustCompile(`(\w+),(\w+)`)    src := []byte(&quot;Golang,World!&quot;)           // 源文本    dst := []byte(&quot;Say: &quot;)                   // 目标文本    template := []byte(&quot;Hello $1, Hello $2&quot;) // 模板    match := reg.FindSubmatchIndex(src)      // 解析源文本    // 填写模板，并将模板追加到目标文本中    fmt.Printf(&quot;%q&quot;, reg.Expand(dst, template, src, match))    // &quot;Say: Hello Golang, Hello World&quot;}------------------------------------------------------------// 功能同 Expand 一样，只不过参数换成了 string 类型func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []bytefunc main() {    reg := regexp.MustCompile(`(\w+),(\w+)`)    src := &quot;Golang,World!&quot;                    // 源文本    dst := []byte(&quot;Say: &quot;)                    // 目标文本（可写）    template := &quot;Hello $1, Hello $2&quot;          // 模板    match := reg.FindStringSubmatchIndex(src) // 解析源文本    // 填写模板，并将模板追加到目标文本中    fmt.Printf(&quot;%q&quot;, reg.ExpandString(dst, template, src, match))    // &quot;Say: Hello Golang, Hello World&quot;}------------------------------------------------------------// LiteralPrefix 返回所有匹配项都共同拥有的前缀（去除可变元素）// prefix：共同拥有的前缀// complete：如果 prefix 就是正则表达式本身，则返回 true，否则返回 falsefunc (re *Regexp) LiteralPrefix() (prefix string, complete bool)func main() {    reg := regexp.MustCompile(`Hello[\w\s]+`)    fmt.Println(reg.LiteralPrefix())    // Hello false    reg = regexp.MustCompile(`Hello`)    fmt.Println(reg.LiteralPrefix())    // Hello true}------------------------------------------------------------// 切换到“贪婪模式”func (re *Regexp) Longest()func main() {    text := `Hello World, 123 Go!`    pattern := `(?U)H[\w\s]+o` // 正则标记“非贪婪模式”(?U)    reg := regexp.MustCompile(pattern)    fmt.Printf(&quot;%q\n&quot;, reg.FindString(text))    // Hello    reg.Longest() // 切换到“贪婪模式”    fmt.Printf(&quot;%q\n&quot;, reg.FindString(text))    // Hello Wo}------------------------------------------------------------// 判断在 b 中能否找到匹配项func (re *Regexp) Match(b []byte) boolfunc main() {    b := []byte(`Hello World`)    reg := regexp.MustCompile(`Hello\w+`)    fmt.Println(reg.Match(b))    // false    reg = regexp.MustCompile(`Hello[\w\s]+`)    fmt.Println(reg.Match(b))    // true}------------------------------------------------------------// 判断在 r 中能否找到匹配项func (re *Regexp) MatchReader(r io.RuneReader) boolfunc main() {    r := bytes.NewReader([]byte(`Hello World`))    reg := regexp.MustCompile(`Hello\w+`)    fmt.Println(reg.MatchReader(r))    // false    r.Seek(0, 0)    reg = regexp.MustCompile(`Hello[\w\s]+`)    fmt.Println(reg.MatchReader(r))    // true}------------------------------------------------------------// 判断在 s 中能否找到匹配项func (re *Regexp) MatchString(s string) boolfunc main() {    s := `Hello World`    reg := regexp.MustCompile(`Hello\w+`)    fmt.Println(reg.MatchString(s))    // false    reg = regexp.MustCompile(`Hello[\w\s]+`)    fmt.Println(reg.MatchString(s))    // true}------------------------------------------------------------// 统计正则表达式中的分组个数（不包括“非捕获的分组”）func (re *Regexp) NumSubexp() intfunc main() {    reg := regexp.MustCompile(`(?U)(?:Hello)(\s+)(\w+)`)    fmt.Println(reg.NumSubexp())    // 2}------------------------------------------------------------// 在 src 中搜索匹配项，并替换为 repl 指定的内容// 全部替换，并返回替换后的结果func (re *Regexp) ReplaceAll(src, repl []byte) []bytefunc main() {    b := []byte(&quot;Hello World, 123 Go!&quot;)    reg := regexp.MustCompile(`(Hell|G)o`)    rep := []byte(&quot;${1}ooo&quot;)    fmt.Printf(&quot;%q\n&quot;, reg.ReplaceAll(b, rep))    // &quot;Hellooo World, 123 Gooo!&quot;}------------------------------------------------------------// 在 src 中搜索匹配项，并替换为 repl 指定的内容// 全部替换，并返回替换后的结果func (re *Regexp) ReplaceAllString(src, repl string) stringfunc main() {    s := &quot;Hello World, 123 Go!&quot;    reg := regexp.MustCompile(`(Hell|G)o`)    rep := &quot;${1}ooo&quot;    fmt.Printf(&quot;%q\n&quot;, reg.ReplaceAllString(s, rep))    // &quot;Hellooo World, 123 Gooo!&quot;}------------------------------------------------------------// 在 src 中搜索匹配项，并替换为 repl 指定的内容// 如果 repl 中有“分组引用符”（$1、$name），则将“分组引用符”当普通字符处理// 全部替换，并返回替换后的结果func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []bytefunc main() {    b := []byte(&quot;Hello World, 123 Go!&quot;)    reg := regexp.MustCompile(`(Hell|G)o`)    rep := []byte(&quot;${1}ooo&quot;)    fmt.Printf(&quot;%q\n&quot;, reg.ReplaceAllLiteral(b, rep))    // &quot;${1}ooo World, 123 ${1}ooo!&quot;}------------------------------------------------------------// 在 src 中搜索匹配项，并替换为 repl 指定的内容// 如果 repl 中有“分组引用符”（$1、$name），则将“分组引用符”当普通字符处理// 全部替换，并返回替换后的结果func (re *Regexp) ReplaceAllLiteralString(src, repl string) stringfunc main() {    s := &quot;Hello World, 123 Go!&quot;    reg := regexp.MustCompile(`(Hell|G)o`)    rep := &quot;${1}ooo&quot;    fmt.Printf(&quot;%q\n&quot;, reg.ReplaceAllLiteralString(s, rep))    // &quot;${1}ooo World, 123 ${1}ooo!&quot;}------------------------------------------------------------// 在 src 中搜索匹配项，然后将匹配的内容经过 repl 处理后，替换 src 中的匹配项// 如果 repl 的返回值中有“分组引用符”（$1、$name），则将“分组引用符”当普通字符处理// 全部替换，并返回替换后的结果func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []bytefunc main() {    s := []byte(&quot;Hello World!&quot;)    reg := regexp.MustCompile(&quot;(H)ello&quot;)    rep := []byte(&quot;$0$1&quot;)    fmt.Printf(&quot;%s\n&quot;, reg.ReplaceAll(s, rep))    // HelloH World!    fmt.Printf(&quot;%s\n&quot;, reg.ReplaceAllFunc(s,        func(b []byte) []byte {            rst := []byte{}            rst = append(rst, b...)            rst = append(rst, &quot;$1&quot;...)            return rst        }))    // Hello$1 World!}k------------------------------------------------------------// 在 src 中搜索匹配项，然后将匹配的内容经过 repl 处理后，替换 src 中的匹配项// 如果 repl 的返回值中有“分组引用符”（$1、$name），则将“分组引用符”当普通字符处理// 全部替换，并返回替换后的结果func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) stringfunc main() {    s := &quot;Hello World!&quot;    reg := regexp.MustCompile(&quot;(H)ello&quot;)    rep := &quot;$0$1&quot;    fmt.Printf(&quot;%s\n&quot;, reg.ReplaceAllString(s, rep))    // HelloH World!    fmt.Printf(&quot;%s\n&quot;, reg.ReplaceAllStringFunc(s,        func(b string) string {            return b + &quot;$1&quot;        }))    // Hello$1 World!}------------------------------------------------------------// 在 s 中搜索匹配项，并以匹配项为分割符，将 s 分割成多个子串// 最多分割出 n 个子串，第 n 个子串不再进行分割// 如果 n &lt; 0，则分割所有子串// 返回分割后的子串列表func (re *Regexp) Split(s string, n int) []stringfunc main() {    s := &quot;Hello World\tHello\nGolang&quot;    reg := regexp.MustCompile(`\s`)    fmt.Printf(&quot;%q\n&quot;, reg.Split(s, -1))    // [&quot;Hello&quot; &quot;World&quot; &quot;Hello&quot; &quot;Golang&quot;]}------------------------------------------------------------// 返回 re 中的“正则表达式”字符串func (re *Regexp) String() stringfunc main() {    re := regexp.MustCompile(&quot;Hello.*$&quot;)    fmt.Printf(&quot;%s\n&quot;, re.String())    // Hello.*$}------------------------------------------------------------// 返回 re 中的分组名称列表，未命名的分组返回空字符串// 返回值[0] 为整个正则表达式的名称// 返回值[1] 是分组 1 的名称// 返回值[2] 是分组 2 的名称// ……func (re *Regexp) SubexpNames() []stringfunc main() {    re := regexp.MustCompile(&quot;(?PHello) (World)&quot;)    fmt.Printf(&quot;%q\n&quot;, re.SubexpNames())    // [&quot;&quot; &quot;Name1&quot; &quot;&quot;]}</code></pre><ul><li>举个栗子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">需要替换字符串中指定字符 将hello 中的e 替换成 a</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    //正则匹配，匹配规则是： 包含e</span><br><span class="line">    reg, err := regexp.Compile(&quot;e&quot;)</span><br><span class="line"></span><br><span class="line">    if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;Compile failed: %s&quot;, error)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    //ReplaceAll： 第一个参数是需要替换的字符串，第二个是 替换的字符</span><br><span class="line">    output := string(reg.ReplaceAll([]byte(&quot;hello&quot;),[]byte(&quot;a&quot;)))</span><br><span class="line">    fmt.Println(output)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; hallo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;regexp包&quot;&gt;&lt;a href=&quot;#regexp包&quot; class=&quot;headerlink&quot; title=&quot;regexp包&quot;&gt;&lt;/a&gt;regexp包&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;------------------------------------------------------------

// 判断在 b 中能否找到正则表达式 pattern 所匹配的子串
// pattern：要查找的正则表达式
// b：要在其中进行查找的 []byte
// matched：返回是否找到匹配项
// err：返回查找过程中遇到的任何错误
// 此函数通过调用 Regexp 的方法实现
func Match(pattern string, b []byte) (matched bool, err error)

func main() {
    fmt.Println(regexp.Match(&amp;quot;H.* &amp;quot;, []byte(&amp;quot;Hello World!&amp;quot;)))
    // true 
}

------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="go" scheme="http://ymliang.com/categories/go/"/>
    
    
      <category term="go" scheme="http://ymliang.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go开发基础入门——5</title>
    <link href="http://ymliang.com/Go%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E2%80%94%E2%80%945.html"/>
    <id>http://ymliang.com/Go开发基础入门——5.html</id>
    <published>2019-06-06T09:55:21.000Z</published>
    <updated>2019-09-09T10:01:18.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="条件语句-select"><a href="#条件语句-select" class="headerlink" title="条件语句 select"></a>条件语句 select</h3><pre><code>select 语句select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。select 是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。select 随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。</code></pre><a id="more"></a><p>语法：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">    case communication clause  :</span><br><span class="line">    statement(s);      </span><br><span class="line">    case communication clause  :</span><br><span class="line">    statement(s);</span><br><span class="line">    /* 你可以定义任意数量的 case */</span><br><span class="line">    default : /* 可选 */</span><br><span class="line">    statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code>见Go开发基础入门——2</code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><pre><code>方法只要记住有method 和 receiver即可receiver可以是值也可以是指针定义方法：func (recevier  recevier&apos;s type) methodName(参数列表)(返回值列表){}我们来测试一下是否只可以用 recevier&apos;s type 类型来使用这个方法</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func (t T) testT() &#123;</span><br><span class="line">fmt.Println(&quot;类型 T 方法集包含全部 receiver T 方法&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func (s *S) testS() &#123;</span><br><span class="line">fmt.Println(&quot;类型 *S 方法集包含全部 receiver S + *S 方法&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type T struct &#123;</span><br><span class="line">int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type S struct &#123;</span><br><span class="line">int</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">a := T&#123;10&#125;</span><br><span class="line">b := &amp;a</span><br><span class="line">a.testT()</span><br><span class="line">b.testT()</span><br><span class="line"></span><br><span class="line">c := S&#123;20&#125;</span><br><span class="line">d := &amp;c</span><br><span class="line">c.testS()</span><br><span class="line">d.testS()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;类型 T 方法集包含全部 receiver T 方法</span><br><span class="line">&gt;类型 T 方法集包含全部 receiver T 方法</span><br><span class="line">&gt;类型 *S 方法集包含全部 receiver S + *S 方法</span><br><span class="line">&gt;类型 *S 方法集包含全部 receiver S + *S 方法</span><br></pre></td></tr></table></figure><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><pre><code>变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过GC回收。获取指针类型所指向的值，使用：&quot; * &quot; 取值符号 。比如：var *p int, 使用*p获取p指向的值指针、slice、map、chan等都是引用类型new和make的区别make 用来创建map、slice、channelnew 用来创建值类型new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作。new() 是一个函数，不要忘记它的括号。</code></pre><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><pre><code>golang slice data[:6:8] 两个冒号的理解常规slice , data[6:8]，从第6位到第8位（返回6， 7），长度len为2， 最大可扩充长度cap为4（6-9）另一种写法： data[:6:8] 每个数字前都有个冒号， slice内容为data从0到第6位，长度len为6，最大扩充项cap设置为8a[x:y:z] 切片内容 [x:y] 切片长度: y-x 切片容量:z-x</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    slice := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">    d1 := slice[6:8]</span><br><span class="line">    fmt.Println(d1, len(d1), cap(d1))</span><br><span class="line">    d2 := slice[:6:8]</span><br><span class="line">    fmt.Println(d2, len(d2), cap(d2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[6 7] 2 4</span><br><span class="line">[0 1 2 3 4 5] 6 8</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><pre><code>var map变量名 map[key] value其中：key为键类型，value为值类型例如：value不仅可以是标注数据类型，也可以是自定义数据类型</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">常用的初始化方法：</span><br><span class="line">make()</span><br><span class="line">Go语言提供的内置函数make()可以用于灵活地创建map。</span><br><span class="line">预先给 make 函数一个合理元素数量参数，有助于提升性能。因为事先申请一大块内存，可避免后续操作时频繁扩张</span><br><span class="line"></span><br><span class="line">type One struct &#123;</span><br><span class="line">name string</span><br><span class="line">age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    dataMap := make(map[string]One)</span><br><span class="line">    dataMap[&quot;1&quot;] = One&#123;&quot;liangfeifan&quot;,22&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map[1:&#123;liangfeifan 22&#125;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常规初始化方法：</span><br><span class="line"></span><br><span class="line">dataMap := map[string]One&#123;</span><br><span class="line">    &quot;3&quot;: &#123;&quot;liang&quot;, 22&#125;,</span><br><span class="line">    &quot;4&quot;: &#123;&quot;fei&quot;, 10&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line">map操作：</span><br><span class="line">插入、更新、查找、删除、判断是否存在、求长度</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">m := map[string]string&#123;&quot;key0&quot;: &quot;value0&quot;, &quot;key1&quot;: &quot;value1&quot;&#125;</span><br><span class="line">fmt.Printf(&quot;map m : %v\n&quot;, m)</span><br><span class="line">//map插入</span><br><span class="line">m[&quot;key2&quot;] = &quot;value2&quot;</span><br><span class="line">fmt.Printf(&quot;inserted map m : %v\n&quot;, m)</span><br><span class="line">//map修改</span><br><span class="line">m[&quot;key0&quot;] = &quot;hello world!&quot;</span><br><span class="line">fmt.Printf(&quot;updated map m : %v\n&quot;, m)</span><br><span class="line">//map查找</span><br><span class="line">val, ok := m[&quot;key0&quot;]</span><br><span class="line">if ok &#123;</span><br><span class="line">fmt.Printf(&quot;map&apos;s key0 is %v\n&quot;, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 长度：获取键值对数量。</span><br><span class="line">len := len(m)</span><br><span class="line">fmt.Printf(&quot;map&apos;s len is %v\n&quot;, len)</span><br><span class="line"></span><br><span class="line">// cap 无效，error</span><br><span class="line">// cap := cap(m)    //invalid argument m (type map[string]string) for cap</span><br><span class="line">// fmt.Printf(&quot;map&apos;s cap is %v\n&quot;, cap)</span><br><span class="line"></span><br><span class="line">// 判断 key 是否存在。</span><br><span class="line">if val, ok = m[&quot;key&quot;]; !ok &#123;</span><br><span class="line">fmt.Println(&quot;map&apos;s key is not existence&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除，如果 key 不存在，不会出错。</span><br><span class="line">if val, ok = m[&quot;key1&quot;]; ok &#123;</span><br><span class="line">delete(m, &quot;key1&quot;)</span><br><span class="line">fmt.Printf(&quot;deleted key1 map m : %v\n&quot;, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">map m : map[key0:value0 key1:value1]</span><br><span class="line">inserted map m : map[key0:value0 key1:value1 key2:value2]</span><br><span class="line">updated map m : map[key0:hello world! key1:value1 key2:value2]</span><br><span class="line">map&apos;s key0 is hello world!</span><br><span class="line">map&apos;s len is 3</span><br><span class="line">map&apos;s key is not existence</span><br><span class="line">deleted key1 map m : map[key0:hello world! key2:value2]</span><br><span class="line">map遍历：</span><br><span class="line"></span><br><span class="line">不能保证迭代返回次序，通常是随机结果，具体和版本实现有关。</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">m := make(map[int]int)</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">m[i] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m)</span><br><span class="line">fmt.Println(m)</span><br><span class="line"></span><br><span class="line">for j := 0; j &lt; 2; j++ &#123;</span><br><span class="line">fmt.Println(&quot;---------------------&quot;)</span><br><span class="line">for k, v := range m &#123;</span><br><span class="line">fmt.Printf(&quot;key -&gt; value : %v -&gt; %v\n&quot;, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">map[6:6 8:8 2:2 1:1 3:3 4:4 5:5 7:7 9:9 0:0]</span><br><span class="line">map[2:2 6:6 8:8 5:5 7:7 9:9 0:0 1:1 3:3 4:4]</span><br><span class="line">---------------------</span><br><span class="line">key -&gt; value : 2 -&gt; 2</span><br><span class="line">key -&gt; value : 6 -&gt; 6</span><br><span class="line">key -&gt; value : 8 -&gt; 8</span><br><span class="line">key -&gt; value : 9 -&gt; 9</span><br><span class="line">key -&gt; value : 0 -&gt; 0</span><br><span class="line">key -&gt; value : 1 -&gt; 1</span><br><span class="line">key -&gt; value : 3 -&gt; 3</span><br><span class="line">key -&gt; value : 4 -&gt; 4</span><br><span class="line">key -&gt; value : 5 -&gt; 5</span><br><span class="line">key -&gt; value : 7 -&gt; 7</span><br><span class="line">---------------------</span><br><span class="line">key -&gt; value : 8 -&gt; 8</span><br><span class="line">key -&gt; value : 2 -&gt; 2</span><br><span class="line">key -&gt; value : 6 -&gt; 6</span><br><span class="line">key -&gt; value : 3 -&gt; 3</span><br><span class="line">key -&gt; value : 4 -&gt; 4</span><br><span class="line">key -&gt; value : 5 -&gt; 5</span><br><span class="line">key -&gt; value : 7 -&gt; 7</span><br><span class="line">key -&gt; value : 9 -&gt; 9</span><br><span class="line">key -&gt; value : 0 -&gt; 0</span><br><span class="line">key -&gt; value : 1 -&gt; 1</span><br><span class="line">slice与map操作（slice of map）</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">items := make([]map[int]int, 5)</span><br><span class="line">for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">items[i] = make(map[int]int)</span><br><span class="line">&#125;</span><br><span class="line">items[0][0] = 0</span><br><span class="line">items[1][2] = 3</span><br><span class="line">fmt.Println(items)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">[map[0:0] map[2:3] map[] map[] map[]]</span><br><span class="line">map排序：</span><br><span class="line"></span><br><span class="line">先获取所有key，把key进行排序，再按照排序好的key，进行遍历。</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sort&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">m := map[string]string&#123;&quot;q&quot;: &quot;q&quot;, &quot;w&quot;: &quot;w&quot;, &quot;e&quot;: &quot;e&quot;, &quot;r&quot;: &quot;r&quot;, &quot;t&quot;: &quot;t&quot;, &quot;y&quot;: &quot;y&quot;&#125;</span><br><span class="line">var slice []string</span><br><span class="line">for k, _ := range m &#123;</span><br><span class="line">slice = append(slice, k)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;clise string is : %v\n&quot;, slice)</span><br><span class="line">sort.Strings(slice[:])</span><br><span class="line">fmt.Printf(&quot;sorted slice string is : %v\n&quot;, slice)</span><br><span class="line">for _, v := range slice &#123;</span><br><span class="line">fmt.Println(m[v])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">clise string is : [e r t y q w]</span><br><span class="line">sorted slice string is : [e q r t w y]</span><br><span class="line">e</span><br><span class="line">q</span><br><span class="line">r</span><br><span class="line">t</span><br><span class="line">w</span><br><span class="line">y</span><br><span class="line">map反转：</span><br><span class="line">初始化另外一个map，把key、value互换即可.</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">m := map[int]string&#123;1: &quot;x&quot;, 2: &quot;w&quot;, 3: &quot;e&quot;, 4: &quot;r&quot;, 5: &quot;t&quot;, 6: &quot;y&quot;&#125;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">m_rev := make(map[string]int)</span><br><span class="line">for k, v := range m &#123;</span><br><span class="line">m_rev[v] = k</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m_rev)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">map[3:e 4:r 5:t 6:y 1:x 2:w]</span><br><span class="line">map[r:4 t:5 y:6 x:1 w:2 e:3]</span><br><span class="line">从 map 中取回的是一个 value 临时复制品，对其成员的修改是没有任何意义的。</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">m := map[int]string&#123;1: &quot;x&quot;, 2: &quot;w&quot;&#125;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">for k, v := range m &#123;</span><br><span class="line">m[k] = v + v   //修改map的值</span><br><span class="line">v = v + &quot;copy&quot; //临时复制品，修改无效</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">容器和结构体（map and struct）</span><br><span class="line"></span><br><span class="line">语法比较：</span><br><span class="line">map[type]struct</span><br><span class="line">map[type]*struct</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">type user struct&#123; name string &#125;</span><br><span class="line">/*</span><br><span class="line">   当 map 因扩张而重新哈希时，各键值项存储位置都会发生改变。</span><br><span class="line">   因此，map 被设计成 not addressable。</span><br><span class="line">   类似 m[1].name 这种期望透过原 value 指针修改成员的行为自然会被禁 。</span><br><span class="line">*/</span><br><span class="line">m := map[int]user&#123; //</span><br><span class="line"></span><br><span class="line">1: &#123;&quot;user1&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">// m[1].name = &quot;Tom&quot;</span><br><span class="line">// ./main.go:16:12: cannot assign to struct field m[1].name in map</span><br><span class="line">fmt.Println(m)</span><br><span class="line"></span><br><span class="line">// 正确做法是完整替换 value 或使用指针。</span><br><span class="line">u := m[1]</span><br><span class="line">u.name = &quot;Tom&quot;</span><br><span class="line">m[1] = u // 替换 value。</span><br><span class="line"></span><br><span class="line">m2 := map[int]*user&#123;</span><br><span class="line">1: &amp;user&#123;&quot;user1&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m2[1].name = &quot;Jack&quot; // 返回的是指针复制品。透过指针修改原对象是允许的。</span><br><span class="line">fmt.Println(m2)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">map[1:&#123;user1&#125;]</span><br><span class="line">map[1:0xc42000e1e0]</span><br><span class="line">可以在迭代时安全删除键值。但如果期间有新增操作，那么就不知道会有什么意外了。</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">m := map[int]string&#123;</span><br><span class="line">0: &quot;a&quot;, 1: &quot;a&quot;, 2: &quot;a&quot;, 3: &quot;a&quot;, 4: &quot;a&quot;,</span><br><span class="line">5: &quot;a&quot;, 6: &quot;a&quot;, 7: &quot;a&quot;, 8: &quot;a&quot;, 9: &quot;a&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for k := range m &#123;</span><br><span class="line">m[k+k] = &quot;x&quot;</span><br><span class="line">delete(m, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line">//每次输出都会变化</span><br><span class="line"></span><br><span class="line">map[36:x 28:x 32:x 2:x 8:x 10:x 12:x]</span><br><span class="line">map[12:x 6:x 16:x 28:x 4:x 10:x 72:x]</span><br><span class="line">map[12:x 14:x 16:x 18:x 20:x]</span><br><span class="line">map[18:x 10:x 14:x 4:x 6:x 16:x 24:x]</span><br><span class="line">map[12:x 16:x 4:x 40:x 14:x 18:x]</span><br></pre></td></tr></table></figure><h3 id="管道-channel"><a href="#管道-channel" class="headerlink" title="管道 (channel)"></a>管道 (channel)</h3><ul><li>Golang 引用类型 channel 是 CSP 模式的具体实现，用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">channel概念:</span><br><span class="line">    a. 类似unix中管道（pipe）</span><br><span class="line">    b. 先进先出</span><br><span class="line">    c. 线程安全，多个goroutine同时访问，不需要加锁</span><br><span class="line">    d. channel是有类型的，一个整数的channel只能存放整数</span><br><span class="line"></span><br><span class="line">channel声明:</span><br><span class="line">    var 变量名 chan 类型</span><br><span class="line"></span><br><span class="line">    package main</span><br><span class="line"></span><br><span class="line">    var ch0 chan int</span><br><span class="line">    var ch1 chan string</span><br><span class="line">    var ch2 chan map[string]string</span><br><span class="line"></span><br><span class="line">    type stu struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">    var ch3 chan stu</span><br><span class="line">    var ch4 chan *stu</span><br><span class="line"></span><br><span class="line">    func main() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">channel初始化:</span><br><span class="line">使用make进行初始化，比如：</span><br><span class="line"></span><br><span class="line">ch := make(chan string,1)</span><br><span class="line">ch2 := make(chan string)</span><br><span class="line"></span><br><span class="line">上述两种：分别为 有缓冲，无缓冲</span><br><span class="line">无缓冲的与有缓冲channel有着重大差别，那就是一个是同步的 一个是非同步的。</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line"></span><br><span class="line">c1:=make(chan int) 无缓冲</span><br><span class="line"></span><br><span class="line">c2:=make(chan int,1) 有缓冲</span><br><span class="line"></span><br><span class="line">c1&lt;-1</span><br><span class="line"></span><br><span class="line">无缓冲： 不仅仅是向 c1 通道放 1，而是一直要等有别的携程 &lt;-c1 接手了这个参数，那么c1&lt;-1才会继续下去，要不然就一直阻塞着。</span><br><span class="line"></span><br><span class="line">有缓冲： c2&lt;-1 则不会阻塞，因为缓冲大小是1(其实是缓冲大小为0)，只有当放第二个值的时候，第一个还没被人拿走，这时候才会阻塞。</span><br><span class="line"></span><br><span class="line">缓冲区是内部属性，并非类型构成要素。</span><br></pre></td></tr></table></figure><blockquote><p>请关注我的<a href="https://ymliang.netlify.com/about/" target="_blank" rel="noopener">个人博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;条件语句-select&quot;&gt;&lt;a href=&quot;#条件语句-select&quot; class=&quot;headerlink&quot; title=&quot;条件语句 select&quot;&gt;&lt;/a&gt;条件语句 select&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;select 语句
select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。

select 是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。
select 随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="go" scheme="http://ymliang.com/categories/go/"/>
    
    
      <category term="go" scheme="http://ymliang.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go开发基础入门——4</title>
    <link href="http://ymliang.com/Go%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E2%80%94%E2%80%944.html"/>
    <id>http://ymliang.com/Go开发基础入门——4.html</id>
    <published>2019-06-05T09:41:37.000Z</published>
    <updated>2019-09-09T10:01:24.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>请关注我的<a href="https://ymliang.netlify.com/about/" target="_blank" rel="noopener">个人博客</a></p></blockquote><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul><li><p>if</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   if 布尔表达式 &#123;</span><br><span class="line">/* 在布尔表达式为 true 时执行 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   *不支持三元操作符(三目运算符) &quot;a &gt; b ? a : b&quot;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   if else：</span><br><span class="line"></span><br><span class="line">   if 布尔表达式 &#123;</span><br><span class="line">   /* 在布尔表达式为 true 时执行 */</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   /* 在布尔表达式为 false 时执行 */</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>for</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Go语言的For循环有3中形式，只有其中的一种使用分号。</span><br><span class="line"></span><br><span class="line">for init; condition; post &#123; &#125;</span><br><span class="line">for condition &#123; &#125;</span><br><span class="line">for &#123; &#125;</span><br><span class="line">init： 一般为赋值表达式，给控制变量赋初值；</span><br><span class="line">condition： 关系表达式或逻辑表达式，循环控制条件；</span><br><span class="line">post： 一般为赋值表达式，给控制变量增量或减量。</span><br><span class="line">for语句执行过程如下：</span><br><span class="line">①先对表达式 init 赋初值；</span><br><span class="line">②判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。</span><br><span class="line"></span><br><span class="line">公式：</span><br><span class="line">for [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">&#123;</span><br><span class="line">    statement(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">替代 while(true)的方法：</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为比较简单，我这里说一个稍微复杂一点的就是 range ，那么请先看range的知识点</span><br><span class="line"></span><br><span class="line">下面是一个栗子：</span><br><span class="line">func changeBigSmallWord(str string) string&#123;</span><br><span class="line">    result := &quot;&quot;</span><br><span class="line">    for i,value := range str&#123;</span><br><span class="line">        if i%2==0 &#123;</span><br><span class="line">            result += strings.ToUpper(string(value))</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            result += strings.ToLower(string(value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">循环时用到range 即迭代传入的 str 相当于遍历了</span><br></pre></td></tr></table></figure></li><li><p>range</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">range = 迭代器的效果</span><br><span class="line">简单理解成遍历没有问题</span><br><span class="line"></span><br><span class="line">for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</span><br><span class="line"></span><br><span class="line">str := &quot;abcdefgHiGKLmn&quot;</span><br><span class="line"></span><br><span class="line">result := &quot;&quot;</span><br><span class="line">for _, value := range str &#123;</span><br><span class="line">    result += string(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>举个栗子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//字母大小写变化</span><br><span class="line"></span><br><span class="line">func changeBigSmallWord(str string) string&#123;</span><br><span class="line">    result := &quot;&quot;</span><br><span class="line">    for i,value := range str&#123;</span><br><span class="line">        if i%2==0 &#123;</span><br><span class="line">            result += strings.ToUpper(string(value))</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            result += strings.ToLower(string(value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">func main&#123;</span><br><span class="line">    str2 := &quot;abcdefGHIGKLMN&quot;</span><br><span class="line">    result2 := changeBigSmallWord(str2)</span><br><span class="line">    fmt.Println(result2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;AbCdEfGhIgKlMn</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for 和 for range有什么区别?</span><br><span class="line"></span><br><span class="line">主要是使用场景不同</span><br><span class="line"></span><br><span class="line">for可以</span><br><span class="line"></span><br><span class="line">遍历array和slice</span><br><span class="line">遍历key为整型递增的map</span><br><span class="line">遍历string</span><br><span class="line"></span><br><span class="line">for range可以完成所有for可以做的事情，却能做到for不能做的，包括</span><br><span class="line"></span><br><span class="line">遍历key为string类型的map并同时获取key和value</span><br><span class="line">遍历channel</span><br></pre></td></tr></table></figure></li></ul></li><li><p>switch</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch var1 &#123;</span><br><span class="line">    case val1:</span><br><span class="line">        ...</span><br><span class="line">    case val2:</span><br><span class="line">        ...</span><br><span class="line">    default:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。</span><br></pre></td></tr></table></figure><ul><li><p>举个栗子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">/* 定义局部变量 */</span><br><span class="line">var grade string = &quot;B&quot;</span><br><span class="line">var marks int = 90</span><br><span class="line"></span><br><span class="line">switch marks &#123;</span><br><span class="line">    case 90: grade = &quot;A&quot;</span><br><span class="line">    case 80: grade = &quot;B&quot;</span><br><span class="line">    case 50,60,70 : grade = &quot;C&quot;</span><br><span class="line">    default: grade = &quot;D&quot;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch &#123;</span><br><span class="line">    case grade == &quot;A&quot; :</span><br><span class="line">        fmt.Printf(&quot;优秀!\n&quot; )     </span><br><span class="line">    case grade == &quot;B&quot;, grade == &quot;C&quot; :</span><br><span class="line">        fmt.Printf(&quot;良好\n&quot; )      </span><br><span class="line">    case grade == &quot;D&quot; :</span><br><span class="line">        fmt.Printf(&quot;及格\n&quot; )      </span><br><span class="line">    case grade == &quot;F&quot;:</span><br><span class="line">        fmt.Printf(&quot;不及格\n&quot; )</span><br><span class="line">    default:</span><br><span class="line">        fmt.Printf(&quot;差\n&quot; )</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;你的等级是 %s\n&quot;, grade )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优秀!</span><br><span class="line">你的等级是 A</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">比较好理解，和java中的类似，下面来看一些不太一样的，比如case中包含 &amp;&amp; || 等，或者是判断某个 interface 变量中实际存储的变量类型</span><br><span class="line"></span><br><span class="line">定义语句： Type switch</span><br><span class="line">Type Switch 语法格式如下：</span><br><span class="line">switch x.(type)&#123;</span><br><span class="line">    case type:</span><br><span class="line">    statement(s)      </span><br><span class="line">    case type:</span><br><span class="line">    statement(s)</span><br><span class="line">    /* 你可以定义任意个数的case */</span><br><span class="line">    default: /* 可选 */</span><br><span class="line">    statement(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var x interface&#123;&#125;</span><br><span class="line">    //写法一：</span><br><span class="line">    switch i := x.(type) &#123; // 带初始化语句</span><br><span class="line">    case nil:</span><br><span class="line">        fmt.Printf(&quot; x 的类型 :%T\r\n&quot;, i)</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Printf(&quot;x 是 int 型&quot;)</span><br><span class="line">    case float64:</span><br><span class="line">        fmt.Printf(&quot;x 是 float64 型&quot;)</span><br><span class="line">    case func(int) float64:</span><br><span class="line">        fmt.Printf(&quot;x 是 func(int) 型&quot;)</span><br><span class="line">    case bool, string:</span><br><span class="line">        fmt.Printf(&quot;x 是 bool 或 string 型&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Printf(&quot;未知型&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //写法二</span><br><span class="line">    var j = 0</span><br><span class="line">    switch j &#123;</span><br><span class="line">    case 0:</span><br><span class="line">    case 1:</span><br><span class="line">        fmt.Println(&quot;1&quot;)</span><br><span class="line">    case 2:</span><br><span class="line">        fmt.Println(&quot;2&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;def&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //写法三</span><br><span class="line">    var k = 0</span><br><span class="line">    switch k &#123;</span><br><span class="line">    case 0:</span><br><span class="line">        println(&quot;fallthrough&quot;)</span><br><span class="line">        fallthrough</span><br><span class="line">        /*</span><br><span class="line">            Go的switch非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；</span><br><span class="line">            而如果switch没有表达式，它会匹配true。</span><br><span class="line">            Go里面switch默认相当于每个case最后带有break，</span><br><span class="line">            匹配成功后不会自动向下执行其他case，而是跳出整个switch,</span><br><span class="line">            但是可以使用fallthrough强制执行后面的case代码。</span><br><span class="line">        */</span><br><span class="line">    case 1:</span><br><span class="line">        fmt.Println(&quot;1&quot;)</span><br><span class="line">    case 2:</span><br><span class="line">        fmt.Println(&quot;2&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;def&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //写法三</span><br><span class="line">    var m = 0</span><br><span class="line">    switch m &#123;</span><br><span class="line">    case 0, 1:</span><br><span class="line">        fmt.Println(&quot;1&quot;)</span><br><span class="line">    case 2:</span><br><span class="line">        fmt.Println(&quot;2&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;def&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //写法四</span><br><span class="line">    var n = 0</span><br><span class="line">    switch &#123; //省略条件表达式，可当 if...else if...else</span><br><span class="line">    case n &gt; 0 &amp;&amp; n &lt; 10:</span><br><span class="line">        fmt.Println(&quot;i &gt; 0 and i &lt; 10&quot;)</span><br><span class="line">    case n &gt; 10 &amp;&amp; n &lt; 20:</span><br><span class="line">        fmt.Println(&quot;i &gt; 10 and i &lt; 20&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;def&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">x 的类型 :&lt;nil&gt;</span><br><span class="line">fallthrough</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">def</span><br></pre></td></tr></table></figure></li></ul></li><li><p>循环控制Goto、Break、Continue</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>请关注我的<a href="https://ymliang.netlify.com/about/" target="_blank" rel="noopener">个人博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;请关注我的&lt;a href=&quot;https://ymliang.netlify.com/about/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;if&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   if 布尔表达式 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* 在布尔表达式为 true 时执行 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   *不支持三元操作符(三目运算符) &amp;quot;a &amp;gt; b ? a : b&amp;quot;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   if else：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   if 布尔表达式 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /* 在布尔表达式为 true 时执行 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /* 在布尔表达式为 false 时执行 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="go" scheme="http://ymliang.com/categories/go/"/>
    
    
      <category term="go" scheme="http://ymliang.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go开发基础入门——3</title>
    <link href="http://ymliang.com/Go%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E2%80%94%E2%80%943.html"/>
    <id>http://ymliang.com/Go开发基础入门——3.html</id>
    <published>2019-06-05T08:22:46.000Z</published>
    <updated>2019-07-29T06:38:48.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go-向函数传递指针参数"><a href="#Go-向函数传递指针参数" class="headerlink" title="Go 向函数传递指针参数"></a>Go 向函数传递指针参数</h3><ul><li><p>Go 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    /* 定义局部变量 */</span><br><span class="line">    var a int = 100</span><br><span class="line">    var b int = 200</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;交换前 a 的值 : %d\n&quot;, a)</span><br><span class="line">    fmt.Printf(&quot;交换前 b 的值 : %d\n&quot;, b)</span><br><span class="line"></span><br><span class="line">    /* 调用函数用于交换值</span><br><span class="line">    * &amp;a 指向 a 变量的地址</span><br><span class="line">    * &amp;b 指向 b 变量的地址</span><br><span class="line">    */</span><br><span class="line">    swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;交换后 a 的值 : %d\n&quot;, a)</span><br><span class="line">    fmt.Printf(&quot;交换后 b 的值 : %d\n&quot;, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func swap(x *int, y *int) &#123;</span><br><span class="line">    var temp int</span><br><span class="line">    temp = *x /* 保存 x 地址的值 */</span><br><span class="line">    *x = *y   /* 将 y 赋值给 x */</span><br><span class="line">    *y = temp /* 将 temp 赋值给 y */</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">交换前 a 的值 : 100</span><br><span class="line">交换前 b 的值 : 200</span><br><span class="line">交换后 a 的值 : 200</span><br><span class="line">交换后 b 的值 : 100</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="自定义类型Struct"><a href="#自定义类型Struct" class="headerlink" title="自定义类型Struct"></a>自定义类型Struct</h3><ul><li><p>Go中的 struct：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">可将类型分为命名和未命名两大类。命名类型包括 bool、int、string 等，而 array、slice、map 等和具体元素类型、长度等有关，属于未命名类型。</span><br><span class="line"></span><br><span class="line">具有相同声明的未命名类型被视为同一类型。</span><br><span class="line"></span><br><span class="line">• 具有相同基类型的指针。</span><br><span class="line">• 具有相同元素类型和长度的 array。</span><br><span class="line">• 具有相同元素类型的 slice。</span><br><span class="line">• 具有相同键值类型的 map。</span><br><span class="line">• 具有相同元素类型和传送方向的 channel。</span><br><span class="line">• 具有相同字段序列 (字段名、类型、标签、顺序) 的匿名 struct。 </span><br><span class="line">• 签名相同 (参数和返回值，不包括参数名称) 的 function。</span><br><span class="line">• 方法集相同 ( 方法名、方法签名相同，和次序无关) 的 interface。</span><br></pre></td></tr></table></figure></li><li><p>struct 特点：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 用来自定义复杂数据结构</span><br><span class="line">2. struct里面可以包含多个字段（属性）</span><br><span class="line">3. struct类型可以定义方法，注意和函数的区分</span><br><span class="line">4. struct类型是值类型</span><br><span class="line">5. struct类型可以嵌套</span><br><span class="line">6. Go语言没有class类型，只有struct类型</span><br><span class="line">7. 结构体是用户单独定义的类型，不能和其他类型进行强制转换</span><br><span class="line">8. golang中的struct没有构造函数，一般可以使用工厂模式来解决这个问题。</span><br><span class="line">9. 我们可以为struct中的每个字段，写上一个tag。这个tag可以通过反射的机制获取到，最常用的场景就是json序列化和反序列化。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>可以理解为面向对象编程</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct声明及初始化：</span><br><span class="line"></span><br><span class="line">声明：</span><br><span class="line"></span><br><span class="line">type typeName struct &#123;  </span><br><span class="line">//...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">type global struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    type local struct&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">初始化：</span><br><span class="line"></span><br><span class="line">方法有几种：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Test struct &#123;</span><br><span class="line">    int</span><br><span class="line">    string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a Test</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    b := new(Test) //同 var b *Test = new(Test)</span><br><span class="line">    c := Test&#123;1, &quot;c&quot;&#125;</span><br><span class="line">    d := Test&#123;&#125;</span><br><span class="line">    e := &amp;Test&#123;&#125;</span><br><span class="line">    f := &amp;Test&#123;2, &quot;f&quot;&#125; //同 var d *Test = &amp;Test&#123;2, &quot;f&quot;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(a, b, c, d, e, f)</span><br><span class="line">    // 注: a b c d 返回 Test 类型变量；e f 返回 *Test 类型变量；若无初始化值，则默认为零值</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">&#123;0 &#125; &amp;&#123;0 &#125; &#123;1 c&#125; &#123;0 &#125; &amp;&#123;0 &#125; &amp;&#123;2 f&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化值可以分为两种</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">a. 有序: typeName&#123;value1, value2, ...&#125; 必须一一对应</span><br><span class="line">b. 无序: typeName&#123;field1:value1, field2:value2, ...&#125; 可初始化部分值</span><br><span class="line"></span><br><span class="line">栗子：</span><br><span class="line"></span><br><span class="line">a：有序</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age int</span><br><span class="line">    sex int</span><br><span class="line">    phone int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    person := Person&#123;&quot;lff&quot;, 23, 1, 18135479521&#125;</span><br><span class="line">    fmt.Println(person)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b： 无序</span><br><span class="line">func main() &#123;</span><br><span class="line">    p2 := Person&#123;age: 23&#125; //无序，指你可以指定给p2赋哪个字段的值</span><br><span class="line">    fmt.Println(person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>操作 struct </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">声明的struct与普通类型一样</span><br><span class="line">访问结构体中的一个变量名, 用 &quot;.&quot; 来连接:</span><br><span class="line">varName.field 或 (*varName).field</span><br><span class="line">如操作上面 Person 结构体中的 age : p.age = 35</span><br><span class="line">也可以作为函数中的参数，返回值类型</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">举个栗子：</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//1. 声明一个自定义类型名为 Person 的结构体</span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    //2. 初始化</span><br><span class="line">    var p1 Person</span><br><span class="line">    p2 := Person&#123;&#125;</span><br><span class="line">    p3 := Person&#123;&quot;James&quot;, 23&#125;</span><br><span class="line">    p4 := Person&#123;age: 23&#125;</span><br><span class="line">    fmt.Println(p1, p2, p3, p4)</span><br><span class="line">    p5 := new(Person)</span><br><span class="line">    p6 := &amp;Person&#123;&#125;</span><br><span class="line">    p7 := &amp;Person&#123;&quot;James&quot;, 23&#125;</span><br><span class="line">    p8 := &amp;Person&#123;age: 23&#125;</span><br><span class="line">    fmt.Println(p5, p6, p7, p8)</span><br><span class="line"></span><br><span class="line">    //3. 操作</span><br><span class="line">    p1.age = 50</span><br><span class="line">    p2.age = 25</span><br><span class="line">    if compareAge(p1, p2) &#123;</span><br><span class="line">        fmt.Println(&quot;p1 is older than p2&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;p2 is older than p1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func compareAge(p1, p2 Person) bool &#123;</span><br><span class="line">    if p1.age &gt; p2.age &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&#123; 0&#125; &#123; 0&#125; &#123;James 23&#125; &#123; 23&#125;</span><br><span class="line">&amp;&#123; 0&#125; &amp;&#123; 0&#125; &amp;&#123;James 23&#125; &amp;&#123; 23&#125;</span><br><span class="line">p1 is older than p2</span><br></pre></td></tr></table></figure></li><li><p>匿名字段</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">匿名字段：</span><br><span class="line">声明一个 struct1 可以包含已经存在的 struct2 或者go语言中内置类型作为内置字段，称为匿名字段，即只写了 typeName，无 varName，但是 typeName 不能重复。</span><br><span class="line"></span><br><span class="line">匿名字段与面向对象程序语言中的继承</span><br><span class="line"></span><br><span class="line">声明及初始化:</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">    addr string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">    Person //匿名字段</span><br><span class="line">    salary int</span><br><span class="line">    int           //用内置类型作为匿名字段</span><br><span class="line">    addr   string //类似于重载</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    em1 := Employee&#123;Person&#123;&quot;rain&quot;, 23, &quot;qingyangqu&quot;&#125;, 5000, 100, &quot;gaoxingqu&quot;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(em1)</span><br><span class="line">    // var em2 Person = em1</span><br><span class="line">    // Error: cannot use em1 (type Employee) as type Person in assignment （没有继承， 然也不会有多态）</span><br><span class="line"></span><br><span class="line">    var em2 Person = em1.Person // 同类型拷贝。</span><br><span class="line"></span><br><span class="line">    fmt.Println(em2)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">&#123;&#123;Murphy 23 帝都&#125; 5000 100 北京&#125;</span><br><span class="line">&#123;Murphy 23 帝都&#125;</span><br><span class="line">操作</span><br><span class="line"></span><br><span class="line">访问方式也是通过 &quot;.&quot; 来连接</span><br><span class="line">相同字段采用最外层优先访问，类似于重载</span><br><span class="line">em1.addr 访问的是 Employee 中最外层的 addr</span><br><span class="line">em1.Person.addr 访问的是 Employee 中 Person 中的 addr</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">    addr string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">    Person //匿名字段</span><br><span class="line">    salary int</span><br><span class="line">    int           //用内置类型作为匿名字段</span><br><span class="line">    addr   string //类似于重载</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    /*</span><br><span class="line">    var em1 Employee = Employee&#123;&#125;</span><br><span class="line">    em1.Person = Person&#123;&quot;rain&quot;, 23, &quot;帝都&quot;&#125;</span><br><span class="line">    em1.salary = 5000</span><br><span class="line">    em1.int = 100 //使用时注意其意义，此处无</span><br><span class="line">    em1.addr = &quot;北京&quot;</span><br><span class="line">    */</span><br><span class="line">    //em1 := Employee&#123;Person&#123;&quot;rain&quot;, 23, &quot;帝都&quot;&#125;, 5000, 100, &quot;北京&quot;&#125;</span><br><span class="line">    //初始化方式不一样，但是结果一样</span><br><span class="line">    em1 := Employee&#123;Person: Person&#123;&quot;Murphy&quot;, 23, &quot;帝都&quot;&#125;, salary: 5000, int: 100, addr: &quot;北京&quot;&#125;</span><br><span class="line">    fmt.Println(em1)</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;live addr(em1.addr) = &quot;, em1.addr)</span><br><span class="line">    fmt.Println(&quot;work addr(em1.Person.addr) = &quot;, em1.Person.addr)</span><br><span class="line">    em1.int = 200 //修改匿名字段的值</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&#123;&#123;Murphy 23 帝都&#125; 5000 100 北京&#125;</span><br><span class="line">live addr(em1.addr) =  北京</span><br><span class="line">work addr(em1.Person.addr) =  帝都</span><br><span class="line">空结构 &quot;节省&quot; 内存， 如用来实现 set 数据结构，或者实现没有 &quot;状态&quot; 只有方法的 &quot;静态类&quot;。</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var null struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">    set := make(map[string]struct&#123;&#125;)</span><br><span class="line">    set[&quot;a&quot;] = null</span><br><span class="line">&#125;</span><br><span class="line">不能同时嵌入某一类型和其指针类型，因为它们名字相同。</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Resource struct &#123;</span><br><span class="line">    id int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">    *Resource</span><br><span class="line">    // Resource // Error: duplicate field Resource</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    u := User&#123;</span><br><span class="line">        &amp;Resource&#123;1&#125;,</span><br><span class="line">        &quot;Administrator&quot;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(u.id)</span><br><span class="line">    println(u.Resource.id)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Go-向函数传递指针参数&quot;&gt;&lt;a href=&quot;#Go-向函数传递指针参数&quot; class=&quot;headerlink&quot; title=&quot;Go 向函数传递指针参数&quot;&gt;&lt;/a&gt;Go 向函数传递指针参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Go 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import &amp;quot;fmt&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func main() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 定义局部变量 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var a int = 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var b int = 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Printf(&amp;quot;交换前 a 的值 : %d\n&amp;quot;, a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Printf(&amp;quot;交换前 b 的值 : %d\n&amp;quot;, b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 调用函数用于交换值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    * &amp;amp;a 指向 a 变量的地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    * &amp;amp;b 指向 b 变量的地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    swap(&amp;amp;a, &amp;amp;b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Printf(&amp;quot;交换后 a 的值 : %d\n&amp;quot;, a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Printf(&amp;quot;交换后 b 的值 : %d\n&amp;quot;, b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func swap(x *int, y *int) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var temp int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    temp = *x /* 保存 x 地址的值 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *x = *y   /* 将 y 赋值给 x */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *y = temp /* 将 temp 赋值给 y */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出结果：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;交换前 a 的值 : 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;交换前 b 的值 : 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;交换后 a 的值 : 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;交换后 b 的值 : 100&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="go" scheme="http://ymliang.com/categories/go/"/>
    
    
      <category term="go" scheme="http://ymliang.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go开发基础入门——2</title>
    <link href="http://ymliang.com/Go%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942.html"/>
    <id>http://ymliang.com/Go开发基础入门——2.html</id>
    <published>2019-06-04T09:42:56.000Z</published>
    <updated>2019-09-09T10:01:28.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   通过类型前置加一个圆括号</span><br><span class="line">   T(表达式)</span><br><span class="line">   T表示要转化的类型，表达式包括：变量，数值，函数返回值等</span><br><span class="line">   int(8.2)</span><br><span class="line">   int(80.5)</span><br><span class="line">   布尔型无法与其他类型转换</span><br><span class="line"></span><br><span class="line">   int转换为string OK</span><br><span class="line">   string转换为int NO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   eg:</span><br><span class="line">   chinese := 90</span><br><span class="line">english := 90.9</span><br><span class="line">result := string(chinese)</span><br><span class="line"></span><br><span class="line">fmt.Println(chinese,english,result)</span><br><span class="line">   </span><br><span class="line">   90 90.9 Z</span><br></pre></td></tr></table></figure></code></pre><a id="more"></a><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">常量是一个简单值的标识符，在程序运行时，不会被修改的量。</span><br><span class="line"></span><br><span class="line">常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</span><br><span class="line"></span><br><span class="line">常量的定义格式：</span><br><span class="line">const identifier [type] = value</span><br><span class="line"></span><br><span class="line">你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</span><br><span class="line">显式类型定义： const b string = &quot;abc&quot;</span><br><span class="line">隐式类型定义： const b = &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">多个相同类型的声明可以简写为：</span><br><span class="line">const c_name1, c_name2 = value1, value2</span><br><span class="line"></span><br><span class="line">常量用于枚举(常量组)：</span><br><span class="line">也可以使用 const()定义块，定义多个，每个常量单独一行，例如</span><br><span class="line">const (</span><br><span class="line">  c6 = 42</span><br><span class="line">  c7 = 1000</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const()块定义时，如果常量未给出定义，则延续上面的定义规则，例如：</span><br><span class="line">const (</span><br><span class="line">  c7 = 42</span><br><span class="line">  c8 // c8 = 42</span><br><span class="line">  c9 // c9 = 42</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">iota迭代定义常量：</span><br><span class="line">const配合iota关键字使用，可以定义一组由0开始+1迭代的常量 演示语法：</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  gender_secret = iota</span><br><span class="line">  gender_male // = iota</span><br><span class="line">  gender_female // = iota</span><br><span class="line">)</span><br><span class="line">此时，三个常量值，分别是,0, 1, 2 iota的规则是：若iota出现在const()中，那么const()定义的第一行的iota就是0，第二行就是0+1=1，不论iota是否被常量使用。演示如下：</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  c1 = 42 // iota = 0，虽然未使用iota，但后边（const()中）有使用，此时iota被初始化为0，下面每行累加1</span><br><span class="line">  c2 = iota      // iota = 1，iota继续累加，使用了iota</span><br><span class="line">  c3 = 1024      // iota = 2，同样未使用，但iota的值继续累加。c3 被定义为1024</span><br><span class="line">  c4             // iota = 3，c4延续上面的定义c4=1024，iota继续累加</span><br><span class="line">  c5 = iota      // iota = 4，iota继续累加，使用了iota</span><br><span class="line">  c6 = iota      // iota = 5，iota继续累加，使用了iota</span><br><span class="line">)</span><br><span class="line">此时结果为：42, 1, 1024, 1024, 4, 5</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>func 和 JavaScript中定义类似 定义之后在main中来调用，流程很好理解</p><ul><li><p>Go中函数为一等公民：</p><ol><li>函数本身可以作为值来传递</li><li>支持匿名函数和闭包</li><li>函数可以满足接口</li></ol></li><li><p>如何声明函数(函数定义)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> func 函数名 (参数列表) (返回值参数列表)&#123;</span><br><span class="line">   //函数体</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> 参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数</span><br><span class="line"> 返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</span><br><span class="line"></span><br><span class="line"> 这里以一个加法的栗子说明：</span><br><span class="line"></span><br><span class="line"> func add (a int,b int) int &#123;</span><br><span class="line">   var sum int = a + b</span><br><span class="line"> return sum</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> func main() &#123;</span><br><span class="line">   //函数调用</span><br><span class="line">   cd := add(10,20)</span><br><span class="line">   fmt.Println(cd)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> 输出：30</span><br><span class="line"></span><br><span class="line"> 下面再来写一个有多个返回值的</span><br><span class="line"> func add(a int, b int) (int,string)&#123;</span><br><span class="line">var sum int = a + b</span><br><span class="line">str := strconv.Itoa(a)</span><br><span class="line">return sum,str</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> func main() &#123;</span><br><span class="line"> cd,str := add(100,200)</span><br><span class="line">fmt.Println(&quot;cd值为：&quot;,cd,str)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> 输出：cd值为： 300 100</span><br><span class="line"></span><br><span class="line"> 如果一个函数有多个返回值而你只想要其中的一个或几个，那么你不想要的返回值可以用下划线：_ 替代，也就是匿名变量</span><br><span class="line"></span><br><span class="line"> eg:</span><br><span class="line"> cd, str := add(100,200)</span><br><span class="line"> 此时不想要str 则改为：</span><br><span class="line"> cd, _ := add(100,200)</span><br></pre></td></tr></table></figure></li><li><p>变量的作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Go语言变量再三个地方声明：</span><br><span class="line">1. 函数内——局部变量</span><br><span class="line">2. 函数外——全局变量</span><br><span class="line">3. 函数中——形式参数</span><br><span class="line"></span><br><span class="line">与java定义类似不多解释</span><br></pre></td></tr></table></figure></li><li><p>Go 语言指针</p><p>• 默认值 nil，没有 NULL 常量。<br>• 操作符 “&amp;” （取地址符） 取变量地址，”*” （取值符）透过指针访问目标对象。<br>• 不支持指针运算，不支持 “-&gt;” 运算符，直接用 “.” 访问目标成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Go 支持指针。指针是保存值的地址的地方。 一个指针用 * 定义 </span><br><span class="line">指针声明：</span><br><span class="line"></span><br><span class="line">var name *类型</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">var ip *int     /* 指向整型*/ //声明一个int值得指针变量</span><br><span class="line">var fp *float32 /* 指向浮点型 */</span><br><span class="line">var sp *string  /* 指向字符串类型 */</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">根据数据类型定义指针。 例：</span><br><span class="line"></span><br><span class="line">var ap *int</span><br><span class="line">上面的  ap  是指向整数类型的指针。＆ 运算符可用于获取变量的地址。</span><br><span class="line"></span><br><span class="line">a := 12</span><br><span class="line">ap = &amp;a</span><br><span class="line">可以使用 * 运算符访问指针指向的值：</span><br><span class="line"></span><br><span class="line">fmt.Println(*ap)</span><br><span class="line">// =&gt; 12</span><br><span class="line"></span><br><span class="line">如何使用指针？</span><br><span class="line"></span><br><span class="line">指针使用流程：</span><br><span class="line">定义指针变量。</span><br><span class="line">为指针变量赋值。</span><br><span class="line">访问指针变量中指向地址的值。</span><br><span class="line">在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</span><br></pre></td></tr></table></figure></li><li><p>举个栗子</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var a int = 20 /* 声明实际变量 */</span><br><span class="line">  var ip *int    /* 声明指针变量 */</span><br><span class="line"></span><br><span class="line">  ip = &amp;a /* 指针变量的存储地址 */</span><br><span class="line"></span><br><span class="line">  fmt.Printf(&quot;a 变量的地址是: %x\n&quot;, &amp;a)</span><br><span class="line"></span><br><span class="line">  /* 指针变量的存储地址 */</span><br><span class="line">  fmt.Printf(&quot;ip 变量的存储地址: %x\n&quot;, ip)</span><br><span class="line"></span><br><span class="line">  /* 使用指针访问值 */</span><br><span class="line">  fmt.Printf(&quot;*ip 变量的值: %d\n&quot;, *ip)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">a 变量的地址是: c420012058</span><br><span class="line">ip 变量的存储地址: c420012058</span><br><span class="line">*ip 变量的值: 20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在将结构体作为参数传递或者为已定义类型声明方法时，通常首选指针。</span><br><span class="line"></span><br><span class="line">传递值时，实际复制的值意味着更多的内存</span><br><span class="line">传递指针后，函数更改的值将反映在方法 / 函数调用者中。</span><br><span class="line">例子:</span><br><span class="line">func increment(i *int) &#123;</span><br><span class="line">  *i++</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">  i := 10</span><br><span class="line">  increment(&amp;i)</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">//=&gt; 11</span><br><span class="line"></span><br><span class="line">上面那个栗子表示将i 用指针的形式再函数中加1，更改了i本身的值</span><br></pre></td></tr></table></figure><ul><li><p>直接用指针访问目标对象成员：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">直接用指针访问目标对象成员：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  type data struct&#123; a int &#125;</span><br><span class="line"></span><br><span class="line">  var d = data&#123;1234&#125;</span><br><span class="line">  var p *data</span><br><span class="line"></span><br><span class="line">  p = &amp;d</span><br><span class="line">  fmt.Printf(&quot;%p, %v\n&quot;, p, p.a) // 直接用指针访问目标对象成员，无须转换。</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line"></span><br><span class="line">0xc420012058, 1234</span><br><span class="line"></span><br><span class="line">这种 .a 的形式有点类似于java中对象.变量的感觉，很熟悉，这样理解会方便一些</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1. 不能对指针做加减法等运算。</span><br><span class="line">2. 可以在 unsafe.Pointer 和任意类型指针间进 转换。</span><br><span class="line">3. 将 Pointer 转换成 uintptr，可变相实现指针运算。</span><br></pre></td></tr></table></figure></li></ul><h3 id="Go-空指针-nil"><a href="#Go-空指针-nil" class="headerlink" title="Go 空指针 nil"></a>Go 空指针 nil</h3><ul><li><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">nil 指针也称为空指针。</span><br><span class="line"></span><br><span class="line">nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</span><br><span class="line"></span><br><span class="line">一个指针变量通常缩写为 ptr 即 Pointer。</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var ptr *int</span><br><span class="line">  /* %x 指十六进制，小写字母，每字节两个字符*/</span><br><span class="line">  fmt.Printf(&quot;ptr 的值为 : %x\n&quot;, ptr)</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">ptr 的值为 : 0</span><br></pre></td></tr></table></figure></li><li><p>空指针判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var ptr1 *int</span><br><span class="line">  var i int = 1</span><br><span class="line">  ptr2 := &amp;i</span><br><span class="line">  if ptr1 == nil &#123; </span><br><span class="line">    fmt.Println(&quot;prt1 是空指针&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  if ptr2 != nil &#123; </span><br><span class="line">    fmt.Println(&quot;prt2 不是空指针 值为：&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">prt1 是空指针</span><br><span class="line">prt2 不是空指针</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">指针记录到这里我稍微总结一下：</span><br><span class="line"></span><br><span class="line">和C语言中指针类似，存储的是变量的地址值，我们无法直接给指针变量赋值</span><br><span class="line">但是我们先定义一个变量之后将其地址取出： 如何取？  用 &amp; 取   &amp;变量</span><br><span class="line">取出后我们把将要赋值的指针地址指向这个变量  ptr = &amp;变量</span><br><span class="line">这样就实现了给指针赋值 之后 *ptr 就可取出指针的值</span><br></pre></td></tr></table></figure><pre><code>请大家记住这个步骤：1. 指针声明格式如下：var name *类型2. 如何使用指针？指针使用流程：定义指针变量。为指针变量赋值。访问指针变量中指向地址的值。在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</code></pre></li></ul><h3 id="Go-指针数组"><a href="#Go-指针数组" class="headerlink" title="Go 指针数组"></a>Go 指针数组</h3><ul><li><p>声明指针数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">var ptr [MAX]*int;</span><br><span class="line">ptr 为整型指针数组。因此每个元素都指向了一个值。以下实例的三个整数将存储在指针数组中：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">const MAX int = 3</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  a := []int&#123;9, 99, 999&#125;</span><br><span class="line">  var i int</span><br><span class="line">  var ptr [MAX]*int</span><br><span class="line"></span><br><span class="line">  for i = 0; i &lt; MAX; i++ &#123;</span><br><span class="line">    ptr[i] = &amp;a[i] /* 整数地址赋值给指针数组 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for i = 0; i &lt; MAX; i++ &#123;</span><br><span class="line">    fmt.Printf(&quot;a[%d] = %d\n&quot;, i, *ptr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">a[0] = 9</span><br><span class="line">a[1] = 99</span><br><span class="line">a[2] = 999</span><br><span class="line"></span><br><span class="line">如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</span><br><span class="line">当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：</span><br><span class="line"></span><br><span class="line">指向指针的指针变量声明格式如下：</span><br><span class="line"></span><br><span class="line">var ptr **int</span><br><span class="line">以上指向指针的指针变量为整型。</span><br><span class="line">访问指向指针的指针变量值需要使用两个 * 号，如下所示：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">  var a int</span><br><span class="line">  var ptr *int</span><br><span class="line">  var pptr **int</span><br><span class="line"></span><br><span class="line">  a = 3000</span><br><span class="line"></span><br><span class="line">  /* 指针 ptr 地址 */</span><br><span class="line">  ptr = &amp;a</span><br><span class="line"></span><br><span class="line">  /* 指向指针 ptr 地址 */</span><br><span class="line">  pptr = &amp;ptr</span><br><span class="line"></span><br><span class="line">  /* 获取 pptr 的值 */</span><br><span class="line">  fmt.Printf(&quot;变量 a = %d\n&quot;, a)</span><br><span class="line">  fmt.Printf(&quot;指针变量 *ptr = %d\n&quot;, *ptr)</span><br><span class="line">  fmt.Printf(&quot;指向指针的指针变量 **pptr = %d\n&quot;, **pptr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">变量 a = 3000</span><br><span class="line">指针变量 *ptr = 3000</span><br><span class="line">指向指针的指针变量 **pptr = 3000</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>请关注我的<a href="https://ymliang.netlify.com/about/" target="_blank" rel="noopener">个人博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据类型转换&quot;&gt;&lt;a href=&quot;#数据类型转换&quot; class=&quot;headerlink&quot; title=&quot;数据类型转换&quot;&gt;&lt;/a&gt;数据类型转换&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   通过类型前置加一个圆括号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   T(表达式)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   T表示要转化的类型，表达式包括：变量，数值，函数返回值等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int(8.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int(80.5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   布尔型无法与其他类型转换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int转换为string OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   string转换为int NO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   eg:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   chinese := 90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;english := 90.9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;result := string(chinese)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Println(chinese,english,result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   90 90.9 Z&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="go" scheme="http://ymliang.com/categories/go/"/>
    
    
      <category term="go" scheme="http://ymliang.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go开发基础入门</title>
    <link href="http://ymliang.com/Go%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html"/>
    <id>http://ymliang.com/Go开发基础入门.html</id>
    <published>2019-06-04T08:46:10.000Z</published>
    <updated>2019-06-10T07:38:05.806Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>请关注我的<a href="https://ymliang.netlify.com/about/" target="_blank" rel="noopener">个人博客</a></p></blockquote><h2 id="Go开发入门"><a href="#Go开发入门" class="headerlink" title="Go开发入门"></a>Go开发入门</h2><h3 id="变量的定义，赋值"><a href="#变量的定义，赋值" class="headerlink" title="变量的定义，赋值"></a>变量的定义，赋值</h3><p>变量声明：Go的变量名首字母不能为数字</p><ul><li><p>未初始化的变量声明：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   var 变量名 变量类型</span><br><span class="line">var a int               // 声明 int 类型的变量</span><br><span class="line">var b [10] int          // 声明 int 类型数组</span><br><span class="line">var c []int             // 声明 int 类型的切片 [] 内赋初值是数组，不赋值是切片</span><br><span class="line">var d *int              // 声明 int 类型的指针</span><br><span class="line">   打印结果为</span><br><span class="line"></span><br><span class="line">   //a=&#123;0&#125;,b=&#123;[0 0 0 0 0 0 0 0 0 0]&#125;,c=&#123;[]&#125;,d=&#123;&lt;nil&gt;&#125;</span><br><span class="line"></span><br><span class="line">   那么未初始化的变量默认值为：</span><br><span class="line"></span><br><span class="line">   整型和浮点型变量： 0</span><br><span class="line">   字符串： 0</span><br><span class="line">   布尔： false</span><br><span class="line">   函数，指针： nil</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>初始化的变量声明：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 变量类型 = 表达式</span><br><span class="line">var a int = 10</span><br><span class="line"></span><br><span class="line">//编译器自动推断格式</span><br><span class="line">var 变量名 = 表达式</span><br><span class="line"></span><br><span class="line">//简短声明格式(短变量声明格式)</span><br><span class="line">变量名 := 表达式</span><br><span class="line"></span><br><span class="line">:= 可以高效的创建新变量，在内存中开辟空间</span><br><span class="line">var 省略</span><br><span class="line">编译器自动推断类型</span><br><span class="line">声明变量首选这种形式</span><br><span class="line">只能用在函数体内，不能作为全局变量来声明</span><br><span class="line">变量名不能是被定义过的，不然会报错</span><br></pre></td></tr></table></figure></li><li><p>变量多重赋值</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go可以进行多变量赋值，变量与变量之间逗号隔开</span><br><span class="line">a, b, c, d := 1, 2, true, &quot;def&quot;</span><br><span class="line">fmt.Printf(&quot;a=&#123;%d&#125;,b=&#123;%d&#125;,c=&#123;%v&#125;,d=&#123;%v&#125; \n&quot;, a, b, c, d)</span><br><span class="line"></span><br><span class="line">a, b = b, a // a,b互换位置</span><br></pre></td></tr></table></figure><ul><li><p>匿名变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要用于函数返回值，返回我们需要的字段</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>布尔型<br>布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</li><li>数字类型<br>整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</li><li>字符串类型:<br>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</li><li>派生类型:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">包括：</span><br><span class="line">(a) 指针类型（Pointer）</span><br><span class="line">(b) 数组类型</span><br><span class="line">(c) 结构化类型(struct)</span><br><span class="line">(d) Channel 类型</span><br><span class="line">(e) 函数类型</span><br><span class="line">(f) 切片类型</span><br><span class="line">(g) 接口类型（interface）</span><br><span class="line">(h) Map 类型</span><br></pre></td></tr></table></figure></li></ul><p>更详细的可以参考<a href="https://www.cnblogs.com/fengbohello/p/5854108.html" target="_blank" rel="noopener">这篇博文</a>，写的非常详细</p><h3 id="格式化输出语句"><a href="#格式化输出语句" class="headerlink" title="格式化输出语句"></a>格式化输出语句</h3><ul><li><p>通用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%v value，值的默认表示</span><br><span class="line">%+v 类似%v，但输出结构体时会添加字段名</span><br><span class="line">%#v 值的 Go 语法表示</span><br><span class="line">%T 值的数据类型Go语法表示，如： int , string等</span><br></pre></td></tr></table></figure></li><li><p>布尔</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%t true或false</span><br></pre></td></tr></table></figure></li><li><p>整数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%b     二进制表示 </span><br><span class="line">%c     相应Unicode码点所表示的字符 </span><br><span class="line">%d     十进制表示 </span><br><span class="line">%8d    整形长度为8，不足8则在数值前补空格 超出以实际为准</span><br><span class="line">%08d   数字长度是8，不足8位的，数字前补0 超出以实际为准</span><br><span class="line">%o     八进制表示 </span><br><span class="line">%q     单引号围绕的字符字面值，由Go语法安全地转义 </span><br><span class="line">%x     十六进制表示，字母形式为小写 a-f </span><br><span class="line">%X     十六进制表示，字母形式为大写 A-F </span><br><span class="line">%U     Unicode格式：U+1234，等同于 &quot;U+%04X&quot;</span><br></pre></td></tr></table></figure></li><li><p>浮点,复数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%b     无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat中的 &apos;b&apos; 转换格式一致。例如 -123456p-78 </span><br><span class="line">%e     科学计数法，例如 -1234.456e+78 </span><br><span class="line">%E     科学计数法，例如 -1234.456E+78 </span><br><span class="line">%f     有小数点而无指数，例如 123.456 </span><br><span class="line">%g     根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 </span><br><span class="line">%G     根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</span><br></pre></td></tr></table></figure></li><li><p>字符串和bytes的slice表示：</p>  <figure class="highlight plain"><figcaption><span>字符串或切片的无解译字节 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%q     双引号围绕的字符串，由Go语法安全地转义 </span><br><span class="line">%x     十六进制，小写字母，每字节两个字符 </span><br><span class="line">%X     十六进制，大写字母，每字节两个字符</span><br></pre></td></tr></table></figure></li><li><p>指针：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%p     十六进制表示，前缀 0x</span><br><span class="line">这里没有 &apos;u&apos; 标记。若整数为无符号类型，他们就会被打印成无符号的。类似地，这里也不需要指定操作数的大小（int8，int64）。</span><br><span class="line"></span><br><span class="line">对于％ｖ来说默认的格式是：</span><br><span class="line">bool:                    %t </span><br><span class="line">int, int8 etc.:          %d </span><br><span class="line">uint, uint8 etc.:        %d, %x if printed with %#v</span><br><span class="line">float32, complex64, etc: %g</span><br><span class="line">string:                  %s</span><br><span class="line">chan:                    %p </span><br><span class="line">pointer:                 %p</span><br><span class="line">由此可以看出，默认的输出格式可以使用%v进行指定，除非输出其他与默认不同的格式，否则都可以使用%v进行替代（但是不推荐使用）</span><br></pre></td></tr></table></figure></li><li><p>对于复合对象:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">里面的元素使用如下规则进行打印：</span><br><span class="line">struct:            &#123;field0 field1 ...&#125; </span><br><span class="line">array, slice:      [elem0 elem1 ...] </span><br><span class="line">maps:              map[key1:value1 key2:value2] </span><br><span class="line">pointer to above:  &amp;&#123;&#125;, &amp;[], &amp;map[]</span><br></pre></td></tr></table></figure></li><li><p>宽度和精度：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">宽度是在％之后的值，如果没有指定，则使用该值的默认值，精度是跟在宽度之后的值，如果没有指定，也是使用要打印的值的默认精度．例如：％９.２f，宽度９，精度２</span><br><span class="line"></span><br><span class="line">%f:      default width, default precision </span><br><span class="line">%9f      width 9, default precision </span><br><span class="line">%.2f     default width, precision 2 </span><br><span class="line">%9.2f    width 9, precision 2 </span><br><span class="line">%9.f     width 9, precision 0</span><br></pre></td></tr></table></figure></li></ul><p>这里有一些<a href="https://blog.csdn.net/qq_34777600/article/details/81266453" target="_blank" rel="noopener">练习</a></p><blockquote><p>弟弟从事java开发，学习go纯属个人爱好，喜欢go的语法和特点，点击这里移步我的<a href="https://ymliang.netlify.com/" target="_blank" rel="noopener">个人博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;请关注我的&lt;a href=&quot;https://ymliang.netlify.com/about/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Go开发入门&quot;&gt;&lt;a href=&quot;#Go开发入门&quot; class=&quot;headerlink&quot; title=&quot;Go开发入门&quot;&gt;&lt;/a&gt;Go开发入门&lt;/h2&gt;&lt;h3 id=&quot;变量的定义，赋值&quot;&gt;&lt;a href=&quot;#变量的定义，赋值&quot; class=&quot;headerlink&quot; title=&quot;变量的定义，赋值&quot;&gt;&lt;/a&gt;变量的定义，赋值&lt;/h3&gt;&lt;p&gt;变量声明：Go的变量名首字母不能为数字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;未初始化的变量声明：&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   var 变量名 变量类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a int               // 声明 int 类型的变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var b [10] int          // 声明 int 类型数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var c []int             // 声明 int 类型的切片 [] 内赋初值是数组，不赋值是切片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var d *int              // 声明 int 类型的指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   打印结果为&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   //a=&amp;#123;0&amp;#125;,b=&amp;#123;[0 0 0 0 0 0 0 0 0 0]&amp;#125;,c=&amp;#123;[]&amp;#125;,d=&amp;#123;&amp;lt;nil&amp;gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   那么未初始化的变量默认值为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   整型和浮点型变量： 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   字符串： 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   布尔： false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   函数，指针： nil&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Golang-Web编程</title>
    <link href="http://ymliang.com/Golang-Web%E7%BC%96%E7%A8%8B.html"/>
    <id>http://ymliang.com/Golang-Web编程.html</id>
    <published>2019-06-03T02:27:17.000Z</published>
    <updated>2019-06-03T02:27:17.947Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>beego框架搭建踩坑</title>
    <link href="http://ymliang.com/beego%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91.html"/>
    <id>http://ymliang.com/beego框架搭建踩坑.html</id>
    <published>2019-05-30T05:39:38.000Z</published>
    <updated>2019-07-29T03:21:59.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是beego"><a href="#什么是beego" class="headerlink" title="什么是beego"></a>什么是beego</h3><pre><code>一个框架：可以理解为Golang的MVC框架四个特点：简单化、智能化、模块化、高性能具体好处去官网自行浏览</code></pre><p><a href="https://beego.me/" target="_blank" rel="noopener">官网传送门</a></p><a id="more"></a><h3 id="踩坑之前先安装一下Golang"><a href="#踩坑之前先安装一下Golang" class="headerlink" title="踩坑之前先安装一下Golang"></a>踩坑之前先安装一下Golang</h3><pre><code>1. 找go的官网下载 https://studygolang.com/articles/6165 windows下载后缀为msi的文件，之后傻瓜式安装2. 配置GOROOT和GPATH环境变量    https://studygolang.com/articles/6165 这里有除了这两个以外还有Path中:    F:\Go\bin   %GOPATH%\bin3. 之后输入go,go version,和go env来看一下    go env 看一下GOPATH的路径改变了没有，如果没有改变在你系统环境变量的上方有个你个人用户的环境变量，重复配置一下GOPATH如果还是不生效    百度搜 &quot;windows10配置GOPATH不生效的解决方案&quot; 4. IDE选择 ： goland 好不好用去试试，可以换主题   主题传送门：https://blog.csdn.net/qq_31339365/article/details/78323153   安装过程中可能遇到的问题：越狱问题传送门：https://blog.csdn.net/u014044812/article/details/876211685. 之后测试一个小demo即可Goland的目录结构GOPATH：    bin:    pkg:    src: 项目名:            main.go</code></pre><h3 id="beego框架安装"><a href="#beego框架安装" class="headerlink" title="beego框架安装"></a>beego框架安装</h3><pre><code>beego 包含一些示例应用程序以帮您学习并使用 beego 应用框架。您需要安装 Go 1.1+ 以确保所有功能的正常使用。你需要安装或者升级 Beego 和 Bee 的开发工具:命令在你的GOPATH下输入go get github.com/astaxie/beegogo get -u github.com/beego/bee为了更加方便的操作，请将 $GOPATH/bin 加入到你的 $PATH 变量中。请确保在此之前您已经添加了 $GOPATH 变量。 windows下只需要$path里面配了 %GOPATH%\bin 即可检测是否安装：1. 在你GOPATH/src 输入 bee new 你的项目名称2. cd 你的项目名称3. bee run之后访问 localhost:8080 出现下图即搭建成功</code></pre><p><img src="/images/beego/beego1.png" alt="beego搭建"></p><pre><code>接着可以实现一个小的功能体验一下MVC架构1. 用goland打开你的项目</code></pre><p><img src="/images/beego/beego2.png" alt="beego搭建"></p><pre><code>项目结构后面会出文章解释，先简单了解一下，这里我们主要了解一下controllers和routers先看一下写法：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package controllers</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/astaxie/beego&quot;</span><br><span class="line">)</span><br><span class="line">//声明了一个控制器 HelloController</span><br><span class="line">//这个控制器里面内嵌了beego.Controller这就是Go的嵌入方式</span><br><span class="line">//也就是HelloController自动拥有了所有 beego.Controller 的方法</span><br><span class="line">//这类似于面向对象里的继承</span><br><span class="line"></span><br><span class="line">type HelloController struct &#123;</span><br><span class="line">beego.Controller //这里相当于继承beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//而beego.Controller拥有很多方法</span><br><span class="line">//其中包括Init、Prepare、Post、Get、Delete、Head等方法</span><br><span class="line">//我们可以通过重写的方式来实现这些方法，而我们下面的代码就是重写了Get方法。</span><br><span class="line">//重写Get方法</span><br><span class="line">func (hello *HelloController) Get() &#123;</span><br><span class="line">hello.Ctx.WriteString(&quot;hello go&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这里写了一个hello.go 的 controller那么上面的代码到底做了些什么呢？首先我们导入了包 github.com/astaxie/beego。我们知道 Go 语言里面被导入的包会按照深度优先的顺序去执行导入包的初始化（变量和 init 函数，更多详情），beego 包中会初始化一个 BeeAPP 的应用和一些参数。定义 Controller，这里我们定义了一个 struct 为 HelloController，充分利用了 Go 语言的组合的概念，匿名包含了 beego.Controller，这样我们的 HelloController 就拥有了 beego.Controller 的所有方法。定义 RESTful 方法，通过匿名组合之后，其实目前的 HelloController 已经拥有了 Get、Post、Delete、Put 等方法，这些方法是分别用来对应用户请求的 Method 函数，如果用户发起的是 POST 请求，那么就执行 Post 函数。所以这里我们定义了 HelloController 的 Get 方法用来重写继承的 Get 函数，这样当用户发起 GET 请求的时候就会执行该函数。Router 注册路由，路由就是告诉 beego，当用户来请求的时候，该如何去调用相应的 Controller，这里我们注册了请求 / 的时候，请求到 HelloController。这里我们需要知道，Router 函数的两个参数函数，第一个是路径，第二个是 Controller 的指针。Run 应用，bee run 启动，其实就是内部监听了 8080 端口：Go 默认情况会监听你本机所有的 IP 上面的 8080 端口停止服务的话，请按 Ctrl+c。之后在 routers 下 routers.go下添加 // 然后将新增的HelloController添加路由，修改routers/router.go文件新增路由beego.Router(&quot;/hello&quot;, &amp;controllers.HelloController{})和java的controller写法类似 /hello 是后缀 即你用localhost:8080/hello可以访问界面如果是用goland进行开发，可以直接启动main.go，其中的配置如下1. 点击edit configurations</code></pre><p><img src="/images/beego/beego3.png" alt="beego搭建"><br><img src="/images/beego/beego4.png" alt="beego搭建"></p><pre><code>下面我们访问一下 localhost:8080/hello</code></pre><p><img src="/images/beego/beego5.png" alt="beego搭建"></p><pre><code>OVER！！！</code></pre><blockquote><p>感谢帮助我踩坑成功的各位哥哥，正是由于你们的付出，才让我们踩更少的坑，感恩<br>如果涉及到您的版权问题，请联系我删除，谢谢<br><a href="mailto:18135479521@163.com" target="_blank" rel="noopener">18135479521@163.com</a></p></blockquote><p>版权声明：本文为博主原创文章，转载请附上博文链接！</p><p><a href="https://app.netlify.com/sites/ymliang/deploys" target="_blank" rel="noopener"><img src="https://api.netlify.com/api/v1/badges/0f11aaba-6571-4f78-b114-467979ef9df5/deploy-status" alt="Netlify Status"></a></p><p><a href><img src="https://img.shields.io/badge/download-26k-green.svg?style=flat-square" alt="Travis"></a> <a href><img src="https://img.shields.io/badge/windows-black.svg?style=flat-square&amp;logo=windows" alt="Travis"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是beego&quot;&gt;&lt;a href=&quot;#什么是beego&quot; class=&quot;headerlink&quot; title=&quot;什么是beego&quot;&gt;&lt;/a&gt;什么是beego&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;一个框架：可以理解为Golang的MVC框架
四个特点：简单化、智能化、模块化、高性能
具体好处去官网自行浏览
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://beego.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://ymliang.com/categories/go/"/>
    
    
      <category term="go" scheme="http://ymliang.com/tags/go/"/>
    
      <category term="beego" scheme="http://ymliang.com/tags/beego/"/>
    
  </entry>
  
  <entry>
    <title>spark知识梳理</title>
    <link href="http://ymliang.com/spark%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86.html"/>
    <id>http://ymliang.com/spark知识梳理.html</id>
    <published>2019-05-23T10:19:30.000Z</published>
    <updated>2019-05-31T05:27:57.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spark定义"><a href="#Spark定义" class="headerlink" title="Spark定义:"></a>Spark定义:</h3><p>Spark编程始于数据集，而数据集往往存放在分布式持久化存储之上，比如Hadoop分布式文件系统HDFS</p><p>编写Spark 程序通常包括一系列相关步骤。</p><pre><code>• 在输入数据集上定义一组转换。• 调用 action，用以将转换后的数据集保存到持久存储上，或者把结果返回到驱动程序的本地内存。• 运行本地计算，本地计算处理分布式计算的结果。本地计算有助于你确定下一步的转换和 action。</code></pre><a id="more"></a><pre><code>要想理解 Spark，就必须理解 Spark 框架提供的两种抽象：存储和执行。Spark 优美地搭配这两类抽象，可以将数据处理管道中的任何中间步骤缓在内存里以备后用常见的RDD转化操作</code></pre><h3 id="transform算子"><a href="#transform算子" class="headerlink" title="transform算子:"></a>transform算子:</h3><p><img src="/images/spark知识梳理/transform.png" alt="transform"></p><h3 id="action算子"><a href="#action算子" class="headerlink" title="action算子:"></a>action算子:</h3><p><img src="/images/spark知识梳理/action.png" alt="action"></p><h3 id="case-class"><a href="#case-class" class="headerlink" title="case class"></a>case class</h3><p>case class 是不可变类的一种简单类型它非常好用，内置了所有 Java 类的基本方法，比如toString、equals和 hashCode。我们来试试为记录关联数据定义一个 case class：</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">样例数据来自加州大学欧文分校机器学习资料库（UC Irvine Machine Learning Repository）。</span><br><span class="line">这里要分析的数据集来源于一项纪录关联研究，是德国一家医院在2010年完成的。这个数据及包含数百万对病人记录，每队记录都根据不同标准来匹配。比如病人姓名、地址、生日。</span><br><span class="line">每个匹配字段都被赋予一个数值评分，范围为0.0 到 1.0，分值根据字符串相似度得出。然后这些数据交给人工处理，标记出哪些代表同一个人哪些代表不同的人。</span><br><span class="line">为了保护病人隐私，创建的数据集的每个字段原始值被删除。病人的ID、字段匹配分数、匹配对标识（包括匹配的和不匹配的）等信息是公开的，可用于纪录关联研究。</span><br></pre></td></tr></table></figure><p>数据获取</p><pre><code>$ mkdir linkage$ cd linkage/$ wget https://archive.ics.uci.edu/ml/machine-learning-databases/00210/donation.zip(http://bit.ly/1Aoywaq)$ unzip donation.zip$ unzip &apos;block_*.zip&apos;放入HDFS：$ hadoop fs -mkdir /linkage$ hadoop fs -put block_*.csv /linkage</code></pre><p>启动spark-shell 这里本地启动</p><pre><code>spark-shell Setting default log level to &quot;WARN&quot;.To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).19/05/24 07:15:36 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableSpark context Web UI available at http://192.111.110.111:4040Spark context available as &apos;sc&apos; (master = spark://master:7077, app id = app-20190524071537-0001).Spark session available as &apos;spark&apos;.Welcome to    ____              __    / __/__  ___ _____/ /__    _\ \/ _ \/ _ `/ __/  &apos;_//___/ .__/\_,_/_/ /_/\_\   version 2.2.0    /_/Using Scala version 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_144)Type in expressions to have them evaluated.Type :help for more information.scala&gt; 如果出现以上说明启动成功</code></pre><p>读数据</p><pre><code>scala&gt;val rawblocks = sc.textFile(&quot;hdfs:///linkage/*.csv&quot;)scala&gt;val head = rawblocks.take(10)scala&gt;head.lengthres2: Int = 10遍历scala&gt;head.foreach(println)&quot;id_1&quot;,&quot;id_2&quot;,&quot;cmp_fname_c1&quot;,&quot;cmp_fname_c2&quot;,&quot;cmp_lname_c1&quot;,&quot;cmp_lname_c2&quot;,&quot;cmp_sex&quot;,&quot;cmp_bd&quot;,&quot;cmp_bm&quot;,&quot;cmp_by&quot;,&quot;cmp_plz&quot;,&quot;is_match&quot;37291,53113,0.833333333333333,?,1,?,1,1,1,1,0,TRUE39086,47614,1,?,1,?,1,1,1,1,1,TRUE70031,70237,1,?,1,?,1,1,1,1,1,TRUE84795,97439,1,?,1,?,1,1,1,1,1,TRUE36950,42116,1,?,1,1,1,1,1,1,1,TRUE42413,48491,1,?,1,?,1,1,1,1,1,TRUE25965,64753,1,?,1,?,1,1,1,1,1,TRUE49451,90407,1,?,1,?,1,1,1,1,0,TRUE39932,40902,1,?,1,?,1,1,1,1,1,TRUE</code></pre><p>定义函数过滤第一行的表头数据：(“id_1”,”id_2”,”cmp_fname_c1”….)</p><pre><code>scala&gt; def isHeader(line:String):Boolean={            line.contains(&quot;id_1&quot;) || line.contains(&quot;cmp&quot;)        }scala&gt; head.filter(isHeader).foreach(println) 查包含&quot;id_1&quot;的行scala&gt; head.filterNot(isHeader).foreach(println) 查不包含&quot;id_1&quot;的行scala&gt; head.filter(x=&gt; isHeader(x)).foreach(println) 查包含&quot;id_1&quot;的行scala&gt; head.filter(x=&gt; !isHeader(x)).foreach(println) 查不包含&quot;id_1&quot;的行scala&gt; head.filter(isHeader(_)).foreach(println) 查包含&quot;id_1&quot;的行scala&gt; head.filter(!isHeader(_)).foreach(println) 查不包含&quot;id_1&quot;的行过滤的方法有三种，再上方已经列举出来了，可以根据喜好和编码习惯选择将去掉标题头 即含有 id_1的第一行去掉后变为新的 RDDscala&gt; val noheader = rawblocks.filter(x =&gt; !isHeader(x)) noheader: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[4] at filter at &lt;console&gt;:28</code></pre><p>进行数据结构化</p><pre><code>说到数据结构化，首先java的思想就是封装，scala中是元组和case class ，其中 case class类似于封装tuple 元组 -- scala    为了测试方便，先取一行数据    val line = head(5)    1. 首先定义一个函数，里面处理每一行数据    def parse(line:String)={        val pieces = line.split(&apos;,&apos;)        val id1 = pieces(0).toInt        val id2 = pieces(1).toInt        val scores = pieces.slice(2,11).map(toDouble)        val matched = pieces(11).toBoolean        (id1,id2,scores,matched)    }    val tup = parse(line)    2. 可能你没有注意有问号的情况，那么为了避免出现 ? 导致程序报错，可以定义 toDouble函数    def toDouble(s:String)={        if(&quot;?&quot;.equals(s)) Double.NaN else s.toDouble    }    --------------------------------------------------------------------------        slice函数截取集合        slice函数需要两个参数，第一个参数表示从该下标开始截取，第二个参数表示截取到该下标（不包含）。        object TestCollection {            val list =List(1,4,6,4,1)            def main(args: Array[String]): Unit = {                print(list.slice(0,3))            }        }    --------------------------------------------------------------------------    3. 之后再执行 val tup = parse(line)    得到的tup就是一个元组    元组的操作:    tup._1      取第一个元素    tup.productElement(0)       或者用 productElement 方法，它是从 0 开始计数的。    tup.productArity        也可以用 productArity 方法得到元组的大小case class     case class 是不可变类的一种简单类型，它非常好用，内置了所有 Java 类的基本方法，比如 toString、equals 和 hashCode。我们来试试为记录关联数据定义一个 case class：    case class MatchData(id1: Int, id2: Int,scores: Array[Double], matched: Boolean)    现在修改 parse 方法以返回 MatchData 实例，这个实例是 case class 而不再是元组：    def parse(line: String) = {        val pieces = line.split(&apos;,&apos;)        val id1 = pieces(0).toInt        val id2 = pieces(1).toInt        val scores = pieces.slice(2, 11).map(toDouble)        val matched = pieces(11).toBoolean        MatchData(id1, id2, scores, matched)    }    val md = parse(line)    这里要注意两点：    一，创建 case class 时没必要在 MatchData 前写上关键字 new    二，MatchData 类有个内置的 toString 方法实现，除了scores 数组字段外，这个方法在其他字段上的表现都还不错。    现在通过名字来访问 MatchData 的字段：    md.matched    md.id1    是不是有种 对象.成员变量 的意思 有些地方还是很像java的，比如java8的lambda表达式和scala非常相似    之后将其作用于head数据集上    val mds = head.filter(x=&gt; !isHeader(x)).map(x=&gt; parse(x))    之后再作用于整个数据集上 noheader    val parsed = noheader.map(line =&gt; parse(line))    记住：和我们本地生成的 mds 数组不同，parse 函数并没有实际应用到集群数据上。当在    parsed 这个 RDD 上执行某个需要输出的调用时，就会用 parse 函数把 noheader RDD     的每个 String 转换成 MatchData 类的实例。如果在 parsed RDD 上执行另一个调用以    产生不同输出，parse函数会在输入数据上再执行一遍。这没有充分利用集群资源。数据一    旦解析好，我们想以解析格式把数据存到集群上，这样就不需要每次遇到新问题时都重新解    析。Spark支持这种使用场景，通过在实例上调用cache 方法，可以指示在内存里缓存某个    RDD。现在用 parsed 这个 RDD 实验一下：    parsed.cache()    Spark的缓存：        虽然默认情况下 RDD 的内容是临时的，但 Spark 提供了在 RDD 中持久化数据的机制。第        一次调用动作并计算出 RDD 内容后，RDD 的内容可以存储在集群的内存或磁盘上。这样下一        次需要调用依赖该 RDD 的动作时，就不需要从依赖关系中重新计算 RDD，数据可以从缓存分        区中直接返回：            cached.cache()            cached.count()            cached.take(10)        在上述代码中，cache 方法调用指示在下次计算 RDD 后，要把 RDD 存储起来。调用        count 会导致第一次计算 RDD。采取（take）这个动作返回一个本地的 Array，包含        RDD 的前 10 个元素。但调用 take 时，访问的是 cached 已经缓存好的元素，而不是        从 cached 的依赖关系中重新计算出来的。        Spark 为持久化 RDD 定义了几种不同的机制，用不同的 StorageLevel 值表示。rdd.        cache() 是 rdd.persist(StorageLevel.MEMORY) 的简写，它将 RDD 存储为未序列化        的 Java 对象。当 Spark 估计内存不够存放一个分区时，它干脆就不在内存中存放该分        区，这样在下次需要时就必须重新计算。在对象需要频繁访问或低延访问时适合使用        StorageLevel.MEMORY，因为它可以避免序列化的开销。相比其他选项，StorageLevel.        MEMORY 的问题是要占用更大的内存空间。另外，大量小对象会对 Java 的垃圾回收造成        压力，会导致程序停顿和常见的速度缓慢问题。        Spark 也提供了 MEMORY_SER 的存储级别，用于在内存中分配大字节缓冲区以存储 RDD        序列化内容。如果使用得当（稍后会详细介绍），序列化数据占用的空间比未经序列化        的数据占用的空间往往要少两到五倍。        Spark 也可以用磁盘来缓存 RDD。        存储级别 MEMORY_AND_DISK 和 MEMORY_AND_DISK_SER        分别类似于 MEMORY 和 MEMORY_SER。对于 MEMORY 和 MEMORY_SER，如果一个分区在内存        里放不下，整个分区都不会放在内存。对于 MEMORY_AND_DISK 和 MEMORY_AND_DISK_SER，        如果分区在内存里放不下，Spark 会将其溢写到磁盘上。        什么时候该缓存数据是门艺术，这通常需要对空间和速度进行权衡，垃圾回收开销的        问题也会时不时让情况更复杂。一般情况下，如果多个动作需要用到某个 RDD，而它        的计算代价又很高，那么就应该把这个 RDD 缓存起来。</code></pre><p>聚合</p><pre><code>我们用 groupBy 方法来创建一个 Scala Map[Boolean, Array[MatchData]]，其中键值基于MatchData 类的字段 matched：    val grouped = mds.groupBy(md =&gt; md.matched)    grouped: scala.collection.immutable.Map[Boolean,Array[MatchData]] = Map(true -&gt; Array(MatchData(37291,53113,[D@14587d48,true), MatchData(39086,47614,[D@556e8e2e,true), MatchData(70031,70237,[D@4d94e219,true), MatchData(84795,97439,[D@25937e5b,true), MatchData(36950,42116,[D@7276f59c,true), MatchData(42413,48491,[D@53481a02,true), MatchData(25965,64753,[D@3926be58,true), MatchData(49451,90407,[D@7f96e81,true), MatchData(39932,40902,[D@42e6a1f7,true)))利用mapValues进行记数    grouped.mapValues(x=&gt;x.size).foreach(println)    (true,9)</code></pre><p>创建直方图</p><pre><code>先来试试创建一个简单的直方图，用它来算一下 parsed 中的 MatchData 记录有多少 matched字段值为 true 或 false。幸运的是 RDD[T] 类已经定义了一个名为 countByValue 的动作，该动作对于计数类运算效率非常高，它向客户端返回 Map[T,Long] 类型的结果。对 MatchData记录中的 matched 字段映射调用 countByValue 会执行一个 Spark 作业，并向客户端返回结果：    scala&gt; val matchCounts = parsed.map(md =&gt; md.matched).countByValue()countByValue:统计一个RDD中各个value的出现次数。返回一个map，map的key是元素的值，value是出现的次数。count:  统计RDD中元素的个数。countByKey: 与count类似，但是是以key为单位进行统计。 注意：此函数返回的是一个map，不是int。Scala 的Map 类没有提供根据内容的键或值排序的方法，但是我们可以将 Map 转换成Scala 的Seq 类型，而Seq 支持排序。Scala 的 Seq 类和 Java 的 List 类接口类似，都是可迭代集合，即具有确定的长度并且可以根据下标来查找值。    scala&gt; val matchCountsSeq = matchCounts.toSeq    matchCountsSeq: Seq[(Boolean, Long)] = ArrayBuffer((true,20931), (false,5728201))------------------------------------------------------------------------------------------------        Scala 集合            Scala 集合类库很庞大，包括 list、set、map 和 array。利用 toList、toSet 和 toArray            方法，各种集合类型可以方便地相互转换。------------------------------------------------------------------------------------------------sortBy 排序matchCountsSeq.sortBy(_._1).foreach(println)matchCountsSeq.sortBy(_._2).foreach(println)matchCountsSeq.sortBy(_._2).reverse.foreach(println)_._1 指按第一列指标排序reverse 反转排序结果</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Spark定义&quot;&gt;&lt;a href=&quot;#Spark定义&quot; class=&quot;headerlink&quot; title=&quot;Spark定义:&quot;&gt;&lt;/a&gt;Spark定义:&lt;/h3&gt;&lt;p&gt;Spark编程始于数据集，而数据集往往存放在分布式持久化存储之上，比如Hadoop分布式文件系统HDFS&lt;/p&gt;
&lt;p&gt;编写Spark 程序通常包括一系列相关步骤。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;• 在输入数据集上定义一组转换。
• 调用 action，用以将转换后的数据集保存到持久存储上，或者把结果返回到驱动程序的
本地内存。
• 运行本地计算，本地计算处理分布式计算的结果。本地计算有助于你确定下一步的转换
和 action。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="spark" scheme="http://ymliang.com/categories/spark/"/>
    
    
      <category term="spark" scheme="http://ymliang.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>redis取经之路</title>
    <link href="http://ymliang.com/redis%E5%8F%96%E7%BB%8F%E4%B9%8B%E8%B7%AF.html"/>
    <id>http://ymliang.com/redis取经之路.html</id>
    <published>2019-05-21T06:44:34.000Z</published>
    <updated>2019-06-04T03:08:08.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis基本数据结构"><a href="#redis基本数据结构" class="headerlink" title="redis基本数据结构"></a>redis基本数据结构</h3><p>Redis使用的是自己构建的简单动态字符串(SDS)[simple dynamic string,SDS]的抽象类型，并将SDS用做Rdis的默认字符串表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello&quot;</span><br><span class="line">Ok</span><br></pre></td></tr></table></figure></p><p>redis的Key-Value的存储方式</p><pre><code>key是一个字符串对象，对象的底层实现是一个保存着字符串&quot;msg&quot;的SDSvalue也是一个字符串对象，对象的底层实现是一个保存着字符串&quot;hello&quot;的SDS</code></pre><p>SDS除了用来保存数据库中的字符串值之外，还被用作缓冲区(Buffer):AOF模块中的AOF缓冲区<br><a id="more"></a></p><p>基本数据类型</p><pre><code>- 字符串命令:GET SET DEL- 列表:一个列表结构可以有序地存储多个字符串     LPUSH RPUSH 表示元素推入列表的左端和右端     LPOP RPOP分别从列表的左端和右端弹出元素，被弹出的元素不再属于列表     LINDEX用于获取列表在给定位置的上一个元素     LRANGE用于获取列表在给定范围上的所有元素- 集合:列表可以存储多个相同的字符串，集合则通过散列表来保证自己存储的每个字符串都是各不相同的(这些散列表只有键，但没有与键相关联的值)     redis的集合使用的是无序方式存储元素     SADD:将元素添加到集合        redis&gt; sadd fengjr &quot;hehehehe&quot;        (integer) 1     SREM:从集合移除元素，命令会返回被移除元素的数量     SMEMBERS:获取集合包含的所有元素将得到一个由元素组成的序列     SISMEMBER:快速检查一个元素是否已经存在于集合中- 散列:redis的散列可以存储多个键值对之间的映射。和字符串一样，散列存储的值既可以是字符串，又可以是数字值，并且用户同样可以对散列存储的数字值执行自增操作或者自减操作     HSET:在散列里面关联起给定的键值对        hset hash-key sub-key1 value1        hset hash-key sub-key2 value2        栗子:        redis&gt; HSET myhash field1 123        redis&gt; HSET myhash name liangym     返回值为1表示给定的键不存在于散列里面，添加成功     返回值为0表示给定的键存在于散列里面，添加失败     HDEL:如果给定键存在于散列里面，删除这个键        栗子:        redis&gt; HDEL myhash name        (integer) 1 删除成功     HGET:从散列里面获取某个键的值     HGETALL:获取散列包含的所有键值对        栗子:        redis&gt; HGETALL myhash        1) &quot;filed1&quot;        2) &quot;foo&quot;        3) &quot;field1&quot;        4) &quot;123&quot;     HINCRBY:对散列存储的值执行自增操作     HINCRBY key field icrement        栗子:        redis&gt;HINCRBY myhash field1 123        (integer) 246- 有序集合:和散列一样都用于存储键值对：有序集合的键被称为成员(member)，每个成员都是各不相同的；而有序集合的值则被称为分值(score)，分值必须为浮点数     ZADD:将一个带有给定分值的成员添加到有序集合里面        栗子:        redis&gt;zadd zset-key 728 member     ZRANGE:根据元素在有序排列中所处的位置，从有序集合里面获取多个元素     ZRANGEBYSCORE:获取有序集合在给定分值范围内的所有元素     ZREM:如果给定成员存在于有序集合，那么移除这个成员     ZINCRBY:给有序集合成员的分值执行自增操作        栗子:        ZINCRBY key increment member        redis&gt;ZINCRBY zset-key 123 member1    ZSCORE:检查记录的有序集合的值        栗子:        ZSCORE key member        redis&gt;ZSCORE zset-key member1        &quot;851&quot;</code></pre><h3 id="redis的特性"><a href="#redis的特性" class="headerlink" title="redis的特性"></a>redis的特性</h3><pre><code>数据结构内存存储(这使得Redis的速度非常快)远程(这使得Redis可以与多个客户端和服务器进行连接)持久化(这可以使得服务器可以再重启之后仍然保持重启之前的数据)可扩展(通过主从复制和分片)通过将传统数据库的一部分数据处理任务以及存储任务转交给redis来完成，可以提升网页的载入速度，并降低资源的占用量</code></pre><h3 id="场景一：登录和cookie缓存"><a href="#场景一：登录和cookie缓存" class="headerlink" title="场景一：登录和cookie缓存"></a>场景一：登录和cookie缓存</h3><pre><code>将登录信息存储在cookie中  可以用签名(signed) 和令牌(token)使用redis来记录用户信息，将每天要对数据库执行的写入操作减少了很多</code></pre><h3 id="场景二：购物车"><a href="#场景二：购物车" class="headerlink" title="场景二：购物车"></a>场景二：购物车</h3><pre><code>定义：散列：每个用户的购物车key：商品IDvalue：商品订购数量将会话和购物车都存储到Redis里面，这样可以减少请求的体积，还可以使得我们根据用户浏览过的上铺，用户放入购物车的商品，以及用户最终购买的商品进行统计计算。实现：在查看过这件商品的用户当中，有X%的用户最终购买了这件商品， 购买了这件商品的用户也购买了某某某其他商品 等功能</code></pre><h3 id="网页缓存"><a href="#网页缓存" class="headerlink" title="网页缓存"></a>网页缓存</h3><pre><code>页面内容不需要动态生成，减少网站在动态生成内容上面所花的时间，可以降低网站处理相同负载所需的服务器数量，并让网站的速度变得更快(增强用户体验)中间层的作用：对于一个不能被缓存的请求，函数将直接生成并返回页面，而对于可以被缓存的请求，函数首先会尝试从缓存里取出并返回被缓存的页面，如果缓存页面不存在，那么函数会生成页面并将其缓存在Redis中5分钟，最后将页面返回给函数调用者</code></pre><h3 id="数据行缓存"><a href="#数据行缓存" class="headerlink" title="数据行缓存"></a>数据行缓存</h3><pre><code>场景：促销活动，会推出一些特价商品供用户抢购疑虑：网站如果对整个促销页面进行缓存，可能会导致用户看到错误的特价商品的数量，但如果每次都从数据库里面取出特价商品的剩余数量的话又会给数据库带来巨大的压力，导致我们需要花费额外的成本来扩展数据库。解决：促销活动必定会带来一些负载，所以必须对数据进行缓存，编写一个持续运行的守护进程，让这个函数将指定的数据行缓存到redis里面，并不定期地对这些缓存进行更新。设置两个有序集合，分别为：调度有序集合，延时有序集合，调度顾名思义调度，延时则是设置了指定数据航的缓存需要每隔多少秒更新一次如果数据行记录的是特价促销商品的剩余数量，并且参与促销活动的用户非常多的话，那么我们最好每隔几秒更新一次数据行缓存；另一方面，如果数据并不经常改变，或者商品缺货是可以接受的，那么我们可以将更新缓存的时间变长</code></pre><h3 id="网页分析"><a href="#网页分析" class="headerlink" title="网页分析"></a>网页分析</h3><h3 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;redis基本数据结构&quot;&gt;&lt;a href=&quot;#redis基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;redis基本数据结构&quot;&gt;&lt;/a&gt;redis基本数据结构&lt;/h3&gt;&lt;p&gt;Redis使用的是自己构建的简单动态字符串(SDS)[simple dynamic string,SDS]的抽象类型，并将SDS用做Rdis的默认字符串表示&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;redis&amp;gt; SET msg &amp;quot;hello&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ok&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;redis的Key-Value的存储方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;key是一个字符串对象，对象的底层实现是一个保存着字符串&amp;quot;msg&amp;quot;的SDS
value也是一个字符串对象，对象的底层实现是一个保存着字符串&amp;quot;hello&amp;quot;的SDS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SDS除了用来保存数据库中的字符串值之外，还被用作缓冲区(Buffer):AOF模块中的AOF缓冲区&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://ymliang.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://ymliang.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Git配置SSH密钥</title>
    <link href="http://ymliang.com/Git%E9%85%8D%E7%BD%AESSH%E5%AF%86%E9%92%A5.html"/>
    <id>http://ymliang.com/Git配置SSH密钥.html</id>
    <published>2019-05-16T01:48:08.000Z</published>
    <updated>2019-06-04T03:08:33.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><pre><code>在随便一个文件夹空白处右击 点击 Git Bash Here初次安装git配置用户名和邮箱$ git config --global user.name &quot;yiming.liang&quot;$ git config --global user.email &quot;18135479521@163.com&quot;注意：（引号内请输入你自己设置的名字，和你自己的邮箱）此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱</code></pre><a id="more"></a><pre><code>git使用ssh密钥--------------------------------------------------------------------------------git使用https协议，每次pull, push都会提示要输入密码，使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦初次使用git的用户要使用git协议大概需要三个步骤：一、生成密钥对二、设置远程仓库（本文以github为例）上的公钥三、把git的 remote url 修改为git协议（以上两个步骤初次设置过以后，以后使用都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤）一、生成密钥对--------------------------------------------------------------------------------大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看：$ cd ~/.ssh$ lsauthorized_keys2  id_dsa       known_hosts config            id_dsa.pub看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;Creates a new ssh key using the provided email # Generating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa):直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)：Enter same passphrase again: [Type passphrase again]完了之后，大概是这样：Your public key has been saved in /home/you/.ssh/id_rsa.pub.The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com到此为止，你本地的密钥对就生成了。二、添加公钥到你的远程仓库（github）1、查看你生成的公钥：$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC2、登陆你的github帐户。点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key3、然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。4、点击 Add key。完成以后，验证下这个key是不是正常工作：$ ssh -T git@github.comAttempts to ssh to github如果，看到：Hi xxx! You&apos;ve successfully authenticated, but GitHub does not # provide shell access.恭喜你，你的设置已经成功了。三、修改git的remote url使用命令 git remote -v 查看你当前的 remote url$ git remote -vorigin https://github.com/someaccount/someproject.git (fetch)origin https://github.com/someaccount/someproject.git (push)如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议）你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url，类似：复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。git remote set-url origin git@github.com:someaccount/someproject.git然后你可以再用命令 git remote -v 查看一下，url是否已经变成了ssh地址。然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了参考链接：http://www.tuicool.com/articles/BzUrAvF</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;配置用户名和邮箱&quot;&gt;&lt;a href=&quot;#配置用户名和邮箱&quot; class=&quot;headerlink&quot; title=&quot;配置用户名和邮箱&quot;&gt;&lt;/a&gt;配置用户名和邮箱&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在随便一个文件夹空白处右击 点击 Git Bash Here
初次安装git配置用户名和邮箱


$ git config --global user.name &amp;quot;yiming.liang&amp;quot;
$ git config --global user.email &amp;quot;18135479521@163.com&amp;quot;
注意：（引号内请输入你自己设置的名字，和你自己的邮箱）此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="git" scheme="http://ymliang.com/categories/git/"/>
    
    
      <category term="git" scheme="http://ymliang.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>leetCode 155 最小栈</title>
    <link href="http://ymliang.com/leetCode-155-%E6%9C%80%E5%B0%8F%E6%A0%88.html"/>
    <id>http://ymliang.com/leetCode-155-最小栈.html</id>
    <published>2019-05-06T10:04:32.000Z</published>
    <updated>2019-06-03T07:54:03.892Z</updated>
    
    <content type="html"><![CDATA[<pre><code>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) -- 将元素 x 推入栈中。pop() -- 删除栈顶的元素。top() -- 获取栈顶元素。getMin() -- 检索栈中的最小元素。</code></pre><a id="more"></a><pre><code>示例:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    //声明栈</span><br><span class="line">    private Stack&lt;Integer&gt; stack;</span><br><span class="line">    //声明初始最小值为Integer.MAX_VALUE保证第一个push的值必定毕它小则可以设定第一个push的值为最小值</span><br><span class="line">    private int min = Integer.MAX_VALUE;</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line"></span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">        //新建栈</span><br><span class="line">        stack = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        //判断如果push的值小于等于min值则将之前的最小值入栈，min设置为当前最小值，之后将当前最小值入栈</span><br><span class="line">        // &gt;= 中的 等于是为了避免出现相同值的情况 比如 0,1,0</span><br><span class="line">        if(min&gt;=x)&#123;</span><br><span class="line">            stack.push(min);</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        //判断pop的值是否和当前最小值相等，如果相等则将上一次push的值设为最小值(因为pop后栈顶元素为上一次入栈的最小值)，整体思路就是每次遇到最小值时将上一次的最小值push，之后push当前最小值，pop的时候也是同样，如果pop的值等于最小值则将最小值设置为上一次push入的值，注意pop的时候，只要执行了pop()方法，栈顶元素就出栈了，则当前最小值出栈，此时栈顶元素为上一次push的最小值，所以可以直接设置为最小值(即 min = stack.pop())</span><br><span class="line">        if(stack.pop() == min)&#123;</span><br><span class="line">            min = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int top() &#123;</span><br><span class="line">        //打印栈顶元素</span><br><span class="line">        return stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMin() &#123;</span><br><span class="line">        //直接返回设定的最小值</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 忽略这段</span><br><span class="line">* Your MinStack object will be instantiated and called as such:</span><br><span class="line">* MinStack obj = new MinStack();</span><br><span class="line">* obj.push(x);</span><br><span class="line">* obj.pop();</span><br><span class="line">* int param_3 = obj.top();</span><br><span class="line">* int param_4 = obj.getMin();</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) -- 将元素 x 推入栈中。
pop() -- 删除栈顶的元素。
top() -- 获取栈顶元素。
getMin() -- 检索栈中的最小元素。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://ymliang.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://ymliang.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>linux高级命令</title>
    <link href="http://ymliang.com/linux%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4.html"/>
    <id>http://ymliang.com/linux高级命令.html</id>
    <published>2019-05-06T06:48:25.000Z</published>
    <updated>2019-06-04T03:09:12.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><pre><code>awk是行处理器: 相比较屏幕处理的优点，在处理庞大文件时不会出现内存溢出或是处理缓慢的问题，通常用来格式化文本信息awk处理过程: 依次对每一行进行处理，然后输出awk命令形式:awk [-F|-f|-v] ‘BEGIN{} //{command1; command2} END{}’ file[-F|-f|-v]   大参数，-F指定分隔符，-f调用脚本，-v定义变量 var=value&apos;  &apos;          引用代码块BEGIN   初始化代码块，在对每一行进行处理之前，初始化代码，主要是引用全局变量，设置FS分隔符//           匹配代码块，可以是字符串或正则表达式{}           命令代码块，包含一条或多条命令；          多条命令使用分号分隔END      结尾代码块，在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息</code></pre><a id="more"></a><pre><code>特殊要点:$0           表示整个当前行$1           每行第一个字段NF          字段数量变量NR          每行的记录号，多文件记录递增FNR        与NR类似，不过多文件记录不递增，每个文件都从1开始\t            制表符\n           换行符FS          BEGIN时定义分隔符RS       输入的记录分隔符， 默认为换行符(即文本是按一行一行输入)~            匹配，与==相比不是精确比较!~           不匹配，不精确比较==         等于，必须全部相等，精确比较!=           不等于，精确比较&amp;&amp;　     逻辑与||             逻辑或+            匹配时表示1个或1个以上/[0-9][0-9]+/   两个或两个以上数字/[0-9][0-9]*/    一个或一个以上数字FILENAME 文件名OFS      输出字段分隔符， 默认也是空格，可以改为制表符等ORS        输出的记录分隔符，默认为换行符,即处理结果也是一行一行输出到屏幕-F&apos;[:#/]&apos;   定义三个分隔符print &amp; $0print 是awk打印指定内容的主要命令awk &apos;{print}&apos;  /etc/passwd   ==   awk &apos;{print $0}&apos;  /etc/passwd  awk &apos;{print &quot; &quot;}&apos; /etc/passwd                                           //不输出passwd的内容，而是输出相同个数的空行，进一步解释了awk是一行一行处理文本awk &apos;{print &quot;a&quot;}&apos;   /etc/passwd                                        //输出相同个数的a行，一行只有一个a字母awk -F&quot;:&quot; &apos;{print $1}&apos;  /etc/passwd awk -F: &apos;{print $1; print $2}&apos;   /etc/passwd                   //将每一行的前二个字段，分行输出，进一步理解一行一行处理文本awk  -F: &apos;{print $1,$3,$6}&apos; OFS=&quot;\t&quot; /etc/passwd        //输出字段1,3,6，以制表符作为分隔符-f指定脚本文件awk -f script.awk  fileBEGIN{FS=&quot;:&quot;}{print $1}               //效果与awk -F&quot;:&quot; &apos;{print $1}&apos;相同,只是分隔符使用FS在代码自身中指定awk &apos;BEGIN{X=0} /^$/{ X+=1 } END{print &quot;I find&quot;,X,&quot;blank lines.&quot;}&apos; test I find 4 blank lines.ls -l|awk &apos;BEGIN{sum=0} !/^d/{sum+=$5} END{print &quot;total size is&quot;,sum}&apos;                    //计算文件大小total size is 17487-F指定分隔符$1 指指定分隔符后，第一个字段，$3第三个字段， \t是制表符一个或多个连续的空格或制表符看做一个定界符，即多个空格看做一个空格awk -F&quot;:&quot; &apos;{print $1}&apos;  /etc/passwdawk -F&quot;:&quot; &apos;{print $1 $3}&apos;  /etc/passwd                       //$1与$3相连输出，不分隔awk -F&quot;:&quot; &apos;{print $1,$3}&apos;  /etc/passwd                       //多了一个逗号，$1与$3使用空格分隔awk -F&quot;:&quot; &apos;{print $1 &quot; &quot; $3}&apos;  /etc/passwd                  //$1与$3之间手动添加空格分隔awk -F&quot;:&quot; &apos;{print &quot;Username:&quot; $1 &quot;\t\t Uid:&quot; $3 }&apos; /etc/passwd       //自定义输出  awk -F: &apos;{print NF}&apos; /etc/passwd                                //显示每行有多少字段awk -F: &apos;{print $NF}&apos; /etc/passwd                              //将每行第NF个字段的值打印出来awk -F: &apos;NF==4 {print }&apos; /etc/passwd                       //显示只有4个字段的行awk -F: &apos;NF&gt;2{print $0}&apos; /etc/passwd                       //显示每行字段数量大于2的行awk &apos;{print NR,$0}&apos; /etc/passwd                                 //输出每行的行号awk -F: &apos;{print NR,NF,$NF,&quot;\t&quot;,$0}&apos; /etc/passwd      //依次打印行号，字段数，最后字段值，制表符，每行内容awk -F: &apos;NR==5{print}&apos;  /etc/passwd                         //显示第5行awk -F: &apos;NR==5 || NR==6{print}&apos;  /etc/passwd       //显示第5行和第6行route -n|awk &apos;NR!=1{print}&apos;                                       //不显示第一行//匹配代码块//纯字符匹配   !//纯字符不匹配   ~//字段值匹配    !~//字段值不匹配   ~/a1|a2/字段值匹配a1或a2   awk &apos;/mysql/&apos; /etc/passwdawk &apos;/mysql/{print }&apos; /etc/passwdawk &apos;/mysql/{print $0}&apos; /etc/passwd                   //三条指令结果一样awk &apos;!/mysql/{print $0}&apos; /etc/passwd                  //输出不匹配mysql的行awk &apos;/mysql|mail/{print}&apos; /etc/passwdawk &apos;!/mysql|mail/{print}&apos; /etc/passwdawk -F: &apos;/mail/,/mysql/{print}&apos; /etc/passwd         //区间匹配awk &apos;/[2][7][7]*/{print $0}&apos; /etc/passwd               //匹配包含27为数字开头的行，如27，277，2777...awk -F: &apos;$1~/mail/{print $1}&apos; /etc/passwd           //$1匹配指定内容才显示awk -F: &apos;{if($1~/mail/) print $1}&apos; /etc/passwd     //与上面相同awk -F: &apos;$1!~/mail/{print $1}&apos; /etc/passwd          //不匹配awk -F: &apos;$1!~/mail|mysql/{print $1}&apos; /etc/passwd        IF语句必须用在{}中，且比较内容用()扩起来awk -F: &apos;{if($1~/mail/) print $1}&apos; /etc/passwd                                       //简写awk -F: &apos;{if($1~/mail/) {print $1}}&apos;  /etc/passwd                                   //全写awk -F: &apos;{if($1~/mail/) {print $1} else {print $2}}&apos; /etc/passwd            //if...else...条件表达式==   !=   &gt;   &gt;=  awk -F&quot;:&quot; &apos;$1==&quot;mysql&quot;{print $3}&apos; /etc/passwd  awk -F&quot;:&quot; &apos;{if($1==&quot;mysql&quot;) print $3}&apos; /etc/passwd          //与上面相同 awk -F&quot;:&quot; &apos;$1!=&quot;mysql&quot;{print $3}&apos; /etc/passwd                 //不等于awk -F&quot;:&quot; &apos;$3&gt;1000{print $3}&apos; /etc/passwd                      //大于awk -F&quot;:&quot; &apos;$3&gt;=100{print $3}&apos; /etc/passwd                     //大于等于awk -F&quot;:&quot; &apos;$3&lt;1{print $3}&apos; /etc/passwd                            //小于awk -F&quot;:&quot; &apos;$3&lt;=1{print $3}&apos; /etc/passwd                         //小于等于逻辑运算符&amp;&amp;　|| awk -F: &apos;$1~/mail/ &amp;&amp; $3&gt;8 {print }&apos; /etc/passwd         //逻辑与，$1匹配mail，并且$3&gt;8awk -F: &apos;{if($1~/mail/ &amp;&amp; $3&gt;8) print }&apos; /etc/passwdawk -F: &apos;$1~/mail/ || $3&gt;1000 {print }&apos; /etc/passwd       //逻辑或awk -F: &apos;{if($1~/mail/ || $3&gt;1000) print }&apos; /etc/passwd 数值运算awk -F: &apos;$3 &gt; 100&apos; /etc/passwd    awk -F: &apos;$3 &gt; 100 || $3 &lt; 5&apos; /etc/passwd  awk -F: &apos;$3+$4 &gt; 200&apos; /etc/passwdawk -F: &apos;/mysql|mail/{print $3+10}&apos; /etc/passwd                    //第三个字段加10打印 awk -F: &apos;/mysql/{print $3-$4}&apos; /etc/passwd                             //减法awk -F: &apos;/mysql/{print $3*$4}&apos; /etc/passwd                             //求乘积awk &apos;/MemFree/{print $2/1024}&apos; /proc/meminfo                  //除法awk &apos;/MemFree/{print int($2/1024)}&apos; /proc/meminfo           //取整输出分隔符OFSawk &apos;$6 ~ /FIN/ || NR==1 {print NR,$4,$5,$6}&apos; OFS=&quot;\t&quot; netstat.txtawk &apos;$6 ~ /WAIT/ || NR==1 {print NR,$4,$5,$6}&apos; OFS=&quot;\t&quot; netstat.txt        //输出字段6匹配WAIT的行，其中输出每行行号，字段4，5,6，并使用制表符分割字段输出处理结果到文件①在命令代码块中直接输出    route -n|awk &apos;NR!=1{print &gt; &quot;./fs&quot;}&apos;   ②使用重定向进行输出           route -n|awk &apos;NR!=1{print}&apos;  &gt; ./fs格式化输出netstat -anp|awk &apos;{printf &quot;%-8s %-8s %-10s\n&quot;,$1,$2,$3}&apos; printf表示格式输出%格式化输出分隔符-8长度为8个字符s表示字符串类型打印每行前三个字段，指定第一个字段输出字符串类型(长度为8)，第二个字段输出字符串类型(长度为8),第三个字段输出字符串类型(长度为10)netstat -anp|awk &apos;$6==&quot;LISTEN&quot; || NR==1 {printf &quot;%-10s %-10s %-10s \n&quot;,$1,$2,$3}&apos;netstat -anp|awk &apos;$6==&quot;LISTEN&quot; || NR==1 {printf &quot;%-3s %-10s %-10s %-10s \n&quot;,NR,$1,$2,$3}&apos;IF语句awk -F: &apos;{if($3&gt;100) print &quot;large&quot;; else print &quot;small&quot;}&apos; /etc/passwdsmallsmallsmalllargesmallsmallawk -F: &apos;BEGIN{A=0;B=0} {if($3&gt;100) {A++; print &quot;large&quot;} else {B++; print &quot;small&quot;}} END{print A,&quot;\t&quot;,B}&apos; /etc/passwd                                                                                                                 //ID大于100,A加1，否则B加1awk -F: &apos;{if($3&lt;100) next; else print}&apos; /etc/passwd                         //小于100跳过，否则显示awk -F: &apos;BEGIN{i=1} {if(i&lt;NF) print NR,NF,i++ }&apos; /etc/passwd   awk -F: &apos;BEGIN{i=1} {if(i&lt;NF) {print NR,NF} i++ }&apos; /etc/passwd另一种形式awk -F: &apos;{print ($3&gt;100 ? &quot;yes&quot;:&quot;no&quot;)}&apos;  /etc/passwd awk -F: &apos;{print ($3&gt;100 ? $3&quot;:\tyes&quot;:$3&quot;:\tno&quot;)}&apos;  /etc/passwdwhile语句awk -F: &apos;BEGIN{i=1} {while(i&lt;NF) print NF,$i,i++}&apos; /etc/passwd 7 root 17 x 27 0 37 0 47 root 57 /root 6数组netstat -anp|awk &apos;NR!=1{a[$6]++} END{for (i in a) print i,&quot;\t&quot;,a[i]}&apos;netstat -anp|awk &apos;NR!=1{a[$6]++} END{for (i in a) printf &quot;%-20s %-10s %-5s \n&quot;, i,&quot;\t&quot;,a[i]}&apos;9523                               1     9929                               1     LISTEN                            6     7903                               1     3038/cupsd                   1     7913                               1     10837                             1     9833                               1     应用1awk -F: &apos;{print NF}&apos; helloworld.sh                                                       //输出文件每行有多少字段awk -F: &apos;{print $1,$2,$3,$4,$5}&apos; helloworld.sh                                 //输出前5个字段awk -F: &apos;{print $1,$2,$3,$4,$5}&apos; OFS=&apos;\t&apos; helloworld.sh                 //输出前5个字段并使用制表符分隔输出awk -F: &apos;{print NR,$1,$2,$3,$4,$5}&apos; OFS=&apos;\t&apos; helloworld.sh           //制表符分隔输出前5个字段，并打印行号应用2awk -F&apos;[:#]&apos; &apos;{print NF}&apos;  helloworld.sh                                                  //指定多个分隔符: #，输出每行多少字段awk -F&apos;[:#]&apos; &apos;{print $1,$2,$3,$4,$5,$6,$7}&apos; OFS=&apos;\t&apos; helloworld.sh   //制表符分隔输出多字段应用3awk -F&apos;[:#/]&apos; &apos;{print NF}&apos; helloworld.sh                                               //指定三个分隔符，并输出每行字段数awk -F&apos;[:#/]&apos; &apos;{print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12}&apos; helloworld.sh     //制表符分隔输出多字段应用4计算/home目录下，普通文件的大小，使用KB作为单位ls -l|awk &apos;BEGIN{sum=0} !/^d/{sum+=$5} END{print &quot;total size is:&quot;,sum/1024,&quot;KB&quot;}&apos;ls -l|awk &apos;BEGIN{sum=0} !/^d/{sum+=$5} END{print &quot;total size is:&quot;,int(sum/1024),&quot;KB&quot;}&apos;         //int是取整的意思应用5统计netstat -anp 状态为LISTEN和CONNECT的连接数量分别是多少netstat -anp|awk &apos;$6~/LISTEN|CONNECTED/{sum[$6]++} END{for (i in sum) printf &quot;%-10s %-6s %-3s \n&quot;, i,&quot; &quot;,sum[i]}&apos;应用6统计/home目录下不同用户的普通文件的总数是多少？ls -l|awk &apos;NR!=1 &amp;&amp; !/^d/{sum[$3]++} END{for (i in sum) printf &quot;%-6s %-5s %-3s \n&quot;,i,&quot; &quot;,sum[i]}&apos;   mysql        199 root           374 统计/home目录下不同用户的普通文件的大小总size是多少？ls -l|awk &apos;NR!=1 &amp;&amp; !/^d/{sum[$3]+=$5} END{for (i in sum) printf &quot;%-6s %-5s %-3s %-2s \n&quot;,i,&quot; &quot;,sum[i]/1024/1024,&quot;MB&quot;}&apos;应用7输出成绩表awk &apos;BEGIN{math=0;eng=0;com=0;printf &quot;Lineno.   Name    No.    Math   English   Computer    Total\n&quot;;printf &quot;------------------------------------------------------------\n&quot;}{math+=$3; eng+=$4; com+=$5;printf &quot;%-8s %-7s %-7s %-7s %-9s %-10s %-7s \n&quot;,NR,$1,$2,$3,$4,$5,$3+$4+$5} END{printf &quot;------------------------------------------------------------\n&quot;;printf &quot;%-24s %-7s %-9s %-20s \n&quot;,&quot;Total:&quot;,math,eng,com;printf &quot;%-24s %-7s %-9s %-20s \n&quot;,&quot;Avg:&quot;,math/NR,eng/NR,com/NR}&apos; test0[root@localhost home]# cat test0 Marry   2143 78 84 77Jack    2321 66 78 45Tom     2122 48 77 71Mike    2537 87 97 95Bob     2415 40 57 62awk手册http://www.chinaunix.net/old_jh/7/16985.html</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;awk&quot;&gt;&lt;a href=&quot;#awk&quot; class=&quot;headerlink&quot; title=&quot;awk&quot;&gt;&lt;/a&gt;awk&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;awk是行处理器: 相比较屏幕处理的优点，在处理庞大文件时不会出现内存溢出或是处理缓慢的问题，通常用来格式化文本信息
awk处理过程: 依次对每一行进行处理，然后输出
awk命令形式:
awk [-F|-f|-v] ‘BEGIN{} //{command1; command2} END{}’ file
[-F|-f|-v]   大参数，-F指定分隔符，-f调用脚本，-v定义变量 var=value
&amp;apos;  &amp;apos;          引用代码块
BEGIN   初始化代码块，在对每一行进行处理之前，初始化代码，主要是引用全局变量，设置FS分隔符
//           匹配代码块，可以是字符串或正则表达式
{}           命令代码块，包含一条或多条命令
；          多条命令使用分号分隔
END      结尾代码块，在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="linux" scheme="http://ymliang.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://ymliang.com/tags/linux/"/>
    
  </entry>
  
</feed>
